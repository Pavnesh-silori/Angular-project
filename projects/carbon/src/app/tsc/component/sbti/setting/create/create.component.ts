import { Component, EventEmitter, OnInit, Output } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';

import {
    AbstractControl,
    FormBuilder,
    FormGroup,
    Validators
} from '@angular/forms';

import { MatDialog } from '@angular/material/dialog';

import { isEqual } from 'lodash';
import { startWith } from 'rxjs/operators';

import { Location } from '@angular/common';

import { DeleteDialog } from '../_shared/delete/delete-dialog.component';
import { EmissionDifferenceViewComponent } from '../emission-difference-view/emission-difference-view.component';
import { SettingChangeDialog } from '../_shared/setting-change-dialog/setting-change-dialog.component';

import { OrgSizeEnum, ScopeTwoMethodEnum } from '@carbon/enum/sbti.enum';
import { BaseYearEnum } from '@carbon/enum/base-year.enum';
import { SbtiSector, SbtiSectorM, SbtiSetting, SbtiSettingDifference, SbtiSettingDifferenceM, SbtiSettingM } from '@carbon/model/sbti.model';
import { ConsolidationApproachM } from '@carbon/model/consolidation-approach.model'; 
import { GhgBaseYearController } from '@carbon/controller/ghg-base-year.controller';
import { SbtiController } from '@carbon/controller/sbti.controller';

import { PreferenceService } from '@carbon/service/preference.service';
import { ConsolidationApproachService } from '@carbon/service/consolidation-approach.service';
import { SbtiService } from '@carbon/service/sbti.service';

// tsc-library
import { DateService } from '@library/date';
import { ToastrColor, ToastrService } from '@library/toastr-service';
import { ButtonLabelEnum, DialogEnum, DialogResponseEnum, FormAction, InvalidForm, MATERIAL_CONSTANT, MatSelectSearchService, MaterialFormFieldAppearance } from '@library/tsc-common';
import { StorageService } from '@library/storage-service';
import { Organization, OrganizationM, OrganizationService } from '@library/organization-service';
import { InfoDialogComponent } from '@library/tsc-common';
// /tsc-library

@Component({
    selector: 'sbti-setting-create',
    templateUrl: './create.component.html',
    styleUrls: ['./create.component.scss']
})

export class CreateComponent implements OnInit {

    FormFieldAppearance = MaterialFormFieldAppearance;
    MATERIAL_CONSTANT = MATERIAL_CONSTANT;
    FormAction = FormAction;
    ButtonLabelEnum = ButtonLabelEnum;

    OrgSize = OrgSizeEnum;
    ScopeTwoMethod = ScopeTwoMethodEnum;
    sbtiSector = [new SbtiSector()];

    currentYear: number = this.dateService.getCurrentYear();
    minYear: number = 2018;
    maxYear: number = this.currentYear - 1;
    currentValueYear = this.currentYear - 1;
    year: number[] = [];
    rootOrgID: any;

    @Output() created: EventEmitter<boolean> = new EventEmitter(false);

    sbtiSettingFG: FormGroup;
    sbtiSetting = new SbtiSetting();
    action: string;
    sbtiSettingID: any;

    sectorSearchUtility: MatSelectSearchService = new MatSelectSearchService(['name']);

    financialInstitutionInfo = {
        title: 'Financial institution',
        body: `<ul class="ps-3">
        <li>Asset management/asset owners.</li>
        <li>Retail and commercial banking activities.</li>
        <li>Insurance companies (when functioning asset managers).</li>
        <li>Mortgage real estate investment trusts (REITs).</li>
        <li>In addition, if at least 5% of a company’s revenue comes from activities such as those described above, they would be considered a financial institution.</li>
        </ul>`
    }

    fossilFuelCompanyInfo = {
        title: 'Fossil fuel company',
        body: `<ul class="ps-3">
        <li>Companies involved in exploration, extraction, mining and/or production of oil, natural gas, coal or other fossil fuels, irrespective of percentage revenue generated by these activities.</li>
        <li>Companies within the oil and gas sector, including, but not limited to, integrated oil and gas companies, integrated gas companies, exploration and production pure players, refining and marketing pure players, oil products distributors, gas distributors and retailers, and traditional oil and gas service companies.</li>
        <li>Companies that derive 50% or more of revenue from fossil fuels sale, transmission and distribution, services and any other activity along the value chain with dedicated infrastructure.</li>
        <li>Companies with more than 5% revenue from dormant or active fossil fuel assets (e.g. coal mine, lignite mine, etc.) for extraction activities with commercial purposes (excluding electric utilities that mine coal for their own power generation).</li>
        </ul>`
    }

    baseYearInfo = {
        title: 'Base year',
        body: ` Base year is the year for which your organization has verifiable data on scope 1, 2, and 3 emissions. SBTi recommended that companies choose the most recent year for which data is available as the base year. The base year should be representative of a company’s typical GHG profile. `
    }

    isUseOfSoldProductsInfo = `Companies that sell, transmit, or distribute natural gas – or other fossil fuel products – 
                            shall set emission reduction scope 3 targets for the “use of sold products” category, irrespective 
                            of the share of these emissions compared to the total scope 1, 2, and 3 emissions of the company.`;

    agreementInfo = {
        title: '',
        body: `Companies shall remove carbon from the atmosphere and permanently store it to counterbalance the impact of any unabated emissions that remain once companies have achieved their long-term science-based target, and for subsequent years thereafter.
                     The neutralization of unabated emissions applies to both the emissions reduction target(s) boundary and to any unabated emissions that have been excluded from the GHG inventory.`
    }

    isSME: String = 'DEFAULT';

    meetsSBTiCriteria: boolean = true;
    ghgBaseYearExist: boolean = false;
    isPreferenceSet: boolean = false;

    ghgBaseYear: any = null;
    ghgSetup: any;

    consolidationApproach: ConsolidationApproachM[] = [];

    agreementQuestions = [
        {
            question: `publicly report its company-wide GHG emissions inventory and progress against published target on an annual basis.`,
            checked: false
        },
        {
            question: `not use carbon credits to show emission reductions toward the progress of companies’ near-term or long-term science-based targets.`,
            checked: false
        },
        {
            question: `not count avoided emissions toward near-term or long-term science-based emission reduction targets`,
            checked: false
        },
        {
            question: `get its targets reviewed, and if necessary, recalculated and revalidated, at a minimum every 5 years`,
            checked: false
        },
        {
            question: `announce their target publicly on the SBTi website within 6 months of the approval date.`,
            checked: false
        }, {
            question: `neutralize any unabated emissions once it achieves its long term targets`,
            checked: false
        }
    ];

    orgSize: any = null;
    showAgreementError = false;
    organizationM = new Organization();

    isEqual: boolean = false;
    initialObject: any = null;

    sbtiSettingDifference = [new SbtiSettingDifference()];

    constructor(
        private activatedRoute: ActivatedRoute,
        private router: Router,
        private matDialog: MatDialog,
        private fb: FormBuilder,
        private organizationService: OrganizationService,
        private storageService: StorageService,
        private toastrService: ToastrService,
        private ghgBaseYearController: GhgBaseYearController,
        private sbtiController: SbtiController,
        private preferenceService: PreferenceService,
        private consolidationApproachService: ConsolidationApproachService,
        private sbtiService: SbtiService,
        private dateService: DateService,
        private location: Location
    ) { }

    ngOnInit(): void {
        this.activatedRoute.data.subscribe((data) => {
            this.action = data['action'];

            if (this.action != FormAction.UPDATE && this.action != FormAction.CREATE) {
                this.router.navigate(['/page-not-found']);
            }
        });

        this.rootOrgID = this.storageService.getStorage('rootOrgID');
        this.createSbtiSettingInit();
        this.getOrgPreference();
    }

    async getOrgPreference() {
        let preference = await this.preferenceService.getOrgPreference(this.rootOrgID);

        if (preference.preferenceID != null) {
            this.isPreferenceSet = true;

            this.getAllSbtiSector();
            this.getOrgByID(this.rootOrgID);
            this.getSBTiSettingsByOrgID();
            this.getGHGBaseYear();
            this.getConsolidationApproachList();
        }
    }

    async getConsolidationApproachList() {
        this.consolidationApproach = await this.consolidationApproachService.getAllConsolidationApproachByOrgID(this.rootOrgID);
        if (this.consolidationApproach.length == 1) {
            this.sbtiSettingFG.get('consolidationApproachKeyID').disable();
            let approach = this.consolidationApproach[0]['keyID'];
            this.sbtiSettingFG.get('consolidationApproachKeyID').patchValue(approach);
        }
    }

    createSbtiSettingInit() {
        this.sbtiSettingFG = this.fb.group({
            orgSizeKeyID: [, Validators.required],
            isUseOfSoldProducts: [],
            sbtiSectorID: [, Validators.required],
            isBaseYearSameAsGHG: [, Validators.required],
            calculationApproachKeyID: [, Validators.required],
            consolidationApproachKeyID: [, Validators.required],
        });
    }

    get orgSizeKeyIDAC(): AbstractControl {
        return this.sbtiSettingFG.get('orgSizeKeyID') as AbstractControl;
    }

    get isUseOfSoldProductsAC(): AbstractControl {
        return this.sbtiSettingFG.get('isUseOfSoldProducts') as AbstractControl;
    }

    get isBaseYearSameAsGHGAC(): AbstractControl {
        return this.sbtiSettingFG.get('isBaseYearSameAsGHG') as AbstractControl;
    }

    getGHGBaseYear() {
        this.ghgBaseYearController.getBaseYearByOrgIDAndType(this.rootOrgID, BaseYearEnum.GHG_BASE_YEAR)
            .subscribe((ghg) => {
                if (ghg['baseYear'] != null) {
                    this.ghgSetup = ghg;
                    this.ghgBaseYearExist = true;
                    this.ghgBaseYear = ghg['baseYear'];
                } else {
                    this.isBaseYearSameAsGHGAC.patchValue(false);
                }
                this.orgSizeKeyIDAC.valueChanges.pipe(startWith({})).subscribe((orgSize) => this.orgSizeChange(orgSize));
            })
    }

    orgSizeChange(orgSize) {
        this.meetsSBTiCriteria = true;
        this.isUseOfSoldProductsAC.clearValidators();
        if (this.ghgBaseYearExist) {
            this.isBaseYearSameAsGHGAC.reset();

            if (this.ghgSetup.significanceThreshold > 5) {
                this.meetsSBTiCriteria = false;
                this.isBaseYearSameAsGHGAC.patchValue(false);
            }

            if (orgSize == OrgSizeEnum.NON_SME) {
                this.isUseOfSoldProductsAC.setValidators([Validators.required]);
                if (this.ghgBaseYear < 2015) {
                    this.meetsSBTiCriteria = false;
                    this.isSME = 'NO';
                    this.isBaseYearSameAsGHGAC.patchValue(false);
                }
            } else if (orgSize == OrgSizeEnum.SME && this.ghgBaseYear < 2018) {
                this.meetsSBTiCriteria = false;
                this.isBaseYearSameAsGHGAC.patchValue(false);
                this.isSME = 'YES';
            }
        }
        this.isUseOfSoldProductsAC.updateValueAndValidity();
    }

    async getSBTiSettingsByOrgID() {
        this.sbtiSetting = <SbtiSettingM>await this.sbtiService.getSbtiSettingsByOrgID(this.rootOrgID);

        if (this.action == FormAction.UPDATE) {
            this.patchSbtiSettingForm(this.sbtiSetting);
        } 
    }

    patchSbtiSettingForm(settings) {
        this.sbtiSettingFG.patchValue(settings, { emitEvent: false });
        this.initialObject = this.sbtiSettingFG.getRawValue();

        this.sbtiSettingFG.valueChanges.pipe(startWith({}))
            .subscribe(() => {
                this.isEqual = isEqual(this.initialObject, this.sbtiSettingFG.getRawValue());
            });

        this.sbtiSettingID = settings.id;
        this.orgSize = settings.orgSizeKeyID;
        if (this.orgSize == OrgSizeEnum.NON_SME) {
            this.agreementQuestions.forEach(q => q['checked'] = true);
        }
    }

    async getAllSbtiSector() {
        let sbtiSector = <SbtiSectorM[]>await this.sbtiService.getAllSbtiSector();

        this.sectorSearchUtility.entityArr = sbtiSector;
        this.sectorSearchUtility.createSubscription();
    }

    validationCheck() {
        if (this.orgSizeKeyIDAC.value == OrgSizeEnum.NON_SME) {
            const isAllChecked = this.agreementQuestions.every(question => question.checked);
            this.showAgreementError = !isAllChecked;
            if (!isAllChecked) {
                this.toastrService.openToast(InvalidForm.INVALID_FORM_TITLE, InvalidForm.INVALID_FORM_MESSAGE, ToastrColor.ERROR);
                return;
            }
        }

        if (this.sbtiSettingFG.invalid) {
            this.sbtiSettingFG.markAllAsTouched();
            this.toastrService.openToast(InvalidForm.INVALID_FORM_TITLE, InvalidForm.INVALID_FORM_MESSAGE, ToastrColor.ERROR);
            return;
        }
    }

    checkValidation(){
        const isAllChecked = this.agreementQuestions.every(question => question.checked);
        this.showAgreementError = isAllChecked;
    }

    async getSettingEmissionDifference() {
        if (this.sbtiSettingFG.invalid) {
            this.sbtiSettingFG.markAllAsTouched();
            this.toastrService.openToast(InvalidForm.INVALID_FORM_TITLE, InvalidForm.INVALID_FORM_MESSAGE, ToastrColor.ERROR);
            return;
        }

        if (this.orgSizeKeyIDAC.value == OrgSizeEnum.NON_SME) {
            const isAllChecked = this.agreementQuestions.every(question => question.checked);
            this.showAgreementError = !isAllChecked;
            if (!isAllChecked) {
                this.toastrService.openToast(InvalidForm.INVALID_FORM_TITLE, InvalidForm.INVALID_FORM_MESSAGE, ToastrColor.ERROR);
                return;
            }
        }

        if (this.sbtiSettingFG.value['orgSizeKeyID'] == this.sbtiSetting['orgSizeKeyID'] &&
            (this.sbtiSettingFG.value['isBaseYearSameAsGHG'] != this.sbtiSetting['isBaseYearSameAsGHG'] ||
                this.sbtiSettingFG.value['calculationApproachKeyID'] != this.sbtiSetting['calculationApproachKeyID'] ||
                this.sbtiSettingFG.value['consolidationApproachKeyID'] != this.sbtiSetting['consolidationApproachKeyID'])) {

            this.sbtiSettingDifference = <SbtiSettingDifferenceM[]>await this.sbtiService.getSettingEmissionDifference(this.rootOrgID, this.sbtiSettingFG.value);
            if (this.sbtiSettingDifference.length > 0) {
                this.openSettingEmissionDifferencDialog(this.sbtiSettingDifference);
            } else {
                this.submitSbtiSetting();
            }
        } else {
            this.submitSbtiSetting();
        }
    }

    openSettingEmissionDifferencDialog(sbtiSettingDifference) {
        let dialogRef;
        dialogRef = this.matDialog.open(EmissionDifferenceViewComponent, {
            data: {
                sbtiSettingDifference: sbtiSettingDifference
            },
            minWidth: '55vw',
            maxWidth: '55vw',
            height: '100%',
            position: { right: '-2px', top: '0px' },
        });

        dialogRef.afterClosed().subscribe((res) => {
            if (res == DialogResponseEnum.YES) {
                this.submitSbtiSetting()
            }
        });
    }

    confimationOrgSizeChange() {
        if (this.sbtiSettingFG.value['orgSizeKeyID'] == OrgSizeEnum.NON_SME) {
            this.isUseOfSoldProductsAC.setValidators([Validators.required]);
        }
        if (this.action == FormAction.UPDATE && this.sbtiSettingFG.value['orgSizeKeyID'] != this.sbtiSetting['orgSizeKeyID']) {
            let dialogRef;
            dialogRef = this.matDialog.open(SettingChangeDialog, {
                maxWidth: '600px'
            });
            dialogRef.afterClosed().subscribe((res) => {
                if (res == DialogEnum.SUCCESS_DR) {
                    this.sbtiSettingFG.controls['orgSizeKeyID'].setValue(this.sbtiSetting['orgSizeKeyID']);
                }
            });
        }
    }

    submitSbtiSetting() {
        if (this.sbtiSettingFG.invalid) {
            this.sbtiSettingFG.markAllAsTouched();
			this.toastrService.openToast(InvalidForm.INVALID_FORM_TITLE, InvalidForm.INVALID_FORM_MESSAGE, ToastrColor.ERROR);
            return;
        }

        if (this.orgSizeKeyIDAC.value == OrgSizeEnum.NON_SME) {
            const isAllChecked = this.agreementQuestions.every(question => question.checked);
            this.showAgreementError = !isAllChecked;
            if (!isAllChecked) {
                this.toastrService.openToast(InvalidForm.INVALID_FORM_TITLE, InvalidForm.INVALID_FORM_MESSAGE, ToastrColor.ERROR);
                return;
            }
        }

        if (this.action == FormAction.UPDATE) {
            this.updateSbtiSetting();
        } else if (this.action == FormAction.CREATE) {
            this.createSbtiSetting();
        }
    }

    createSbtiSetting() {
        this.sbtiController.createSbtiSetting(this.rootOrgID, this.sbtiSettingFG.getRawValue()).subscribe(submitSbtiSettingRes => {
            this.created.emit();
        }, error => {
            console.error('error in submitSBTISetting', error);
        });
    }

    updateSbtiSetting() {
        this.sbtiController.updateSbtiSetting(this.rootOrgID, this.sbtiSettingFG.getRawValue(), this.sbtiSettingID).subscribe(submitSbtiSettingRes => {
            this.router.navigate(['/target-setting/sbti']);
        }, error => {
            console.error('error in updateSbtiSetting', error);
        });
    }

    async getOrgByID(orgID) {
        this.organizationM = <OrganizationM>await this.organizationService.getOrganizationByID(orgID);
    }

    openInfoDialog(data) {
        const dialog = this.matDialog.open(InfoDialogComponent,
            {
                data: data,
                minWidth: '400px',
                maxWidth: '500px',
            });
    }

    confirmBaseYearTypeChange() {
        if (this.action == FormAction.UPDATE && this.sbtiSettingFG.value['isBaseYearSameAsGHG'] ^ <any>this.sbtiSetting['isBaseYearSameAsGHG']) {
            const title = "Inactive existing SBTi Base year?";
            let message = "All targets for this SBTi base year will be inactive permanently. GHG base year will remain unaffected and you can create a new SBTi base year from ";
            let btnLabel = 'Inactive and Save';
            if (this.sbtiSettingFG.value['isBaseYearSameAsGHG']) {
                message = "All targets for this SBTi base year will be deleted permanently. GHG base year will remain unaffected and new SBTi base year will be synced with GHG base year";
                btnLabel = 'Inactive targets and Save';
            }
            const confirmationMsg = "Are you sure you want inactive all existing targets?";
            const dialogRef = this.matDialog.open(DeleteDialog, {
                data: {
                    isBaseYearSameAsGHG: this.sbtiSettingFG.value['isBaseYearSameAsGHG'],
                    title: title,
                    message: message,
                    confirmationMsg: confirmationMsg,
                    btnLabel: btnLabel,
                    page: 'SBTI'
                },
                minWidth: '500px',
                maxWidth: '600px'
            });
            dialogRef.afterClosed().subscribe(res => {
                if (res != DialogEnum.DELETE_DR)
                    this.sbtiSettingFG.controls['isBaseYearSameAsGHG'].setValue(this.sbtiSetting['isBaseYearSameAsGHG']);
            });
        }
    }

    backBtnClick() {
        this.location.back();
    }

    populateYear() {
        for (let year = this.minYear; year <= this.maxYear; year++) {
            this.year.push(year);
        }
    }

    public errorHandling = (control: string, error: string) => {
        return this.sbtiSettingFG.controls[control].hasError(error) && this.sbtiSettingFG.controls[control].touched;
    }

    public radioGroupHasError = (control: string, error: string) => {
        return this.sbtiSettingFG.controls[control].hasError(error) && this.sbtiSettingFG.controls[control].touched;
    }
}
