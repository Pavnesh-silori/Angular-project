import { animate, keyframes, state, style, transition, trigger } from '@angular/animations';
import { Component, Input, ViewChild } from '@angular/core';
import { buildLinearPath, buildSmoothPath } from '../helpers/DOM.helpers';
import { normalize } from '../helpers/math.helpers';
import { generateId } from '../helpers/misc.helpers';
import { normalizeDataset } from './trend.helpers';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = ["pathEl"];
function TrendComponent__svg_svg_0__svg_defs_1__svg_stop_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "stop");
} if (rf & 2) {
    const g_r4 = ctx.$implicit;
    ɵngcc0.ɵɵattribute("key", g_r4.idx)("offset", g_r4.offset)("stop-color", g_r4.stopColor);
} }
function TrendComponent__svg_svg_0__svg_defs_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelementStart(1, "linearGradient", 3);
    ɵngcc0.ɵɵtemplate(2, TrendComponent__svg_svg_0__svg_defs_1__svg_stop_2_Template, 1, 3, "stop", 4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("id", ctx_r1.gradientId);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.gradientTrimmed);
} }
const _c1 = function (a0, a1, a2) { return { autoDrawDuration: a0, autoDrawEasing: a1, lineLength: a2 }; };
const _c2 = function (a0, a1) { return { value: a0, params: a1 }; };
function TrendComponent__svg_svg_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "svg");
    ɵngcc0.ɵɵtemplate(1, TrendComponent__svg_svg_0__svg_defs_1_Template, 3, 2, "defs", 0);
    ɵngcc0.ɵɵelement(2, "path", 1, 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("width", ctx_r0.svgWidth)("height", ctx_r0.svgHeight)("stroke", ctx_r0.stroke)("stroke-width", ctx_r0.strokeWidth)("stroke-linecap", ctx_r0.strokeLinecap)("viewBox", ctx_r0.viewBox)("preserveAspectRatio", ctx_r0.preserveAspectRatio);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.gradient && ctx_r0.gradient.length);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("@pathAnimaiton", ɵngcc0.ɵɵpureFunction2(15, _c2, ctx_r0.animationState, ɵngcc0.ɵɵpureFunction3(11, _c1, ctx_r0.autoDrawDuration, ctx_r0.autoDrawEasing, ctx_r0.lineLength)));
    ɵngcc0.ɵɵattribute("stroke", ctx_r0.pathStroke)("d", ctx_r0.d);
} }
export class TrendComponent {
    constructor() {
        this.autoDraw = false;
        this.autoDrawDuration = 2000;
        this.autoDrawEasing = 'ease';
        this.padding = 8;
        this.radius = 10;
        this.stroke = 'black';
        this.strokeLinecap = '';
        this.strokeWidth = 1;
        this.gradient = [];
        this.svgHeight = '25%';
        this.svgWidth = '100%';
        this.animationState = '';
        this.id = generateId();
        this.gradientId = `ngx-trend-vertical-gradient-${this.id}`;
    }
    ngOnChanges() {
        // We need at least 2 points to draw a graph.
        if (!this.data || this.data.length < 2) {
            return;
        }
        // `data` can either be an array of numbers:
        // [1, 2, 3]
        // or, an array of objects containing a value:
        // [{ value: 1 }, { value: 2 }, { value: 3 }]
        //
        // For now, we're just going to convert the second form to the first.
        // Later on, if/when we support tooltips, we may adjust.
        const plainValues = this.data.map(point => {
            if (typeof point === 'number') {
                return point;
            }
            return point.value;
        });
        // Our viewbox needs to be in absolute units, so we'll default to 300x75
        // Our SVG can be a %, though; this is what makes it scalable.
        // By defaulting to percentages, the SVG will grow to fill its parent
        // container, preserving a 1/4 aspect ratio.
        const viewBoxWidth = this.width || 300;
        const viewBoxHeight = this.height || 75;
        this.svgWidth = this.width || '100%';
        this.svgHeight = this.height || '25%';
        this.viewBox = `0 0 ${viewBoxWidth} ${viewBoxHeight}`;
        const root = location.href.split(location.hash || '#')[0];
        this.pathStroke =
            this.gradient && this.gradient.length ? `url('${root}#${this.gradientId}')` : undefined;
        this.gradientTrimmed = this.gradient
            .slice()
            .reverse()
            .map((val, idx) => {
            return {
                idx,
                stopColor: val,
                offset: normalize(idx, 0, this.gradient.length - 1 || 1),
            };
        });
        const normalizedValues = normalizeDataset(plainValues, this.padding, viewBoxWidth - this.padding, 
        // NOTE: Because SVGs are indexed from the top left, but most data is
        // indexed from the bottom left, we're inverting the Y min/max.
        viewBoxHeight - this.padding, this.padding);
        if (this.autoDraw && this.animationState !== 'active') {
            this.animationState = 'inactive';
            setTimeout(() => {
                this.lineLength = this.pathEl.nativeElement.getTotalLength();
                this.animationState = 'active';
            });
        }
        this.d = this.smooth
            ? buildSmoothPath(normalizedValues, this.radius)
            : buildLinearPath(normalizedValues);
    }
}
TrendComponent.ɵfac = function TrendComponent_Factory(t) { return new (t || TrendComponent)(); };
TrendComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TrendComponent, selectors: [["ngx-trend"]], viewQuery: function TrendComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.pathEl = _t.first);
    } }, inputs: { autoDraw: "autoDraw", autoDrawDuration: "autoDrawDuration", autoDrawEasing: "autoDrawEasing", padding: "padding", radius: "radius", stroke: "stroke", strokeLinecap: "strokeLinecap", strokeWidth: "strokeWidth", gradient: "gradient", svgHeight: "svgHeight", svgWidth: "svgWidth", data: "data", smooth: "smooth", width: "width", height: "height", preserveAspectRatio: "preserveAspectRatio" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 1, consts: [[4, "ngIf"], ["fill", "none"], ["pathEl", ""], ["x1", "0%", "y1", "0%", "x2", "0%", "y2", "100%"], [4, "ngFor", "ngForOf"]], template: function TrendComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TrendComponent__svg_svg_0_Template, 4, 18, "svg", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.data && ctx.data.length >= 2);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf], encapsulation: 2, data: { animation: [
            trigger('pathAnimaiton', [
                state('inactive', style({ display: 'none' })),
                transition('* => active', [
                    style({ display: 'initial' }),
                    // We do the animation using the dash array/offset trick
                    // https://css-tricks.com/svg-line-animation-works/
                    animate('{{ autoDrawDuration }}ms {{ autoDrawEasing }}', keyframes([
                        style({
                            'stroke-dasharray': '{{ lineLength }}px',
                            'stroke-dashoffset': '{{ lineLength }}px'
                        }),
                        style({
                            'stroke-dasharray': '{{ lineLength }}px',
                            'stroke-dashoffset': 0
                        }),
                    ])),
                    // One unfortunate side-effect of the auto-draw is that the line is
                    // actually 1 big dash, the same length as the line itself. If the
                    // line length changes (eg. radius change, new data), that dash won't
                    // be the same length anymore. We can fix that by removing those
                    // properties once the auto-draw is completed.
                    style({
                        'stroke-dashoffset': '',
                        'stroke-dasharray': ''
                    }),
                ]),
            ]),
        ] } });
TrendComponent.ctorParameters = () => [];
TrendComponent.propDecorators = {
    data: [{ type: Input }],
    smooth: [{ type: Input }],
    autoDraw: [{ type: Input }],
    autoDrawDuration: [{ type: Input }],
    autoDrawEasing: [{ type: Input }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    padding: [{ type: Input }],
    radius: [{ type: Input }],
    stroke: [{ type: Input }],
    strokeLinecap: [{ type: Input }],
    strokeWidth: [{ type: Input }],
    gradient: [{ type: Input }],
    preserveAspectRatio: [{ type: Input }],
    svgHeight: [{ type: Input }],
    svgWidth: [{ type: Input }],
    pathEl: [{ type: ViewChild, args: ['pathEl',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TrendComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-trend',
                template: `
    <svg
      *ngIf="data && data.length >= 2"
      [attr.width]="svgWidth"
      [attr.height]="svgHeight"
      [attr.stroke]="stroke"
      [attr.stroke-width]="strokeWidth"
      [attr.stroke-linecap]="strokeLinecap"
      [attr.viewBox]="viewBox"
      [attr.preserveAspectRatio]="preserveAspectRatio"
    >
      <defs *ngIf="gradient && gradient.length">
        <linearGradient [attr.id]="gradientId" x1="0%" y1="0%" x2="0%" y2="100%">
          <stop
            *ngFor="let g of gradientTrimmed"
            [attr.key]="g.idx"
            [attr.offset]="g.offset"
            [attr.stop-color]="g.stopColor"
          />
        </linearGradient>
      </defs>
      <path
        fill="none"
        #pathEl
        [attr.stroke]="pathStroke"
        [attr.d]="d"
        [@pathAnimaiton]="{
          value: animationState,
          params: {
            autoDrawDuration: autoDrawDuration,
            autoDrawEasing: autoDrawEasing,
            lineLength: lineLength
          }
        }"
      />
    </svg>
  `,
                animations: [
                    trigger('pathAnimaiton', [
                        state('inactive', style({ display: 'none' })),
                        transition('* => active', [
                            style({ display: 'initial' }),
                            // We do the animation using the dash array/offset trick
                            // https://css-tricks.com/svg-line-animation-works/
                            animate('{{ autoDrawDuration }}ms {{ autoDrawEasing }}', keyframes([
                                style({
                                    'stroke-dasharray': '{{ lineLength }}px',
                                    'stroke-dashoffset': '{{ lineLength }}px'
                                }),
                                style({
                                    'stroke-dasharray': '{{ lineLength }}px',
                                    'stroke-dashoffset': 0
                                }),
                            ])),
                            // One unfortunate side-effect of the auto-draw is that the line is
                            // actually 1 big dash, the same length as the line itself. If the
                            // line length changes (eg. radius change, new data), that dash won't
                            // be the same length anymore. We can fix that by removing those
                            // properties once the auto-draw is completed.
                            style({
                                'stroke-dashoffset': '',
                                'stroke-dasharray': ''
                            }),
                        ]),
                    ]),
                ]
            }]
    }], function () { return []; }, { autoDraw: [{
            type: Input
        }], autoDrawDuration: [{
            type: Input
        }], autoDrawEasing: [{
            type: Input
        }], padding: [{
            type: Input
        }], radius: [{
            type: Input
        }], stroke: [{
            type: Input
        }], strokeLinecap: [{
            type: Input
        }], strokeWidth: [{
            type: Input
        }], gradient: [{
            type: Input
        }], svgHeight: [{
            type: Input
        }], svgWidth: [{
            type: Input
        }], data: [{
            type: Input
        }], smooth: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], preserveAspectRatio: [{
            type: Input
        }], pathEl: [{
            type: ViewChild,
            args: ['pathEl']
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlbmQuY29tcG9uZW50LmpzIiwic291cmNlcyI6WyIuLi8uLi9zcmMvbGliL3RyZW5kL3RyZW5kLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUM1RixPQUFPLEVBQUUsU0FBUyxFQUFjLEtBQUssRUFBYSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFbkYsT0FBTyxFQUFFLGVBQWUsRUFBRSxlQUFlLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUMxRSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDcEQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3JELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEVuRCxNQUFNLE9BQU8sY0FBYztBQUFHLElBMkI1QjtBQUNGLFFBeEJXLGFBQVEsR0FBRyxLQUFLLENBQUM7QUFDNUIsUUFBVyxxQkFBZ0IsR0FBRyxJQUFJLENBQUM7QUFDbkMsUUFBVyxtQkFBYyxHQUFHLE1BQU0sQ0FBQztBQUNuQyxRQUVXLFlBQU8sR0FBRyxDQUFDLENBQUM7QUFDdkIsUUFBVyxXQUFNLEdBQUcsRUFBRSxDQUFDO0FBQ3ZCLFFBQVcsV0FBTSxHQUFHLE9BQU8sQ0FBQztBQUM1QixRQUFXLGtCQUFhLEdBQUcsRUFBRSxDQUFDO0FBQzlCLFFBQVcsZ0JBQVcsR0FBRyxDQUFDLENBQUM7QUFDM0IsUUFBVyxhQUFRLEdBQWEsRUFBRSxDQUFDO0FBQ25DLFFBQ1csY0FBUyxHQUFvQixLQUFLLENBQUM7QUFDOUMsUUFBVyxhQUFRLEdBQW9CLE1BQU0sQ0FBQztBQUM5QyxRQU9FLG1CQUFjLEdBQUcs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QUM7c0JBQ3ZCLENBQUM7R0FDSCxDQUFDLENBQ0g7T0FDRDtpREFBbUUsNkJBQ25FO3dEQUFrRSw2QkFDbEU7bUVBQXFFO01BQ3JFLGdFQUFnRTtjQUNoRSw4Q0FBOEM7c0JBQzlDLEtBQUs7QUFBQyxrQ0FDSjtJQUFtQixFQUFFLEVBQUUsa0NBQ3ZCO2FBQWtCLEVBQUUsRUFBRTs7SUFDdkIsQ0FBQztlQUtMO0FBSkUsQ0FBQyx1QkFDSCxDQUFDLHpCQUdBO0VBRkgsY0FDRixoQkFDK0M7QUFFL0IsbUJBQWQsS0FBSztBQUFLLHFCQUNWLEtBQUs7QUFBSyx1QkFDVixLQUFLO0FBQUssK0JBQ1YsS0FBSztBQUFLLDZCQUNWLEtBQUs7QUFBSyxvQkFDVixLQUFLO0FBQUsscUJBQ1YsS0FBSztBQUFLLHNCQUNWLEtBQUs7QUFBSyxxQkFDVixLQUFLO0FBQUsscUJBQ1YsS0FBSztBQUFLLDRCQUNWLEtBQUs7QUFBSywwQkFDVixLQUFLO0FBQUssdUJBQ1YsS0FBSztBQUFLLGtDQUNWLEtBQUs7QUFBSyx3QkFDVixLQUFLO0FBQUssdUJBQ1YsS0FBSztBQUFLLHFCQUNWLFNBQVMsU0FBQyxRQUFRO0FBQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhbmltYXRlLCBrZXlmcmFtZXMsIHN0YXRlLCBzdHlsZSwgdHJhbnNpdGlvbiwgdHJpZ2dlciB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBJbnB1dCwgT25DaGFuZ2VzLCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgYnVpbGRMaW5lYXJQYXRoLCBidWlsZFNtb290aFBhdGggfSBmcm9tICcuLi9oZWxwZXJzL0RPTS5oZWxwZXJzJztcbmltcG9ydCB7IG5vcm1hbGl6ZSB9IGZyb20gJy4uL2hlbHBlcnMvbWF0aC5oZWxwZXJzJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi9oZWxwZXJzL21pc2MuaGVscGVycyc7XG5pbXBvcnQgeyBub3JtYWxpemVEYXRhc2V0IH0gZnJvbSAnLi90cmVuZC5oZWxwZXJzJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbmd4LXRyZW5kJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8c3ZnXG4gICAgICAqbmdJZj1cImRhdGEgJiYgZGF0YS5sZW5ndGggPj0gMlwiXG4gICAgICBbYXR0ci53aWR0aF09XCJzdmdXaWR0aFwiXG4gICAgICBbYXR0ci5oZWlnaHRdPVwic3ZnSGVpZ2h0XCJcbiAgICAgIFthdHRyLnN0cm9rZV09XCJzdHJva2VcIlxuICAgICAgW2F0dHIuc3Ryb2tlLXdpZHRoXT1cInN0cm9rZVdpZHRoXCJcbiAgICAgIFthdHRyLnN0cm9rZS1saW5lY2FwXT1cInN0cm9rZUxpbmVjYXBcIlxuICAgICAgW2F0dHIudmlld0JveF09XCJ2aWV3Qm94XCJcbiAgICAgIFthdHRyLnByZXNlcnZlQXNwZWN0UmF0aW9dPVwicHJlc2VydmVBc3BlY3RSYXRpb1wiXG4gICAgPlxuICAgICAgPGRlZnMgKm5nSWY9XCJncmFkaWVudCAmJiBncmFkaWVudC5sZW5ndGhcIj5cbiAgICAgICAgPGxpbmVhckdyYWRpZW50IFthdHRyLmlkXT1cImdyYWRpZW50SWRcIiB4MT1cIjAlXCIgeTE9XCIwJVwiIHgyPVwiMCVcIiB5Mj1cIjEwMCVcIj5cbiAgICAgICAgICA8c3RvcFxuICAgICAgICAgICAgKm5nRm9yPVwibGV0IGcgb2YgZ3JhZGllbnRUcmltbWVkXCJcbiAgICAgICAgICAgIFthdHRyLmtleV09XCJnLmlkeFwiXG4gICAgICAgICAgICBbYXR0ci5vZmZzZXRdPVwiZy5vZmZzZXRcIlxuICAgICAgICAgICAgW2F0dHIuc3RvcC1jb2xvcl09XCJnLnN0b3BDb2xvclwiXG4gICAgICAgICAgLz5cbiAgICAgICAgPC9saW5lYXJHcmFkaWVudD5cbiAgICAgIDwvZGVmcz5cbiAgICAgIDxwYXRoXG4gICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgI3BhdGhFbFxuICAgICAgICBbYXR0ci5zdHJva2VdPVwicGF0aFN0cm9rZVwiXG4gICAgICAgIFthdHRyLmRdPVwiZFwiXG4gICAgICAgIFtAcGF0aEFuaW1haXRvbl09XCJ7XG4gICAgICAgICAgdmFsdWU6IGFuaW1hdGlvblN0YXRlLFxuICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgYXV0b0RyYXdEdXJhdGlvbjogYXV0b0RyYXdEdXJhdGlvbixcbiAgICAgICAgICAgIGF1dG9EcmF3RWFzaW5nOiBhdXRvRHJhd0Vhc2luZyxcbiAgICAgICAgICAgIGxpbmVMZW5ndGg6IGxpbmVMZW5ndGhcbiAgICAgICAgICB9XG4gICAgICAgIH1cIlxuICAgICAgLz5cbiAgICA8L3N2Zz5cbiAgYCxcbiAgYW5pbWF0aW9uczogW1xuICAgIHRyaWdnZXIoJ3BhdGhBbmltYWl0b24nLCBbXG4gICAgICBzdGF0ZSgnaW5hY3RpdmUnLCBzdHlsZSh7IGRpc3BsYXk6ICdub25lJyB9KSksXG4gICAgICB0cmFuc2l0aW9uKCcqID0+IGFjdGl2ZScsIFtcbiAgICAgICAgc3R5bGUoeyBkaXNwbGF5OiAnaW5pdGlhbCcgfSksXG4gICAgICAgIC8vIFdlIGRvIHRoZSBhbmltYXRpb24gdXNpbmcgdGhlIGRhc2ggYXJyYXkvb2Zmc2V0IHRyaWNrXG4gICAgICAgIC8vIGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vc3ZnLWxpbmUtYW5pbWF0aW9uLXdvcmtzL1xuICAgICAgICBhbmltYXRlKFxuICAgICAgICAgICd7eyBhdXRvRHJhd0R1cmF0aW9uIH19bXMge3sgYXV0b0RyYXdFYXNpbmcgfX0nLFxuICAgICAgICAgIGtleWZyYW1lcyhbXG4gICAgICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICAgICdzdHJva2UtZGFzaGFycmF5JzogJ3t7IGxpbmVMZW5ndGggfX1weCcsXG4gICAgICAgICAgICAgICdzdHJva2UtZGFzaG9mZnNldCc6ICd7eyBsaW5lTGVuZ3RoIH19cHgnLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICAgICdzdHJva2UtZGFzaGFycmF5JzogJ3t7IGxpbmVMZW5ndGggfX1weCcsXG4gICAgICAgICAgICAgICdzdHJva2UtZGFzaG9mZnNldCc6IDAsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICBdKSxcbiAgICAgICAgKSxcbiAgICAgICAgLy8gT25lIHVuZm9ydHVuYXRlIHNpZGUtZWZmZWN0IG9mIHRoZSBhdXRvLWRyYXcgaXMgdGhhdCB0aGUgbGluZSBpc1xuICAgICAgICAvLyBhY3R1YWxseSAxIGJpZyBkYXNoLCB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIGxpbmUgaXRzZWxmLiBJZiB0aGVcbiAgICAgICAgLy8gbGluZSBsZW5ndGggY2hhbmdlcyAoZWcuIHJhZGl1cyBjaGFuZ2UsIG5ldyBkYXRhKSwgdGhhdCBkYXNoIHdvbid0XG4gICAgICAgIC8vIGJlIHRoZSBzYW1lIGxlbmd0aCBhbnltb3JlLiBXZSBjYW4gZml4IHRoYXQgYnkgcmVtb3ZpbmcgdGhvc2VcbiAgICAgICAgLy8gcHJvcGVydGllcyBvbmNlIHRoZSBhdXRvLWRyYXcgaXMgY29tcGxldGVkLlxuICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJycsXG4gICAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiAnJyxcbiAgICAgICAgfSksXG4gICAgICBdKSxcbiAgICBdKSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgVHJlbmRDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICBpZDogbnVtYmVyO1xuICBASW5wdXQoKSBkYXRhPzogQXJyYXk8KG51bWJlciB8IHsgdmFsdWU6IG51bWJlciB9KT47XG4gIEBJbnB1dCgpIHNtb290aD86IGJvb2xlYW47XG4gIEBJbnB1dCgpIGF1dG9EcmF3ID0gZmFsc2U7XG4gIEBJbnB1dCgpIGF1dG9EcmF3RHVyYXRpb24gPSAyMDAwO1xuICBASW5wdXQoKSBhdXRvRHJhd0Vhc2luZyA9ICdlYXNlJztcbiAgQElucHV0KCkgd2lkdGg/OiBudW1iZXI7XG4gIEBJbnB1dCgpIGhlaWdodD86IG51bWJlcjtcbiAgQElucHV0KCkgcGFkZGluZyA9IDg7XG4gIEBJbnB1dCgpIHJhZGl1cyA9IDEwO1xuICBASW5wdXQoKSBzdHJva2UgPSAnYmxhY2snO1xuICBASW5wdXQoKSBzdHJva2VMaW5lY2FwID0gJyc7XG4gIEBJbnB1dCgpIHN0cm9rZVdpZHRoID0gMTtcbiAgQElucHV0KCkgZ3JhZGllbnQ6IHN0cmluZ1tdID0gW107XG4gIEBJbnB1dCgpIHByZXNlcnZlQXNwZWN0UmF0aW8/OiBzdHJpbmc7XG4gIEBJbnB1dCgpIHN2Z0hlaWdodDogc3RyaW5nIHwgbnVtYmVyID0gJzI1JSc7XG4gIEBJbnB1dCgpIHN2Z1dpZHRoOiBzdHJpbmcgfCBudW1iZXIgPSAnMTAwJSc7XG4gIEBWaWV3Q2hpbGQoJ3BhdGhFbCcpIHBhdGhFbCE6IEVsZW1lbnRSZWY7XG4gIGdyYWRpZW50VHJpbW1lZCE6IEFycmF5PHsgaWR4OiBudW1iZXI7IHN0b3BDb2xvcjogc3RyaW5nOyBvZmZzZXQ6IG51bWJlciB9PjtcbiAgZDogYW55O1xuICB2aWV3Qm94ITogc3RyaW5nO1xuICBwYXRoU3Ryb2tlOiBhbnk7XG4gIGdyYWRpZW50SWQ6IHN0cmluZztcbiAgbGluZUxlbmd0aCE6IG51bWJlcjtcbiAgYW5pbWF0aW9uU3RhdGUgPSAnJztcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgIHRoaXMuZ3JhZGllbnRJZCA9IGBuZ3gtdHJlbmQtdmVydGljYWwtZ3JhZGllbnQtJHt0aGlzLmlkfWA7XG4gIH1cbiAgbmdPbkNoYW5nZXMoKTogdm9pZCB7XG4gICAgLy8gV2UgbmVlZCBhdCBsZWFzdCAyIHBvaW50cyB0byBkcmF3IGEgZ3JhcGguXG4gICAgaWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kYXRhLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBgZGF0YWAgY2FuIGVpdGhlciBiZSBhbiBhcnJheSBvZiBudW1iZXJzOlxuICAgIC8vIFsxLCAyLCAzXVxuICAgIC8vIG9yLCBhbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgYSB2YWx1ZTpcbiAgICAvLyBbeyB2YWx1ZTogMSB9LCB7IHZhbHVlOiAyIH0sIHsgdmFsdWU6IDMgfV1cbiAgICAvL1xuICAgIC8vIEZvciBub3csIHdlJ3JlIGp1c3QgZ29pbmcgdG8gY29udmVydCB0aGUgc2Vjb25kIGZvcm0gdG8gdGhlIGZpcnN0LlxuICAgIC8vIExhdGVyIG9uLCBpZi93aGVuIHdlIHN1cHBvcnQgdG9vbHRpcHMsIHdlIG1heSBhZGp1c3QuXG4gICAgY29uc3QgcGxhaW5WYWx1ZXMgPSB0aGlzLmRhdGEubWFwKHBvaW50ID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcG9pbnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb2ludC52YWx1ZTtcbiAgICB9KTtcblxuICAgIC8vIE91ciB2aWV3Ym94IG5lZWRzIHRvIGJlIGluIGFic29sdXRlIHVuaXRzLCBzbyB3ZSdsbCBkZWZhdWx0IHRvIDMwMHg3NVxuICAgIC8vIE91ciBTVkcgY2FuIGJlIGEgJSwgdGhvdWdoOyB0aGlzIGlzIHdoYXQgbWFrZXMgaXQgc2NhbGFibGUuXG4gICAgLy8gQnkgZGVmYXVsdGluZyB0byBwZXJjZW50YWdlcywgdGhlIFNWRyB3aWxsIGdyb3cgdG8gZmlsbCBpdHMgcGFyZW50XG4gICAgLy8gY29udGFpbmVyLCBwcmVzZXJ2aW5nIGEgMS80IGFzcGVjdCByYXRpby5cbiAgICBjb25zdCB2aWV3Qm94V2lkdGggPSB0aGlzLndpZHRoIHx8IDMwMDtcbiAgICBjb25zdCB2aWV3Qm94SGVpZ2h0ID0gdGhpcy5oZWlnaHQgfHwgNzU7XG4gICAgdGhpcy5zdmdXaWR0aCA9IHRoaXMud2lkdGggfHwgJzEwMCUnO1xuICAgIHRoaXMuc3ZnSGVpZ2h0ID0gdGhpcy5oZWlnaHQgfHwgJzI1JSc7XG4gICAgdGhpcy52aWV3Qm94ID0gYDAgMCAke3ZpZXdCb3hXaWR0aH0gJHt2aWV3Qm94SGVpZ2h0fWA7XG4gICAgY29uc3Qgcm9vdCA9IGxvY2F0aW9uLmhyZWYuc3BsaXQobG9jYXRpb24uaGFzaCB8fCAnIycpWzBdO1xuICAgIHRoaXMucGF0aFN0cm9rZSA9XG4gICAgICB0aGlzLmdyYWRpZW50ICYmIHRoaXMuZ3JhZGllbnQubGVuZ3RoID8gYHVybCgnJHtyb290fSMke3RoaXMuZ3JhZGllbnRJZH0nKWAgOiB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLmdyYWRpZW50VHJpbW1lZCA9IHRoaXMuZ3JhZGllbnRcbiAgICAgIC5zbGljZSgpXG4gICAgICAucmV2ZXJzZSgpXG4gICAgICAubWFwKCh2YWwsIGlkeCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkeCxcbiAgICAgICAgICBzdG9wQ29sb3I6IHZhbCxcbiAgICAgICAgICBvZmZzZXQ6IG5vcm1hbGl6ZShpZHgsIDAsIHRoaXMuZ3JhZGllbnQubGVuZ3RoIC0gMSB8fCAxKSxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlcyA9IG5vcm1hbGl6ZURhdGFzZXQoXG4gICAgICBwbGFpblZhbHVlcyxcbiAgICAgIHRoaXMucGFkZGluZyxcbiAgICAgIHZpZXdCb3hXaWR0aCAtIHRoaXMucGFkZGluZyxcbiAgICAgIC8vIE5PVEU6IEJlY2F1c2UgU1ZHcyBhcmUgaW5kZXhlZCBmcm9tIHRoZSB0b3AgbGVmdCwgYnV0IG1vc3QgZGF0YSBpc1xuICAgICAgLy8gaW5kZXhlZCBmcm9tIHRoZSBib3R0b20gbGVmdCwgd2UncmUgaW52ZXJ0aW5nIHRoZSBZIG1pbi9tYXguXG4gICAgICB2aWV3Qm94SGVpZ2h0IC0gdGhpcy5wYWRkaW5nLFxuICAgICAgdGhpcy5wYWRkaW5nLFxuICAgICk7XG5cbiAgICBpZiAodGhpcy5hdXRvRHJhdyAmJiB0aGlzLmFuaW1hdGlvblN0YXRlICE9PSAnYWN0aXZlJykge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9ICdpbmFjdGl2ZSc7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5saW5lTGVuZ3RoID0gdGhpcy5wYXRoRWwubmF0aXZlRWxlbWVudC5nZXRUb3RhbExlbmd0aCgpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gJ2FjdGl2ZSc7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmQgPSB0aGlzLnNtb290aFxuICAgICAgPyBidWlsZFNtb290aFBhdGgobm9ybWFsaXplZFZhbHVlcywgdGhpcy5yYWRpdXMpXG4gICAgICA6IGJ1aWxkTGluZWFyUGF0aChub3JtYWxpemVkVmFsdWVzKTtcbiAgfVxufVxuIl19