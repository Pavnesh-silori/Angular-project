/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// Workaround for: https://github.com/bazelbuild/rules_nodejs/issues/1265
/// <reference types="googlemaps" />
import { Directive } from '@angular/core';
import { MapBaseLayer } from '../map-base-layer';
/**
 * Angular component that renders a Google Maps Transit Layer via the Google Maps JavaScript API.
 *
 * See developers.google.com/maps/documentation/javascript/reference/map#TransitLayer
 */
import * as ɵngcc0 from '@angular/core';
export class MapTransitLayer extends MapBaseLayer {
    _initializeObject() {
        this.transitLayer = new google.maps.TransitLayer();
    }
    _setMap() {
        this._assertLayerInitialized();
        this.transitLayer.setMap(this._map.googleMap);
    }
    _unsetMap() {
        if (this.transitLayer) {
            this.transitLayer.setMap(null);
        }
    }
    _assertLayerInitialized() {
        if (!this.transitLayer) {
            throw Error('Cannot interact with a Google Map Transit Layer before it has been initialized. ' +
                'Please wait for the Transit Layer to load before trying to interact with it.');
        }
    }
}
MapTransitLayer.ɵfac = /*@__PURE__*/ function () { let ɵMapTransitLayer_BaseFactory; return function MapTransitLayer_Factory(t) { return (ɵMapTransitLayer_BaseFactory || (ɵMapTransitLayer_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(MapTransitLayer)))(t || MapTransitLayer); }; }();
MapTransitLayer.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MapTransitLayer, selectors: [["map-transit-layer"]], exportAs: ["mapTransitLayer"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MapTransitLayer, [{
        type: Directive,
        args: [{
                selector: 'map-transit-layer',
                exportAs: 'mapTransitLayer'
            }]
    }], null, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFwLXRyYW5zaXQtbGF5ZXIuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9nb29nbGUtbWFwcy9tYXAtdHJhbnNpdC1sYXllci9tYXAtdHJhbnNpdC1sYXllci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBRUgseUVBQXlFO0FBQ3pFLG9DQUFvQztBQUVwQyxPQUFPLEVBQUMsU0FBUyxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBRXhDLE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBS0gsTUFBTSxPQUFPLGVBQWdCLFNBQVEsWUFBWTtBQUNqRCxJQU9ZLGlCQUFpQjtBQUM3QixRQUFJLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO0FBQ3ZELElBQUUsQ0FBQztBQUNILElBQ1ksT0FBTztBQUNuQixRQUFJLElBQUksQ0FBQyx1QkFBdUIsRUFBRSxDQUFDO0FBQ25DLFFBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFVLENBQUMsQ0FBQztBQUNuRCxJQUFFLENBQUM7QUFDSCxJQUNZLFNBQVM7QUFDckIsUUFBSSxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7QUFDM0IsWUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNyQyxTQUFLO0FBQ0wsSUFBRSxDQUFDO0FBQ0gsSUFDVSx1QkFBdUI7QUFBSyxRQUNsQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRTtBQUM1QixZQUFNLE1BQU0sS0FBSyxDQUNQLGtGQUFrRjtBQUM1RixnQkFBVSw4RUFBOEUsQ0FBQyxDQUFDO0FBQzFGLFNBQUs7QUFDTCxJQUFFLENBQUM7QUFDSDsyQ0FsQ0MsU0FBUyxTQUFDLGtCQUNULFFBQVEsRUFBRSxtQkFBbUIsa0JBQzdCLFFBQVEsRUFBRSxpQkFBaUIsZUFDNUI7Ozs7Ozs7OzBCQUNJO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLy8gV29ya2Fyb3VuZCBmb3I6IGh0dHBzOi8vZ2l0aHViLmNvbS9iYXplbGJ1aWxkL3J1bGVzX25vZGVqcy9pc3N1ZXMvMTI2NVxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJnb29nbGVtYXBzXCIgLz5cblxuaW1wb3J0IHtEaXJlY3RpdmV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQge01hcEJhc2VMYXllcn0gZnJvbSAnLi4vbWFwLWJhc2UtbGF5ZXInO1xuXG4vKipcbiAqIEFuZ3VsYXIgY29tcG9uZW50IHRoYXQgcmVuZGVycyBhIEdvb2dsZSBNYXBzIFRyYW5zaXQgTGF5ZXIgdmlhIHRoZSBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSS5cbiAqXG4gKiBTZWUgZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L3JlZmVyZW5jZS9tYXAjVHJhbnNpdExheWVyXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ21hcC10cmFuc2l0LWxheWVyJyxcbiAgZXhwb3J0QXM6ICdtYXBUcmFuc2l0TGF5ZXInLFxufSlcbmV4cG9ydCBjbGFzcyBNYXBUcmFuc2l0TGF5ZXIgZXh0ZW5kcyBNYXBCYXNlTGF5ZXIge1xuICAvKipcbiAgICogVGhlIHVuZGVybHlpbmcgZ29vZ2xlLm1hcHMuVHJhbnNpdExheWVyIG9iamVjdC5cbiAgICpcbiAgICogU2VlIGRldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9yZWZlcmVuY2UvbWFwI1RyYW5zaXRMYXllclxuICAgKi9cbiAgdHJhbnNpdExheWVyPzogZ29vZ2xlLm1hcHMuVHJhbnNpdExheWVyO1xuXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZU9iamVjdCgpIHtcbiAgICB0aGlzLnRyYW5zaXRMYXllciA9IG5ldyBnb29nbGUubWFwcy5UcmFuc2l0TGF5ZXIoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfc2V0TWFwKCkge1xuICAgIHRoaXMuX2Fzc2VydExheWVySW5pdGlhbGl6ZWQoKTtcbiAgICB0aGlzLnRyYW5zaXRMYXllci5zZXRNYXAodGhpcy5fbWFwLmdvb2dsZU1hcCEpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF91bnNldE1hcCgpIHtcbiAgICBpZiAodGhpcy50cmFuc2l0TGF5ZXIpIHtcbiAgICAgIHRoaXMudHJhbnNpdExheWVyLnNldE1hcChudWxsKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9hc3NlcnRMYXllckluaXRpYWxpemVkKCk6IGFzc2VydHMgdGhpcyBpcyB7dHJhbnNpdExheWVyOiBnb29nbGUubWFwcy5UcmFuc2l0TGF5ZXJ9IHtcbiAgICBpZiAoIXRoaXMudHJhbnNpdExheWVyKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAnQ2Fubm90IGludGVyYWN0IHdpdGggYSBHb29nbGUgTWFwIFRyYW5zaXQgTGF5ZXIgYmVmb3JlIGl0IGhhcyBiZWVuIGluaXRpYWxpemVkLiAnICtcbiAgICAgICAgICAnUGxlYXNlIHdhaXQgZm9yIHRoZSBUcmFuc2l0IExheWVyIHRvIGxvYWQgYmVmb3JlIHRyeWluZyB0byBpbnRlcmFjdCB3aXRoIGl0LicpO1xuICAgIH1cbiAgfVxufVxuIl19