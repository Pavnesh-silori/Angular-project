import { __decorate, __metadata, __param } from "tslib";
import { Injectable, Inject } from "@angular/core";
import { DEFAULT_ERRORS } from "../default-errors";
import { CUSTOM_ERROR_MESSAGES } from "../Tokens/tokens";
import * as i0 from "@angular/core";
import * as i1 from "../Tokens/tokens";
import * as ɵngcc0 from '@angular/core';
let ErrorMessageService = class ErrorMessageService {
    constructor(customErrorMessages) {
        this.customErrorMessages = customErrorMessages;
        this.defaultErrors = DEFAULT_ERRORS;
        this.errorMessages = customErrorMessages.reduce((acc, cur) => acc.concat(cur), this.defaultErrors);
    }
};
ErrorMessageService.ɵfac = function ErrorMessageService_Factory(t) { return new (t || ErrorMessageService)(ɵngcc0.ɵɵinject(CUSTOM_ERROR_MESSAGES)); };
ErrorMessageService.ctorParameters = () => [
    { type: Array, decorators: [{ type: Inject, args: [CUSTOM_ERROR_MESSAGES,] }] }
];
ErrorMessageService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ErrorMessageService_Factory() { return new ErrorMessageService(i0.ɵɵinject(i1.CUSTOM_ERROR_MESSAGES)); }, token: ErrorMessageService, providedIn: "root" });
ErrorMessageService = __decorate([ __param(0, Inject(CUSTOM_ERROR_MESSAGES)),
    __metadata("design:paramtypes", [Array])
], ErrorMessageService);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ErrorMessageService, [{
        type: Injectable,
        args: [{
                providedIn: "root"
            }]
    }], function () { return [{ type: Array, decorators: [{
                type: Inject,
                args: [CUSTOM_ERROR_MESSAGES]
            }] }]; }, null); })();
export { ErrorMessageService };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXJyb3ItbWVzc2FnZS5zZXJ2aWNlLmpzIiwic291cmNlcyI6WyJuZy1ib290c3RyYXAtZm9ybS12YWxpZGF0aW9uL2xpYi9TZXJ2aWNlcy9lcnJvci1tZXNzYWdlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ25ELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNuRCxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUN6RDtBQUFxQzs7QUFLckMsSUFBYSxtQkFBbUIsR0FBaEMsTUFBYSxtQkFBbUI7QUFDaEMsSUFJRSxZQUN3QyxtQkFBcUM7QUFDNUUsUUFEdUMsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFrQjtBQUMvRSxRQU5VLGtCQUFhLEdBQUcsY0FBYyxDQUFDO0FBQ3pDLFFBTUksSUFBSSxDQUFDLGFBQWEsR0FBRyxtQkFBbUIsQ0FBQyxNQUFNLENBQzdDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFDN0IsSUFBSSxDQUFDLGFBQWEsQ0FDbkIsQ0FBQztBQUNOLElBQUUsQ0FBQztBQUNILENBQUM7c0pBQUE7QUFDRDtBQUE2Qyx3Q0FSeEMsTUFBTSxTQUFDLHFCQUFxQjtBQUFRO0FBQUc7QUFOL0IsbUJBQW1CLG9CQUgvQixVQUFVLENBQUMsVUFDVixVQUFVLEVBQUUsdENBRVYsQ0FNQyxXQUFBLE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFBO0FBUmQsTUFDbkIsQ0FBQyxQQU9rQztBQUNuQyxHQVBZLG1CQUFtQixDQWEvQjs7Ozs7Ozs7O2tDQUNEO0FBQUMsU0FkWSxtQkFBbUI7QUFDL0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgREVGQVVMVF9FUlJPUlMgfSBmcm9tIFwiLi4vZGVmYXVsdC1lcnJvcnNcIjtcbmltcG9ydCB7IENVU1RPTV9FUlJPUl9NRVNTQUdFUyB9IGZyb20gXCIuLi9Ub2tlbnMvdG9rZW5zXCI7XG5pbXBvcnQgeyBFcnJvck1lc3NhZ2UgfSBmcm9tIFwiLi4vTW9kZWxzL2Vycm9yLW1lc3NhZ2VcIjtcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiBcInJvb3RcIlxufSlcbmV4cG9ydCBjbGFzcyBFcnJvck1lc3NhZ2VTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBkZWZhdWx0RXJyb3JzID0gREVGQVVMVF9FUlJPUlM7XG5cbiAgcHVibGljIGVycm9yTWVzc2FnZXM6IEVycm9yTWVzc2FnZVtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoQ1VTVE9NX0VSUk9SX01FU1NBR0VTKSBwdWJsaWMgY3VzdG9tRXJyb3JNZXNzYWdlczogRXJyb3JNZXNzYWdlW11bXVxuICApIHtcbiAgICB0aGlzLmVycm9yTWVzc2FnZXMgPSBjdXN0b21FcnJvck1lc3NhZ2VzLnJlZHVjZShcbiAgICAgIChhY2MsIGN1cikgPT4gYWNjLmNvbmNhdChjdXIpLFxuICAgICAgdGhpcy5kZWZhdWx0RXJyb3JzXG4gICAgKTtcbiAgfVxufVxuIl19