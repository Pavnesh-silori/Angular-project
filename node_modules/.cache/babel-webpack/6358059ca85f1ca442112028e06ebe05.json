{"ast":null,"code":"import { EventEmitter, Component, ElementRef, ChangeDetectorRef, Renderer2, Input, ViewChild, HostListener, Directive, ViewContainerRef, ComponentFactoryResolver, ApplicationRef, Injector, Output, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/popover.placement.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nconst _c0 = [\"popoverDiv\"];\nconst _c1 = function (a0, a1, a2, a3, a4) {\n  return {\n    \"sm\": a0,\n    \"md-sm\": a1,\n    \"md\": a2,\n    \"lg\": a3,\n    \"in\": a4\n  };\n};\nconst _c2 = [\"*\"];\nlet PopoverPlacement = /*#__PURE__*/(() => {\n  class PopoverPlacement {}\n  PopoverPlacement.Bottom = 'bottom';\n  PopoverPlacement.BottomLeft = 'bottom-left';\n  PopoverPlacement.BottomRight = 'bottom-right';\n  PopoverPlacement.Left = 'left';\n  PopoverPlacement.Right = 'right';\n  PopoverPlacement.Top = 'top';\n  PopoverPlacement.TopLeft = 'top-left';\n  PopoverPlacement.TopRight = 'top-right';\n\n  /**\n   * @fileoverview added by tsickle\n   * Generated from: lib/popover-content.component.ts\n   * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n   */\n  return PopoverPlacement;\n})();\nlet PopoverContentComponent = /*#__PURE__*/(() => {\n  class PopoverContentComponent {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    /**\n     * @param {?} element\n     * @param {?} cdr\n     * @param {?} renderer\n     */\n    constructor(element, cdr, renderer) {\n      this.element = element;\n      this.cdr = cdr;\n      this.renderer = renderer;\n      this.placement = PopoverPlacement.Top;\n      this.animation = true;\n      this.closeOnClickOutside = false;\n      this.closeOnMouseOutside = false;\n      this.appendToBody = false;\n      this.size = 'small';\n      this.onCloseFromOutside = new EventEmitter();\n      this.top = -10000;\n      this.left = -10000;\n      this.isIn = false;\n      this.opacity = 0;\n      this.transitionEnabled = false;\n      this.windowWidth = window.innerWidth;\n      this.windowHeight = window.innerHeight;\n      // -------------------------------------------------------------------------\n      // Anonymous\n      // -------------------------------------------------------------------------\n      /**\n       * Closes dropdown if user clicks outside of this directive.\n       */\n      this.onDocumentMouseDown =\n      /**\n      * @param {?} event\n      * @return {?}\n      */\n      event => {\n        /** @type {?} */\n        const element = this.element.nativeElement;\n        if (!element || !this.popover) {\n          return;\n        }\n        if (element.contains(event.target) || this.popover.getElement().contains(event.target)) {\n          return;\n        }\n        this.onCloseFromOutside.emit(undefined);\n      };\n    }\n    // -------------------------------------------------------------------------\n    // Lifecycle callbacks\n    // -------------------------------------------------------------------------\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n      if (this.closeOnClickOutside) {\n        this.listenClickFunc = this.renderer.listen('document', 'mousedown',\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        event => this.onDocumentMouseDown(event));\n      }\n      if (this.closeOnMouseOutside) {\n        this.listenMouseFunc = this.renderer.listen('document', 'mouseover',\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        event => this.onDocumentMouseDown(event));\n      }\n      // Always close on mobile touch event outside.\n      this.listenTouchFunc = this.renderer.listen('document', 'touchstart',\n      /**\n      * @param {?} event\n      * @return {?}\n      */\n      event => this.onDocumentMouseDown(event));\n      this.show();\n      this.cdr.detectChanges();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n      if (this.closeOnClickOutside && this.listenClickFunc) {\n        this.listenClickFunc();\n      }\n      if (this.closeOnMouseOutside && this.listenMouseFunc) {\n        this.listenMouseFunc();\n      }\n      if (!!this.listenTouchFunc) {\n        this.listenTouchFunc();\n      }\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    onResize(event) {\n      this.windowWidth = window.innerWidth;\n      this.windowHeight = window.innerHeight;\n    }\n    /**\n     * @return {?}\n     */\n    updatePosition() {\n      // if visible, reposition\n      if (this.opacity) {\n        /** @type {?} */\n        const p = this.positionElements(this.popover.getElement(), this.popoverDiv.nativeElement, this.placement);\n        this.top = p.top;\n        this.left = p.left;\n      }\n    }\n    /**\n     * @return {?}\n     */\n    show() {\n      if (!this.popover || !this.popover.getElement()) {\n        return;\n      }\n      /** @type {?} */\n      const p = this.positionElements(this.popover.getElement(), this.popoverDiv.nativeElement, this.placement);\n      this.top = p.top;\n      this.left = p.left;\n      this.isIn = true;\n      this.transitionEnabled = true;\n      this.opacity = 1;\n    }\n    /**\n     * @return {?}\n     */\n    hide() {\n      this.top = -10000;\n      this.left = -10000;\n      this.isIn = true;\n      this.popover.hide();\n    }\n    /**\n     * @return {?}\n     */\n    hideFromPopover() {\n      this.top = -10000;\n      this.left = -10000;\n      this.isIn = true;\n      this.transitionEnabled = false;\n      this.opacity = 0;\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    /**\n     * @protected\n     * @param {?} hostEl\n     * @param {?} targetEl\n     * @param {?} positionStr\n     * @param {?=} appendToBody\n     * @return {?}\n     */\n    positionElements(hostEl, targetEl, positionStr, appendToBody = false) {\n      /** @type {?} */\n      const positionStrParts = /** @type {?} */positionStr.split(' ');\n      /** @type {?} */\n      let pos0 = positionStrParts[0];\n      /** @type {?} */\n      const pos1 = positionStrParts[1] || 'center';\n      /** @type {?} */\n      const hostElPos = this.appendToBody || appendToBody ? this.offset(hostEl) : this.position(hostEl);\n      /** @type {?} */\n      const targetElWidth = targetEl.offsetWidth;\n      /** @type {?} */\n      const targetElHeight = targetEl.offsetHeight;\n      this.effectivePlacement = pos0 = this.getEffectivePlacement(pos0, hostEl, targetEl);\n      /** @type {?} */\n      const shiftWidth = {\n        center:\n        /**\n        * @return {?}\n        */\n        function () {\n          return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;\n        },\n        left:\n        /**\n        * @return {?}\n        */\n        function () {\n          return hostElPos.left;\n        },\n        right:\n        /**\n        * @return {?}\n        */\n        function () {\n          return hostElPos.left + hostElPos.width;\n        },\n        topOrBottomRight:\n        /**\n        * @return {?}\n        */\n        function () {\n          return hostElPos.left + hostElPos.width / 2;\n        },\n        topOrBottomLeft:\n        /**\n        * @return {?}\n        */\n        function () {\n          return hostElPos.left - targetElWidth + hostElPos.width / 2;\n        }\n      };\n      /** @type {?} */\n      const shiftHeight = {\n        center:\n        /**\n        * @return {?}\n        */\n        function () {\n          return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;\n        },\n        top:\n        /**\n        * @return {?}\n        */\n        function () {\n          return hostElPos.top;\n        },\n        bottom:\n        /**\n        * @return {?}\n        */\n        function () {\n          return hostElPos.top + hostElPos.height;\n        }\n      };\n      /** @type {?} */\n      let targetElPos;\n      switch (pos0) {\n        case PopoverPlacement.Right:\n          targetElPos = {\n            top: shiftHeight[pos1](),\n            left: shiftWidth[pos0]()\n          };\n          break;\n        case PopoverPlacement.Left:\n          targetElPos = {\n            top: shiftHeight[pos1](),\n            left: hostElPos.left - targetElWidth\n          };\n          break;\n        case PopoverPlacement.Bottom:\n          targetElPos = {\n            top: shiftHeight[pos0](),\n            left: shiftWidth[pos1]()\n          };\n          break;\n        case PopoverPlacement.TopLeft:\n          targetElPos = {\n            top: hostElPos.top - targetElHeight,\n            left: shiftWidth['topOrBottomLeft']()\n          };\n          break;\n        case PopoverPlacement.TopRight:\n          targetElPos = {\n            top: hostElPos.top - targetElHeight,\n            left: shiftWidth['topOrBottomRight']()\n          };\n          break;\n        case PopoverPlacement.BottomLeft:\n          targetElPos = {\n            top: shiftHeight[PopoverPlacement.Bottom](),\n            left: shiftWidth['topOrBottomLeft']()\n          };\n          break;\n        case PopoverPlacement.BottomRight:\n          targetElPos = {\n            top: shiftHeight[PopoverPlacement.Bottom](),\n            left: shiftWidth['topOrBottomRight']()\n          };\n          break;\n        default:\n          targetElPos = {\n            top: hostElPos.top - targetElHeight,\n            left: shiftWidth[pos1]()\n          };\n          break;\n      }\n      return targetElPos;\n    }\n    /**\n     * @protected\n     * @param {?} nativeEl\n     * @return {?}\n     */\n    position(nativeEl) {\n      /** @type {?} */\n      let offsetParentBCR = {\n        top: 0,\n        left: 0\n      };\n      /** @type {?} */\n      const elBCR = this.offset(nativeEl);\n      /** @type {?} */\n      const offsetParentEl = this.parentOffsetEl(nativeEl);\n      if (offsetParentEl !== window.document) {\n        offsetParentBCR = this.offset(offsetParentEl);\n        offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;\n        offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;\n      }\n      /** @type {?} */\n      const boundingClientRect = nativeEl.getBoundingClientRect();\n      return {\n        width: boundingClientRect.width || nativeEl.offsetWidth,\n        height: boundingClientRect.height || nativeEl.offsetHeight,\n        top: elBCR.top - offsetParentBCR.top,\n        left: elBCR.left - offsetParentBCR.left\n      };\n    }\n    /**\n     * @protected\n     * @param {?} nativeEl\n     * @return {?}\n     */\n    offset(nativeEl) {\n      /** @type {?} */\n      const boundingClientRect = nativeEl.getBoundingClientRect();\n      return {\n        width: boundingClientRect.width || nativeEl.offsetWidth,\n        height: boundingClientRect.height || nativeEl.offsetHeight,\n        top: boundingClientRect.top + (window.pageYOffset || window.document.documentElement.scrollTop),\n        left: boundingClientRect.left + (window.pageXOffset || window.document.documentElement.scrollLeft)\n      };\n    }\n    /**\n     * @protected\n     * @param {?} nativeEl\n     * @param {?} cssProp\n     * @return {?}\n     */\n    getStyle(nativeEl, cssProp) {\n      if ( /** @type {?} */nativeEl.currentStyle) {\n        // IE\n        return (/** @type {?} */nativeEl.currentStyle[cssProp]\n        );\n      }\n      if (window.getComputedStyle) {\n        return (/** @type {?} */window.getComputedStyle(nativeEl)[cssProp]\n        );\n      }\n      // finally try and get inline style\n      return (/** @type {?} */nativeEl.style[cssProp]\n      );\n    }\n    /**\n     * @protected\n     * @param {?} nativeEl\n     * @return {?}\n     */\n    isStaticPositioned(nativeEl) {\n      return (this.getStyle(nativeEl, 'position') || 'static') === 'static';\n    }\n    /**\n     * @protected\n     * @param {?} nativeEl\n     * @return {?}\n     */\n    parentOffsetEl(nativeEl) {\n      /** @type {?} */\n      let offsetParent = nativeEl.offsetParent || window.document;\n      while (offsetParent && offsetParent !== window.document && this.isStaticPositioned(offsetParent)) {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || window.document;\n    }\n    // Check for overflow of the viewport and reflect the position if necessary.\n    /**\n     * @protected\n     * @param {?} placement\n     * @param {?} hostElement\n     * @param {?} targetElement\n     * @return {?}\n     */\n    getEffectivePlacement(placement, hostElement, targetElement) {\n      /** @type {?} */\n      const hostElBoundingRect = hostElement.getBoundingClientRect();\n      /** @type {?} */\n      const desiredPlacement = placement || PopoverPlacement.Top;\n      // Determines if a popover overflows in a direction when in a specific position.\n      /** @type {?} */\n      const overflows = {\n        positionTop: {\n          top: hostElBoundingRect.top - targetElement.offsetHeight < 0,\n          right: hostElBoundingRect.left + hostElBoundingRect.width / 2 + targetElement.offsetWidth / 2 > this.windowWidth,\n          left: hostElBoundingRect.left + hostElBoundingRect.width / 2 - targetElement.offsetWidth / 2 < 0\n        },\n        positionTopRight: {\n          top: hostElBoundingRect.top - targetElement.offsetHeight < 0,\n          right: hostElBoundingRect.right + targetElement.offsetWidth > this.windowWidth\n        },\n        positionRight: {\n          top: hostElBoundingRect.top + hostElBoundingRect.height / 2 - targetElement.offsetHeight / 2 < 0,\n          right: hostElBoundingRect.right + targetElement.offsetWidth > this.windowWidth,\n          bottom: hostElBoundingRect.top + hostElBoundingRect.height / 2 + targetElement.offsetHeight / 2 > this.windowHeight\n        },\n        positionBottomRight: {\n          right: hostElBoundingRect.right + targetElement.offsetWidth > this.windowWidth,\n          bottom: hostElBoundingRect.bottom + targetElement.offsetHeight > this.windowHeight\n        },\n        positionBottom: {\n          right: hostElBoundingRect.left + hostElBoundingRect.width / 2 + targetElement.offsetWidth / 2 > this.windowWidth,\n          bottom: hostElBoundingRect.bottom + targetElement.offsetHeight > this.windowHeight,\n          left: hostElBoundingRect.left + hostElBoundingRect.width / 2 - targetElement.offsetWidth / 2 < 0\n        },\n        positionBottomLeft: {\n          bottom: hostElBoundingRect.bottom + targetElement.offsetHeight > this.windowHeight,\n          left: hostElBoundingRect.left - targetElement.offsetWidth < 0\n        },\n        positionLeft: {\n          left: hostElBoundingRect.left < targetElement.offsetWidth,\n          top: hostElBoundingRect.top + hostElBoundingRect.height / 2 - targetElement.offsetHeight / 2 < 0,\n          bottom: hostElBoundingRect.top + hostElBoundingRect.height / 2 + targetElement.offsetHeight / 2 > this.windowHeight\n        },\n        positionTopLeft: {\n          top: hostElBoundingRect.top - targetElement.offsetHeight < 0,\n          left: hostElBoundingRect.left - targetElement.offsetWidth < 0\n        }\n      };\n      if (desiredPlacement === PopoverPlacement.Top) {\n        // If it overflows on the top AND left, go to bottom-right.\n        if (overflows.positionTop.top && overflows.positionTop.left) {\n          return PopoverPlacement.BottomRight;\n          // If it overflows on the top AND right, go to bottom-left.\n        } else if (overflows.positionTop.top && overflows.positionTop.right) {\n          return PopoverPlacement.BottomLeft;\n          // If it only overflows on the top, go to bottom.\n        } else if (overflows.positionTop.top) {\n          return PopoverPlacement.Bottom;\n          // If it only overflows to the right, go to top-left.\n        } else if (overflows.positionTop.right) {\n          return PopoverPlacement.TopLeft;\n          // If it only overflows to the left, go to top-right.\n        } else if (overflows.positionTop.left) {\n          return PopoverPlacement.TopRight;\n        } else {\n          return PopoverPlacement.Top;\n        }\n      }\n      if (desiredPlacement === PopoverPlacement.TopRight) {\n        // If it overflows on the top AND the right, try in the order: bottom, Bottom-left, left.\n        if (overflows.positionTopRight.top && overflows.positionTopRight.right) {\n          if (overflows.positionBottom.bottom) {\n            return PopoverPlacement.Left;\n          } else if (overflows.positionBottom.right) {\n            return PopoverPlacement.BottomLeft;\n          } else {\n            return PopoverPlacement.Bottom;\n          }\n          // If it only overflows on the top, try in the order: right, bottom-right.\n        } else if (overflows.positionTopRight.top) {\n          if (overflows.positionRight.top) {\n            return PopoverPlacement.BottomRight;\n          } else {\n            return PopoverPlacement.Right;\n          }\n          // If it only overflows on the right, try in the order: top, top-left.\n        } else if (overflows.positionTopRight.right) {\n          if (overflows.positionTop.right) {\n            return PopoverPlacement.TopLeft;\n          } else {\n            return PopoverPlacement.Top;\n          }\n        } else {\n          return PopoverPlacement.TopRight;\n        }\n      }\n      if (desiredPlacement === PopoverPlacement.Right) {\n        // If it overflows on the right AND the top, try in the order: bottom-right, bottom, bottom-left.\n        if (overflows.positionRight.right && overflows.positionRight.top) {\n          if (overflows.positionBottomRight.right && overflows.positionBottom.right) {\n            return PopoverPlacement.BottomLeft;\n          } else if (overflows.positionBottomRight.right) {\n            return PopoverPlacement.Bottom;\n          } else {\n            return PopoverPlacement.BottomRight;\n          }\n          // If it overflows on the right AND the bottom, try in the order: top-right, top, top-left.\n        } else if (overflows.positionRight.right && overflows.positionRight.bottom) {\n          if (overflows.positionTopRight.right && overflows.positionTop.right) {\n            return PopoverPlacement.TopLeft;\n          } else if (overflows.positionTopRight.right) {\n            return PopoverPlacement.Top;\n          } else {\n            return PopoverPlacement.TopRight;\n          }\n          // If it only overflows on the right, try all top positions from right to left, then try all bottom positions right to left.\n        } else if (overflows.positionRight.right) {\n          if (overflows.positionTop.top) {\n            if (overflows.positionBottom.right) {\n              return PopoverPlacement.BottomLeft;\n            } else if (overflows.positionBottomRight.right) {\n              return PopoverPlacement.Bottom;\n            } else {\n              return PopoverPlacement.BottomRight;\n            }\n          } else {\n            if (overflows.positionTop.right) {\n              return PopoverPlacement.TopLeft;\n            } else if (overflows.positionTopRight.right) {\n              return PopoverPlacement.Top;\n            } else {\n              return PopoverPlacement.TopRight;\n            }\n          }\n          // If it only over flows on the top, go bottom-right.\n        } else if (overflows.positionRight.top) {\n          return PopoverPlacement.BottomRight;\n          // If it only overflows on the bottom, go top-right.\n        } else if (overflows.positionRight.bottom) {\n          return PopoverPlacement.TopRight;\n        } else {\n          return PopoverPlacement.Right;\n        }\n      }\n      if (desiredPlacement === PopoverPlacement.BottomRight) {\n        // If it overflows on the bottom AND the right, try in the order: top, top-left, left.\n        if (overflows.positionBottomRight.bottom && overflows.positionBottomRight.right) {\n          if (overflows.positionTop.top) {\n            return PopoverPlacement.Left;\n          } else if (overflows.positionTop.right) {\n            return PopoverPlacement.TopLeft;\n          } else {\n            return PopoverPlacement.Top;\n          }\n          // If it only overflows on the bottom, try in the order: right, top-right.\n        } else if (overflows.positionBottomRight.bottom) {\n          if (overflows.positionRight.bottom) {\n            return PopoverPlacement.TopRight;\n          } else {\n            return PopoverPlacement.Right;\n          }\n          // If it only overflows on the right, try in the order: bottom, bottom-left.\n        } else if (overflows.positionBottomRight.right) {\n          if (overflows.positionBottom.right) {\n            return PopoverPlacement.BottomLeft;\n          } else {\n            return PopoverPlacement.Bottom;\n          }\n        } else {\n          return PopoverPlacement.BottomRight;\n        }\n      }\n      if (desiredPlacement === PopoverPlacement.Bottom) {\n        // If it overflows on the bottom AND left, go to top-right.\n        if (overflows.positionBottom.bottom && overflows.positionBottom.left) {\n          return PopoverPlacement.TopRight;\n          // If it overflows on the bottom AND right, go to top-left.\n        } else if (overflows.positionBottom.bottom && overflows.positionBottom.right) {\n          return PopoverPlacement.TopLeft;\n          // If it only overflows on the bottom, go to top.\n        } else if (overflows.positionBottom.bottom) {\n          return PopoverPlacement.Top;\n          // If it only overflows to the right, go to bottom-left.\n        } else if (overflows.positionBottom.right) {\n          return PopoverPlacement.BottomLeft;\n          // If it only overflows to the left, go to bottom-right.\n        } else if (overflows.positionBottom.left) {\n          return PopoverPlacement.BottomRight;\n        } else {\n          return PopoverPlacement.Bottom;\n        }\n      }\n      if (desiredPlacement === PopoverPlacement.BottomLeft) {\n        // If it overflows on the bottom AND the left, try in the order: top, top-right, right.\n        if (overflows.positionBottomLeft.bottom && overflows.positionBottomLeft.left) {\n          if (overflows.positionTop.top) {\n            return PopoverPlacement.Right;\n          } else if (overflows.positionTop.left) {\n            return PopoverPlacement.TopRight;\n          } else {\n            return PopoverPlacement.Top;\n          }\n          // If it only overflows on the bottom, try in the order: left, top-left.\n        } else if (overflows.positionBottomLeft.bottom) {\n          if (overflows.positionLeft.bottom) {\n            return PopoverPlacement.TopLeft;\n          } else {\n            return PopoverPlacement.Left;\n          }\n          // If it only overflows on the left, try in the order: bottom, bottom-right.\n        } else if (overflows.positionBottomLeft.left) {\n          if (overflows.positionBottom.left) {\n            return PopoverPlacement.BottomRight;\n          } else {\n            return PopoverPlacement.Bottom;\n          }\n        } else {\n          return PopoverPlacement.BottomLeft;\n        }\n      }\n      if (desiredPlacement === PopoverPlacement.Left) {\n        // If it overflows on the left AND the top, try in the order: bottom-left, bottom, bottom-right.\n        if (overflows.positionLeft.left && overflows.positionLeft.top) {\n          if (overflows.positionBottomLeft.left && overflows.positionBottom.left) {\n            return PopoverPlacement.BottomRight;\n          } else if (overflows.positionBottomRight.right) {\n            return PopoverPlacement.Bottom;\n          } else {\n            return PopoverPlacement.BottomLeft;\n          }\n          // If it overflows on the left AND the bottom, try in the order: top-left, top, top-right.\n        } else if (overflows.positionLeft.left && overflows.positionLeft.bottom) {\n          if (overflows.positionTopLeft.left && overflows.positionTop.left) {\n            return PopoverPlacement.TopRight;\n          } else if (overflows.positionTopLeft.left) {\n            return PopoverPlacement.Top;\n          } else {\n            return PopoverPlacement.TopLeft;\n          }\n          // If it only overflows on the left, try all top positions from left to right, then try all bottom positions left to right.\n        } else if (overflows.positionLeft.left) {\n          if (overflows.positionTop.top) {\n            if (overflows.positionBottom.left) {\n              return PopoverPlacement.BottomRight;\n            } else if (overflows.positionBottomLeft.left) {\n              return PopoverPlacement.Bottom;\n            } else {\n              return PopoverPlacement.BottomLeft;\n            }\n          } else {\n            if (overflows.positionTop.left) {\n              return PopoverPlacement.TopRight;\n            } else if (overflows.positionTopLeft.left) {\n              return PopoverPlacement.Top;\n            } else {\n              return PopoverPlacement.TopLeft;\n            }\n          }\n          // If it only over flows on the top, go bottom-left.\n        } else if (overflows.positionLeft.top) {\n          return PopoverPlacement.BottomLeft;\n          // If it only overflows on the bottom, go top-left.\n        } else if (overflows.positionLeft.bottom) {\n          return PopoverPlacement.TopLeft;\n        } else {\n          return PopoverPlacement.Left;\n        }\n      }\n      if (desiredPlacement === PopoverPlacement.TopLeft) {\n        // If it overflows on the top AND the left, try in the order: bottom, Bottom-right, right.\n        if (overflows.positionTopLeft.top && overflows.positionTopLeft.left) {\n          if (overflows.positionBottom.bottom) {\n            return PopoverPlacement.Right;\n          } else if (overflows.positionBottom.left) {\n            return PopoverPlacement.BottomRight;\n          } else {\n            return PopoverPlacement.Bottom;\n          }\n          // If it only overflows on the top, try in the order: left, bottom-left.\n        } else if (overflows.positionTopLeft.top) {\n          if (overflows.positionLeft.top) {\n            return PopoverPlacement.BottomLeft;\n          } else {\n            return PopoverPlacement.Left;\n          }\n          // If it only overflows on the left, try in the order: top, top-right.\n        } else if (overflows.positionTopLeft.left) {\n          if (overflows.positionTop.left) {\n            return PopoverPlacement.TopRight;\n          } else {\n            return PopoverPlacement.Top;\n          }\n        } else {\n          return PopoverPlacement.TopLeft;\n        }\n      }\n      return desiredPlacement;\n    }\n  }\n  PopoverContentComponent.ɵfac = function PopoverContentComponent_Factory(t) {\n    return new (t || PopoverContentComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n  PopoverContentComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: PopoverContentComponent,\n    selectors: [[\"popover-content\"]],\n    viewQuery: function PopoverContentComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.popoverDiv = _t.first);\n      }\n    },\n    hostBindings: function PopoverContentComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"resize\", function PopoverContentComponent_resize_HostBindingHandler($event) {\n          return ctx.onResize($event);\n        }, false, ɵngcc0.ɵɵresolveWindow);\n      }\n    },\n    inputs: {\n      placement: \"placement\",\n      animation: \"animation\",\n      closeOnClickOutside: \"closeOnClickOutside\",\n      closeOnMouseOutside: \"closeOnMouseOutside\",\n      appendToBody: \"appendToBody\",\n      size: \"size\",\n      content: \"content\",\n      title: \"title\",\n      parentClass: \"parentClass\"\n    },\n    ngContentSelectors: _c2,\n    decls: 9,\n    vars: 26,\n    consts: [[\"role\", \"popover\", 3, \"ngClass\"], [\"popoverDiv\", \"\"], [1, \"virtual-area\", 3, \"hidden\"], [1, \"arrow\"], [1, \"popover-header\", 3, \"hidden\"], [1, \"popover-body\"]],\n    template: function PopoverContentComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0, 1);\n        ɵngcc0.ɵɵelement(2, \"div\", 2);\n        ɵngcc0.ɵɵelement(3, \"div\", 3);\n        ɵngcc0.ɵɵelementStart(4, \"div\", 4);\n        ɵngcc0.ɵɵtext(5);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(6, \"div\", 5);\n        ɵngcc0.ɵɵprojection(7);\n        ɵngcc0.ɵɵtext(8);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassMapInterpolate2(\"bs-popover-\", ctx.effectivePlacement, \" popover-content popover \", ctx.parentClass, \"\");\n        ɵngcc0.ɵɵstyleProp(\"top\", ctx.top, \"px\")(\"left\", ctx.left, \"px\")(\"transition\", ctx.transitionEnabled ? \"0.15s opacity\" : \"\")(\"opacity\", ctx.opacity)(\"display\", \"block\");\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction5(20, _c1, ctx.size === \"small\", ctx.size === \"medium-small\", ctx.size === \"medium\", ctx.size === \"large\", ctx.isIn));\n        ɵngcc0.ɵɵattribute(\"aria-hidden\", ctx.opacity === 0);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"hidden\", !ctx.closeOnMouseOutside);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"hidden\", !ctx.title);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵtextInterpolate(ctx.title);\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵtextInterpolate1(\" \", ctx.content, \" \");\n      }\n    },\n    directives: [ɵngcc1.NgClass],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n  return PopoverContentComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/popover.directive.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * \\@group Basic Toolkit\n * \\@component Popover Directive\n */\nlet PopoverDirective = /*#__PURE__*/(() => {\n  class PopoverDirective {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    /**\n     * @param {?} viewContainerRef\n     * @param {?} cdr\n     * @param {?} resolver\n     * @param {?} appRef\n     * @param {?} injector\n     */\n    constructor(viewContainerRef, cdr, resolver, appRef, injector) {\n      this.viewContainerRef = viewContainerRef;\n      this.cdr = cdr;\n      this.resolver = resolver;\n      this.appRef = appRef;\n      this.injector = injector;\n      // -------------------------------------------------------------------------\n      // Properties\n      // -------------------------------------------------------------------------\n      this.popoverContentComponent = PopoverContentComponent;\n      this.popoverOnHover = true;\n      this.popoverDismissTimeout = 0;\n      this.onShown = new EventEmitter();\n      this.onHidden = new EventEmitter();\n    }\n    // -------------------------------------------------------------------------\n    // Event listeners\n    // -------------------------------------------------------------------------\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n    showOrHideOnClick(evt) {\n      if (this.popoverOnHover) {\n        return;\n      }\n      if (this.popoverDisabled) {\n        return;\n      }\n      evt.stopImmediatePropagation();\n      this.toggle();\n    }\n    /**\n     * @param {?} evt\n     * @return {?}\n     */\n    showOrHideOnTouch(evt) {\n      evt.stopImmediatePropagation();\n      if (!this.popoverOnHover) {\n        return;\n      }\n      if (this.popoverDisabled) {\n        return;\n      }\n      this.toggle();\n    }\n    /**\n     * @return {?}\n     */\n    showOnHover() {\n      if (!this.popoverOnHover) {\n        return;\n      }\n      if (this.popoverDisabled) {\n        return;\n      }\n      this.show();\n    }\n    /**\n     * @return {?}\n     */\n    hideOnHover() {\n      if (this.popoverCloseOnMouseOutside) {\n        return; // don't do anything since we do not control this\n      }\n\n      if (!this.popoverOnHover) {\n        return;\n      }\n      if (this.popoverDisabled) {\n        return;\n      }\n      this.hide();\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n      if (changes['popoverDisabled']) {\n        if (changes['popoverDisabled'].currentValue) {\n          this.hide();\n        }\n      }\n    }\n    /**\n     * @protected\n     * @param {?} component\n     * @return {?}\n     */\n    createComponent(component) {\n      /** @type {?} */\n      const factory = this.resolver.resolveComponentFactory(component);\n      // Create a component reference from the component\n      /** @type {?} */\n      const componentRef = this.appendToBody ? factory.create(this.injector) : this.viewContainerRef.createComponent(factory);\n      if (this.appendToBody) {\n        // Attach component to the appRef so that it's inside the ng component tree\n        this.appRef.attachView(componentRef.hostView);\n        // Get DOM element from component\n        /** @type {?} */\n        const domElem = /** @type {?} */ /** @type {?} */componentRef.hostView.rootNodes[0];\n        // Append DOM element to the body\n        document.body.appendChild(domElem);\n      }\n      return componentRef;\n    }\n    /**\n     * @protected\n     * @param {?} componentRef\n     * @return {?}\n     */\n    removeComponent(componentRef) {\n      if (this.popover) {\n        if (this.appendToBody) {\n          this.appRef.detachView(componentRef.hostView);\n        }\n        componentRef.destroy();\n      }\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * @return {?}\n     */\n    toggle() {\n      if (!this.visible) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    }\n    /**\n     * @return {?}\n     */\n    show() {\n      if (this.visible) {\n        return;\n      }\n      this.visible = true;\n      if (typeof this.content === 'string') {\n        if (!this.visible) {\n          return;\n        }\n        this.popover = this.createComponent(this.popoverContentComponent);\n        /** @type {?} */\n        const popover = /** @type {?} */this.popover.instance;\n        popover.popover = this;\n        popover.content = /** @type {?} */this.content;\n        if (this.popoverPlacement !== undefined) {\n          popover.placement = this.popoverPlacement;\n        }\n        if (this.popoverAnimation !== undefined) {\n          popover.animation = this.popoverAnimation;\n        }\n        if (this.popoverTitle !== undefined) {\n          popover.title = this.popoverTitle;\n        }\n        if (this.popoverCloseOnClickOutside !== undefined) {\n          popover.closeOnClickOutside = this.popoverCloseOnClickOutside;\n        }\n        if (this.popoverCloseOnMouseOutside !== undefined) {\n          popover.closeOnMouseOutside = this.popoverCloseOnMouseOutside;\n        }\n        if (this.popoverSize) {\n          popover.size = this.popoverSize;\n        }\n        popover.appendToBody = this.appendToBody;\n        popover.onCloseFromOutside.subscribe(\n        /**\n        * @return {?}\n        */\n        () => this.hide());\n        // if dismissTimeout option is set, then this popover will be dismissed in dismissTimeout time\n        if (this.popoverDismissTimeout > 0) {\n          setTimeout(\n          /**\n          * @return {?}\n          */\n          () => this.hide(), this.popoverDismissTimeout);\n        }\n      } else {\n        /** @type {?} */\n        const popover = /** @type {?} */this.content;\n        popover.popover = this;\n        if (this.popoverPlacement !== undefined) {\n          popover.placement = this.popoverPlacement;\n        }\n        if (this.popoverAnimation !== undefined) {\n          popover.animation = this.popoverAnimation;\n        }\n        if (this.popoverTitle !== undefined) {\n          popover.title = this.popoverTitle;\n        }\n        if (this.popoverCloseOnClickOutside !== undefined) {\n          popover.closeOnClickOutside = this.popoverCloseOnClickOutside;\n        }\n        if (this.popoverCloseOnMouseOutside !== undefined) {\n          popover.closeOnMouseOutside = this.popoverCloseOnMouseOutside;\n        }\n        if (this.popoverSize) {\n          popover.size = this.popoverSize;\n        }\n        popover.appendToBody = this.appendToBody;\n        popover.onCloseFromOutside.subscribe(\n        /**\n        * @return {?}\n        */\n        () => this.hide());\n        // if dismissTimeout option is set, then this popover will be dismissed in dismissTimeout time\n        if (this.popoverDismissTimeout > 0) {\n          setTimeout(\n          /**\n          * @return {?}\n          */\n          () => this.hide(), this.popoverDismissTimeout);\n        }\n        popover.show();\n      }\n      this.cdr.detectChanges();\n      this.onShown.emit(this);\n    }\n    /**\n     * @return {?}\n     */\n    hide() {\n      if (!this.visible) {\n        return;\n      }\n      this.visible = false;\n      this.removeComponent(this.popover);\n      if (this.content instanceof PopoverContentComponent) {\n        /** @type {?} */this.content.hideFromPopover();\n      }\n      this.cdr.detectChanges();\n      this.onHidden.emit(this);\n    }\n    /**\n     * @return {?}\n     */\n    getElement() {\n      return this.viewContainerRef.element.nativeElement;\n    }\n  }\n  PopoverDirective.ɵfac = function PopoverDirective_Factory(t) {\n    return new (t || PopoverDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector));\n  };\n  PopoverDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: PopoverDirective,\n    selectors: [[\"\", \"popover\", \"\"]],\n    hostBindings: function PopoverDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function PopoverDirective_click_HostBindingHandler($event) {\n          return ctx.showOrHideOnClick($event);\n        })(\"touchend\", function PopoverDirective_touchend_HostBindingHandler($event) {\n          return ctx.showOrHideOnTouch($event);\n        })(\"focusin\", function PopoverDirective_focusin_HostBindingHandler() {\n          return ctx.showOnHover();\n        })(\"mouseenter\", function PopoverDirective_mouseenter_HostBindingHandler() {\n          return ctx.showOnHover();\n        })(\"focusout\", function PopoverDirective_focusout_HostBindingHandler() {\n          return ctx.hideOnHover();\n        })(\"mouseleave\", function PopoverDirective_mouseleave_HostBindingHandler() {\n          return ctx.hideOnHover();\n        });\n      }\n    },\n    inputs: {\n      popoverOnHover: \"popoverOnHover\",\n      popoverDismissTimeout: \"popoverDismissTimeout\",\n      content: [\"popover\", \"content\"],\n      popoverSize: \"popoverSize\",\n      popoverDisabled: \"popoverDisabled\",\n      popoverAnimation: \"popoverAnimation\",\n      popoverPlacement: \"popoverPlacement\",\n      popoverTitle: \"popoverTitle\",\n      popoverCloseOnClickOutside: \"popoverCloseOnClickOutside\",\n      popoverCloseOnMouseOutside: \"popoverCloseOnMouseOutside\",\n      appendToBody: \"appendToBody\"\n    },\n    outputs: {\n      onShown: \"onShown\",\n      onHidden: \"onHidden\"\n    },\n    exportAs: [\"popover\"],\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  /** @nocollapse */\n  return PopoverDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/popover.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet PopoverModule = /*#__PURE__*/(() => {\n  class PopoverModule {}\n  PopoverModule.ɵfac = function PopoverModule_Factory(t) {\n    return new (t || PopoverModule)();\n  };\n  PopoverModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: PopoverModule\n  });\n  PopoverModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return PopoverModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PopoverModule, {\n    declarations: function () {\n      return [PopoverDirective, PopoverContentComponent];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [PopoverContentComponent, PopoverDirective];\n    }\n  });\n})();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: ngx-smart-popover.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { PopoverContentComponent, PopoverDirective, PopoverModule, PopoverPlacement };\n\n//# sourceMappingURL=ngx-smart-popover.js.map","map":null,"metadata":{},"sourceType":"module"}