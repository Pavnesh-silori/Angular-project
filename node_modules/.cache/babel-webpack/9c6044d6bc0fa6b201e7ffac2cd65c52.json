{"ast":null,"code":"import { ɵɵdefineInjectable, ɵɵinject, Injectable, Optional, Inject, InjectionToken, EventEmitter, Component, ChangeDetectionStrategy, NgZone, ViewChild, Input, Output, NgModule } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport * as ɵngcc0 from '@angular/core';\nconst _c0 = [\"path\"];\nconst DEGREE_IN_RADIANS = Math.PI / 180;\nlet RoundProgressService = /*#__PURE__*/(() => {\n  class RoundProgressService {\n    constructor(document) {\n      this.supportsSvg = !!(document && document.createElementNS && document.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGRect);\n      this.base = document && document.head.querySelector('base');\n      this.hasPerf = typeof window !== 'undefined' && window.performance && window.performance.now && typeof window.performance.now() === 'number';\n    }\n    /**\r\n     * Resolves a SVG color against the page's `base` tag.\r\n     */\n    resolveColor(color) {\n      if (this.base && this.base.href) {\n        const hashIndex = color.indexOf('#');\n        if (hashIndex > -1 && color.indexOf('url') > -1) {\n          return color.slice(0, hashIndex) + location.href + color.slice(hashIndex);\n        }\n      }\n      return color;\n    }\n    /**\r\n     * Generates a timestamp.\r\n     */\n    getTimestamp() {\n      return this.hasPerf ? window.performance.now() : Date.now();\n    }\n    /**\r\n     * Generates the value for an SVG arc.\r\n     * @param current       Current value.\r\n     * @param total         Maximum value.\r\n     * @param pathRadius    Radius of the SVG path.\r\n     * @param elementRadius Radius of the SVG container.\r\n     * @param isSemicircle  Whether the element should be a semicircle.\r\n     */\n    getArc(current, total, pathRadius, elementRadius, isSemicircle = false) {\n      const value = Math.max(0, Math.min(current || 0, total));\n      const maxAngle = isSemicircle ? 180 : 359.9999;\n      const percentage = total === 0 ? maxAngle : value / total * maxAngle;\n      const start = this._polarToCartesian(elementRadius, pathRadius, percentage);\n      const end = this._polarToCartesian(elementRadius, pathRadius, 0);\n      const arcSweep = percentage <= 180 ? 0 : 1;\n      return `M ${start} A ${pathRadius} ${pathRadius} 0 ${arcSweep} 0 ${end}`;\n    }\n    /**\r\n     * Converts polar cooradinates to Cartesian.\r\n     * @param elementRadius  Radius of the wrapper element.\r\n     * @param pathRadius     Radius of the path being described.\r\n     * @param angleInDegrees Degree to be converted.\r\n     */\n    _polarToCartesian(elementRadius, pathRadius, angleInDegrees) {\n      const angleInRadians = (angleInDegrees - 90) * DEGREE_IN_RADIANS;\n      const x = elementRadius + pathRadius * Math.cos(angleInRadians);\n      const y = elementRadius + pathRadius * Math.sin(angleInRadians);\n      return x + ' ' + y;\n    }\n  }\n  RoundProgressService.ɵfac = function RoundProgressService_Factory(t) {\n    return new (t || RoundProgressService)(ɵngcc0.ɵɵinject(DOCUMENT, 8));\n  };\n  RoundProgressService.ɵprov = ɵɵdefineInjectable({\n    factory: function RoundProgressService_Factory() {\n      return new RoundProgressService(ɵɵinject(DOCUMENT, 8));\n    },\n    token: RoundProgressService,\n    providedIn: \"root\"\n  });\n  return RoundProgressService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst ROUND_PROGRESS_DEFAULTS = new InjectionToken('ROUND_PROGRESS_DEFAULTS');\nconst ɵ0 = {\n  radius: 125,\n  animation: 'easeOutCubic',\n  animationDelay: null,\n  duration: 500,\n  stroke: 15,\n  color: '#45CCCE',\n  background: '#EAEAEA',\n  responsive: false,\n  clockwise: true,\n  semicircle: false,\n  rounded: false\n};\nconst ROUND_PROGRESS_DEFAULTS_PROVIDER = {\n  provide: ROUND_PROGRESS_DEFAULTS,\n  useValue: ɵ0\n};\n\n/**\r\n * TERMS OF USE - EASING EQUATIONS\r\n * Open source under the BSD License.\r\n *\r\n * Copyright © 2001 Robert Penner\r\n * All rights reserved.\r\n * Redistribution and use in source and binary forms, with or without modification, are permitted\r\n * provided that the following conditions are met:\r\n *\r\n * Redistributions of source code must retain the above copyright notice, this list of conditions\r\n * and the following disclaimer.\r\n *\r\n * Redistributions in binary form must reproduce the above copyright notice, this list of conditions\r\n * and the following disclaimer in the documentation and/or other materials provided with the\r\n * distribution.\r\n *\r\n * Neither the name of the author nor the names of contributors may be used to endorse or promote\r\n * products derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\r\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\r\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\r\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\nlet RoundProgressEase = /*#__PURE__*/(() => {\n  class RoundProgressEase {\n    // t: current time (or position) of the neonate. This can be seconds or frames, steps,\n    // seconds, ms, whatever – as long as the unit is the same as is used for the total time.\n    // b: beginning value of the property.\n    // c: change between the beginning and destination value of the property.\n    // d: total time of the neonate.\n    linearEase(t, b, c, d) {\n      return c * t / d + b;\n    }\n    easeInQuad(t, b, c, d) {\n      return c * (t /= d) * t + b;\n    }\n    easeOutQuad(t, b, c, d) {\n      return -c * (t /= d) * (t - 2) + b;\n    }\n    easeInOutQuad(t, b, c, d) {\n      // tslint:disable-next-line:no-conditional-assignment\n      if ((t /= d / 2) < 1) {\n        return c / 2 * t * t + b;\n      }\n      return -c / 2 * (--t * (t - 2) - 1) + b;\n    }\n    easeInCubic(t, b, c, d) {\n      return c * (t /= d) * t * t + b;\n    }\n    easeOutCubic(t, b, c, d) {\n      return c * ((t = t / d - 1) * t * t + 1) + b;\n    }\n    easeInOutCubic(t, b, c, d) {\n      // tslint:disable-next-line:no-conditional-assignment\n      if ((t /= d / 2) < 1) {\n        return c / 2 * t * t * t + b;\n      }\n      return c / 2 * ((t -= 2) * t * t + 2) + b;\n    }\n    easeInQuart(t, b, c, d) {\n      return c * (t /= d) * t * t * t + b;\n    }\n    easeOutQuart(t, b, c, d) {\n      return -c * ((t = t / d - 1) * t * t * t - 1) + b;\n    }\n    easeInOutQuart(t, b, c, d) {\n      // tslint:disable-next-line:no-conditional-assignment\n      if ((t /= d / 2) < 1) {\n        return c / 2 * t * t * t * t + b;\n      }\n      return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\n    }\n    easeInQuint(t, b, c, d) {\n      return c * (t /= d) * t * t * t * t + b;\n    }\n    easeOutQuint(t, b, c, d) {\n      return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\n    }\n    easeInOutQuint(t, b, c, d) {\n      // tslint:disable-next-line:no-conditional-assignment\n      if ((t /= d / 2) < 1) {\n        return c / 2 * t * t * t * t * t + b;\n      }\n      return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\n    }\n    easeInSine(t, b, c, d) {\n      return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\n    }\n    easeOutSine(t, b, c, d) {\n      return c * Math.sin(t / d * (Math.PI / 2)) + b;\n    }\n    easeInOutSine(t, b, c, d) {\n      return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\n    }\n    easeInExpo(t, b, c, d) {\n      return t === 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;\n    }\n    easeOutExpo(t, b, c, d) {\n      return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\n    }\n    easeInOutExpo(t, b, c, d) {\n      if (t === 0) {\n        return b;\n      }\n      if (t === d) {\n        return b + c;\n      }\n      // tslint:disable-next-line:no-conditional-assignment\n      if ((t /= d / 2) < 1) {\n        return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\n      }\n      return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\n    }\n    easeInCirc(t, b, c, d) {\n      return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;\n    }\n    easeOutCirc(t, b, c, d) {\n      return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;\n    }\n    easeInOutCirc(t, b, c, d) {\n      // tslint:disable-next-line:no-conditional-assignment\n      if ((t /= d / 2) < 1) {\n        return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;\n      }\n      return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;\n    }\n    easeInElastic(t, b, c, d) {\n      const p = d * 0.3;\n      let s = 1.70158;\n      let a = c;\n      if (t === 0) {\n        return b;\n      }\n      // tslint:disable-next-line:no-conditional-assignment\n      if ((t /= d) === 1) {\n        return b + c;\n      }\n      if (a < Math.abs(c)) {\n        a = c;\n        s = p / 4;\n      } else {\n        s = p / (2 * Math.PI) * Math.asin(c / a);\n      }\n      return -(a * Math.pow(2, 10 * t--) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n    }\n    easeOutElastic(t, b, c, d) {\n      const p = d * 0.3;\n      let s = 1.70158;\n      let a = c;\n      if (t === 0) {\n        return b;\n      }\n      // tslint:disable-next-line:no-conditional-assignment\n      if ((t /= d) === 1) {\n        return b + c;\n      }\n      if (a < Math.abs(c)) {\n        a = c;\n        s = p / 4;\n      } else {\n        s = p / (2 * Math.PI) * Math.asin(c / a);\n      }\n      return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;\n    }\n    easeInOutElastic(t, b, c, d) {\n      const p = d * (0.3 * 1.5);\n      let s = 1.70158;\n      let a = c;\n      if (t === 0) {\n        return b;\n      }\n      // tslint:disable-next-line:no-conditional-assignment\n      if ((t /= d / 2) === 2) {\n        return b + c;\n      }\n      if (a < Math.abs(c)) {\n        a = c;\n        s = p / 4;\n      } else {\n        s = p / (2 * Math.PI) * Math.asin(c / a);\n      }\n      if (t < 1) {\n        return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n      }\n      return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;\n    }\n    easeInBack(t, b, c, d, s = 1.70158) {\n      return c * (t /= d) * t * ((s + 1) * t - s) + b;\n    }\n    easeOutBack(t, b, c, d, s = 1.70158) {\n      return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\n    }\n    easeInOutBack(t, b, c, d, s = 1.70158) {\n      // tslint:disable-next-line:no-conditional-assignment\n      if ((t /= d / 2) < 1) {\n        return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;\n      }\n      return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;\n    }\n    easeInBounce(t, b, c, d) {\n      return c - this.easeOutBounce(d - t, 0, c, d) + b;\n    }\n    easeOutBounce(t, b, c, d) {\n      // tslint:disable-next-line:no-conditional-assignment\n      if ((t /= d) < 1 / 2.75) {\n        return c * (7.5625 * t * t) + b;\n      } else if (t < 2 / 2.75) {\n        return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;\n      } else if (t < 2.5 / 2.75) {\n        return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;\n      }\n      return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;\n    }\n    easeInOutBounce(t, b, c, d) {\n      if (t < d / 2) {\n        return this.easeInBounce(t * 2, 0, c, d) * 0.5 + b;\n      }\n      return this.easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;\n    }\n  }\n  RoundProgressEase.ɵfac = function RoundProgressEase_Factory(t) {\n    return new (t || RoundProgressEase)();\n  };\n  RoundProgressEase.ɵprov = ɵɵdefineInjectable({\n    factory: function RoundProgressEase_Factory() {\n      return new RoundProgressEase();\n    },\n    token: RoundProgressEase,\n    providedIn: \"root\"\n  });\n  return RoundProgressEase;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RoundProgressComponent = /*#__PURE__*/(() => {\n  class RoundProgressComponent {\n    constructor(service, easing, defaults, ngZone) {\n      this.service = service;\n      this.easing = easing;\n      this.defaults = defaults;\n      this.ngZone = ngZone;\n      /** Radius of the circle. */\n      this.radius = this.defaults.radius;\n      /** Name of the easing function to use when animating. */\n      this.animation = this.defaults.animation;\n      /** Time in millisconds by which to delay the animation. */\n      this.animationDelay = this.defaults.animationDelay;\n      /** Duration of the animation. */\n      this.duration = this.defaults.duration;\n      /** Width of the circle's stroke. */\n      this.stroke = this.defaults.stroke;\n      /** Color of the circle. */\n      this.color = this.defaults.color;\n      /** Background color of the circle. */\n      this.background = this.defaults.background;\n      /** Whether the circle should take up the width of its parent. */\n      this.responsive = this.defaults.responsive;\n      /** Whether the circle is filling up clockwise. */\n      this.clockwise = this.defaults.clockwise;\n      /** Whether to render a semicircle. */\n      this.semicircle = this.defaults.semicircle;\n      /** Whether the tip of the progress should be rounded off. */\n      this.rounded = this.defaults.rounded;\n      /** Emits when a new value has been rendered. */\n      this.onRender = new EventEmitter();\n      this.lastAnimationId = 0;\n    }\n    /** Animates a change in the current value. */\n    _animateChange(from, to) {\n      if (typeof from !== 'number') {\n        from = 0;\n      }\n      to = this._clamp(to);\n      from = this._clamp(from);\n      const self = this;\n      const changeInValue = to - from;\n      const duration = self.duration;\n      // Avoid firing change detection for each of the animation frames.\n      self.ngZone.runOutsideAngular(() => {\n        const start = () => {\n          const startTime = self.service.getTimestamp();\n          const id = ++self.lastAnimationId;\n          requestAnimationFrame(function animation() {\n            const currentTime = Math.min(self.service.getTimestamp() - startTime, duration);\n            const value = self.easing[self.animation](currentTime, from, changeInValue, duration);\n            self._setPath(value);\n            self.onRender.emit(value);\n            if (id === self.lastAnimationId && currentTime < duration) {\n              requestAnimationFrame(animation);\n            }\n          });\n        };\n        if (this.animationDelay > 0) {\n          setTimeout(start, this.animationDelay);\n        } else {\n          start();\n        }\n      });\n    }\n    /** Sets the path dimensions. */\n    _setPath(value) {\n      if (this.path) {\n        const arc = this.service.getArc(value, this.max, this.radius - this.stroke / 2, this.radius, this.semicircle);\n        this.path.nativeElement.setAttribute('d', arc);\n      }\n    }\n    /** Clamps a value between the maximum and 0. */\n    _clamp(value) {\n      return Math.max(0, Math.min(value || 0, this.max));\n    }\n    /** Determines the SVG transforms for the <path> node. */\n    getPathTransform() {\n      const diameter = this._getDiameter();\n      if (this.semicircle) {\n        return this.clockwise ? `translate(0, ${diameter}) rotate(-90)` : `translate(${diameter + ',' + diameter}) rotate(90) scale(-1, 1)`;\n      } else if (!this.clockwise) {\n        return `scale(-1, 1) translate(-${diameter} 0)`;\n      }\n    }\n    /** Resolves a color through the service. */\n    resolveColor(color) {\n      return this.service.resolveColor(color);\n    }\n    /** Change detection callback. */\n    ngOnChanges(changes) {\n      if (changes.current) {\n        this._animateChange(changes.current.previousValue, changes.current.currentValue);\n      } else {\n        this._setPath(this.current);\n      }\n    }\n    /** Diameter of the circle. */\n    _getDiameter() {\n      return this.radius * 2;\n    }\n    /** The CSS height of the wrapper element. */\n    _getElementHeight() {\n      if (!this.responsive) {\n        return (this.semicircle ? this.radius : this._getDiameter()) + 'px';\n      }\n    }\n    /** Viewbox for the SVG element. */\n    _getViewBox() {\n      const diameter = this._getDiameter();\n      return `0 0 ${diameter} ${this.semicircle ? this.radius : diameter}`;\n    }\n    /** Bottom padding for the wrapper element. */\n    _getPaddingBottom() {\n      if (this.responsive) {\n        return this.semicircle ? '50%' : '100%';\n      }\n    }\n  }\n  RoundProgressComponent.ɵfac = function RoundProgressComponent_Factory(t) {\n    return new (t || RoundProgressComponent)(ɵngcc0.ɵɵdirectiveInject(RoundProgressService), ɵngcc0.ɵɵdirectiveInject(RoundProgressEase), ɵngcc0.ɵɵdirectiveInject(ROUND_PROGRESS_DEFAULTS), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n  RoundProgressComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: RoundProgressComponent,\n    selectors: [[\"round-progress\"]],\n    viewQuery: function RoundProgressComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.path = _t.first);\n      }\n    },\n    hostAttrs: [\"role\", \"progressbar\"],\n    hostVars: 10,\n    hostBindings: function RoundProgressComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"aria-valuemin\", ctx.current)(\"aria-valuemax\", ctx.max);\n        ɵngcc0.ɵɵstyleProp(\"width\", ctx.responsive ? \"\" : ctx._getDiameter() + \"px\")(\"height\", ctx._getElementHeight())(\"padding-bottom\", ctx._getPaddingBottom());\n        ɵngcc0.ɵɵclassProp(\"responsive\", ctx.responsive);\n      }\n    },\n    inputs: {\n      radius: \"radius\",\n      animation: \"animation\",\n      animationDelay: \"animationDelay\",\n      duration: \"duration\",\n      stroke: \"stroke\",\n      color: \"color\",\n      background: \"background\",\n      responsive: \"responsive\",\n      clockwise: \"clockwise\",\n      semicircle: \"semicircle\",\n      rounded: \"rounded\",\n      current: \"current\",\n      max: \"max\"\n    },\n    outputs: {\n      onRender: \"onRender\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 4,\n    vars: 15,\n    consts: [[\"xmlns\", \"http://www.w3.org/2000/svg\"], [\"fill\", \"none\"], [\"path\", \"\"]],\n    template: function RoundProgressComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵnamespaceSVG();\n        ɵngcc0.ɵɵelementStart(0, \"svg\", 0);\n        ɵngcc0.ɵɵelement(1, \"circle\", 1);\n        ɵngcc0.ɵɵelement(2, \"path\", 1, 2);\n        ɵngcc0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"viewBox\", ctx._getViewBox());\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵstyleProp(\"stroke\", ctx.resolveColor(ctx.background))(\"stroke-width\", ctx.stroke);\n        ɵngcc0.ɵɵattribute(\"cx\", ctx.radius)(\"cy\", ctx.radius)(\"r\", ctx.radius - ctx.stroke / 2);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵstyleProp(\"stroke-width\", ctx.stroke)(\"stroke\", ctx.resolveColor(ctx.color))(\"stroke-linecap\", ctx.rounded ? \"round\" : \"\");\n        ɵngcc0.ɵɵattribute(\"transform\", ctx.getPathTransform());\n      }\n    },\n    styles: [\"[_nghost-%COMP%]{display:block;overflow:hidden;position:relative}.responsive[_nghost-%COMP%]{padding-bottom:100%;width:100%}.responsive[_nghost-%COMP%] > svg[_ngcontent-%COMP%]{height:100%;left:0;position:absolute;top:0;width:100%}\"],\n    changeDetection: 0\n  });\n  return RoundProgressComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RoundProgressModule = /*#__PURE__*/(() => {\n  class RoundProgressModule {}\n  RoundProgressModule.ɵfac = function RoundProgressModule_Factory(t) {\n    return new (t || RoundProgressModule)();\n  };\n  RoundProgressModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: RoundProgressModule\n  });\n  RoundProgressModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [ROUND_PROGRESS_DEFAULTS_PROVIDER]\n  });\n  return RoundProgressModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(RoundProgressModule, {\n    declarations: [RoundProgressComponent],\n    exports: [RoundProgressComponent]\n  });\n})();\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { ROUND_PROGRESS_DEFAULTS, ROUND_PROGRESS_DEFAULTS_PROVIDER, RoundProgressComponent, RoundProgressEase, RoundProgressModule, RoundProgressService, RoundProgressModule as RoundprogressModule, ɵ0 };\n\n//# sourceMappingURL=angular-svg-round-progressbar.js.map","map":null,"metadata":{},"sourceType":"module"}