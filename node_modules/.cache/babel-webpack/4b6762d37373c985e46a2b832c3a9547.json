{"ast":null,"code":"import { combineLatest } from 'rxjs';\nimport { PROCESS_INPUT_ENUM, PROCESS_OUTPUT_ENTITY_SOURCE_KEYID_ENUM, PROCESS_OUTPUT_ENUM } from '@netzero/enum/process.enum';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/router\";\nimport * as i2 from \"@library/storage-service\";\nimport * as i3 from \"@netzero/controller/production-route.controller\";\nconst _c0 = [\"myCanvas\"];\nconst DEFAULT_STROKE_COLOR = 'black';\nconst ELECTRICITY_INPUT_COLOR = '#063474';\nconst HEAT_INPUT_COLOR = '#FF3C00';\nconst PROCESS_BOX_COLOR = '#043484';\nconst PRODUCT_INPUT_COLOR = '#f57c05';\nconst PROCESS_OUTPUT_COLOR = '#6c757d';\nconst PROCESS_CONNECTION_COLOR = 'green';\nconst fuel_input_color = 'blue';\nconst CURVE_RADIUS = 16;\nconst SPACE_BW_LEFT_INPUTS = 15;\nconst HORIZONTAL_SPACE_BW_OUTPUTS = 20;\nexport let ProcessMapComponent = /*#__PURE__*/(() => {\n  class ProcessMapComponent {\n    constructor(activatedRoute, storageService, prController) {\n      this.prController = prController;\n      this.refresh = false;\n      this.nodes = [];\n      this.multi_connections = [];\n      this.externalInputs = [];\n      this.productionRoute = null;\n      this.total_rows = 1;\n      this.nodeCount = 5;\n      this.inputLines_y = 70;\n      this.nodeWidth = 200;\n      this.nodeHeight = 100;\n      this.nodesPerRow = 3;\n      this.canvasHeight = 600;\n      this.canvasWidth = 600;\n      this.heatSvgString = `\n            <svg \n                xmlns=\"http://www.w3.org/2000/svg\" \n                height=\"24px\" viewBox=\"0 -960 960 960\" width=\"24px\" \n                fill=\"${HEAT_INPUT_COLOR}\">\n                <path d=\"M240-400q0 52 21 98.5t60 81.5q-1-5-1-9v-9q0-32 12-60t35-51l113-111 113 111q23 23 35 51t12 60v9q0 4-1 9 39-35 60-81.5t21-98.5q0-50-18.5-94.5T648-574q-20 13-42 19.5t-45 6.5q-62 0-107.5-41T401-690q-39 33-69 68.5t-50.5 72Q261-513 250.5-475T240-400Zm240 52-57 56q-11 11-17 25t-6 29q0 32 23.5 55t56.5 23q33 0 56.5-23t23.5-55q0-16-6-29.5T537-292l-57-56Zm0-492v132q0 34 23.5 57t57.5 23q18 0 33.5-7.5T622-658l18-22q74 42 117 117t43 163q0 134-93 227T480-80q-134 0-227-93t-93-227q0-129 86.5-245T480-840Z\"/>\n            </svg>`;\n      this.electricitySvgString = `\n            <svg xmlns=\"http://www.w3.org/2000/svg\" \n                height=\"24px\" viewBox=\"0 -960 960 960\" width=\"24px\" \n                fill=\"${ELECTRICITY_INPUT_COLOR}\">\n                <path d=\"m280-80 160-300-320-40 480-460h80L520-580l320 40L360-80h-80Zm222-247 161-154-269-34 63-117-160 154 268 33-63 118Zm-22-153Z\"/>\n            </svg>`;\n      this.loadImage = (svg, width, height, callback) => {\n        const svgBlob = new Blob([svg], {\n          type: 'image/svg+xml;charset=utf-8'\n        });\n        const url = URL.createObjectURL(svgBlob);\n        const img = new Image();\n        img.onload = () => {\n          URL.revokeObjectURL(url);\n          callback(img);\n        };\n        img.src = url;\n      };\n      this.drawRoundedRect = (ctx, x, y, width, height, borderRadius) => {\n        ctx.strokeStyle = PROCESS_BOX_COLOR;\n        ctx.beginPath(); /* Begins a new path by emptying the list of sub-paths */\n        ctx.moveTo(x + borderRadius, y); /*  Moves the starting point of a new sub-path to the (x, y) coordinates specified. */\n        ctx.lineTo(x + width - borderRadius, y); /* Adds a straight line to the current path by connecting the current point to the (x, y) coordinates specified. */\n        ctx.quadraticCurveTo(x + width, y, x + width, y + borderRadius); /* used to create a quadratic Bézier curve. */\n        ctx.lineTo(x + width, y + height - borderRadius);\n        ctx.quadraticCurveTo(x + width, y + height, x + width - borderRadius, y + height);\n        ctx.lineTo(x + borderRadius, y + height);\n        ctx.quadraticCurveTo(x, y + height, x, y + height - borderRadius);\n        ctx.lineTo(x, y + borderRadius);\n        ctx.quadraticCurveTo(x, y, x + borderRadius, y);\n        ctx.stroke(); /* Renders the drawn path. */\n      };\n\n      this.isExported = (typeKeyID, source, entityID) => {\n        switch (typeKeyID) {\n          case PROCESS_OUTPUT_ENUM.ELECTRICITY:\n          case PROCESS_OUTPUT_ENUM.CO_PRODUCT:\n          case PROCESS_OUTPUT_ENUM.BY_PRODUCT_AND_WASTE:\n            return true;\n          case PROCESS_OUTPUT_ENUM.HEAT:\n            return source.map(s => s.keyID).some(s => s == PROCESS_OUTPUT_ENTITY_SOURCE_KEYID_ENUM.HEAT_GENERATED_AND_EXPORTED);\n          case PROCESS_OUTPUT_ENUM.INTERMEDIATE_PRODUCT:\n          case PROCESS_OUTPUT_ENUM.PRECURSOR_PRODUCT:\n            return source.filter(source => source.entityID == entityID).map(s => s.keyID).some(s => s == PROCESS_OUTPUT_ENTITY_SOURCE_KEYID_ENUM.EXPORTED_FROM_THIS_PROCESS);\n          case PROCESS_OUTPUT_ENUM.WASTE_GAS_STREAM:\n            return source.filter(source => source.entityID == entityID).map(s => s.keyID).some(s => s == PROCESS_OUTPUT_ENTITY_SOURCE_KEYID_ENUM.EXPORTED_TO_CBAM_INSTALLATION || s == PROCESS_OUTPUT_ENTITY_SOURCE_KEYID_ENUM.EXPORTED_TO_NON_CBAM_INSTALLATION);\n          default:\n            break;\n        }\n        return false;\n      };\n      this.isUsedInProductionRoute = (typeKeyID, source, entityID) => {\n        switch (typeKeyID) {\n          case PROCESS_OUTPUT_ENUM.ELECTRICITY:\n          case PROCESS_OUTPUT_ENUM.CO_PRODUCT:\n          case PROCESS_OUTPUT_ENUM.FINISHED_PRODUCT:\n            return true;\n          case PROCESS_OUTPUT_ENUM.HEAT:\n          // return source.map(s => s.keyID).some(s => s == PROCESS_OUTPUT_ENTITY_SOURCE_KEYID_ENUM.HEAT_GENERATED_AND_EXPORTED);\n          case PROCESS_OUTPUT_ENUM.INTERMEDIATE_PRODUCT:\n          case PROCESS_OUTPUT_ENUM.PRECURSOR_PRODUCT:\n            return source.filter(source => source.entityID == entityID).map(s => s.keyID).some(s => s == PROCESS_OUTPUT_ENTITY_SOURCE_KEYID_ENUM.CONSUMED_IN_PRODUCTION_ROUTE);\n          case PROCESS_OUTPUT_ENUM.WASTE_GAS_STREAM:\n            return source.filter(source => source.entityID == entityID).map(s => s.keyID).some(s => s == PROCESS_OUTPUT_ENTITY_SOURCE_KEYID_ENUM.CONSUMED_AS_FUEL_IN_PRODUCTION_ROUTE);\n          default:\n            break;\n        }\n        return false;\n      };\n      this.currentOrgID = storageService.getStorage('currentOrgID');\n      combineLatest([activatedRoute.params, activatedRoute.queryParams]).subscribe(([params, queryParams]) => {\n        if (params['productionRouteID']) {\n          this.productionRouteID = parseInt(params['productionRouteID']);\n          this.getProductionRoute();\n        } else if (queryParams['productionRouteID']) {\n          if (this.productionRoute == null) {\n            this.productionRouteID = queryParams['productionRouteID'];\n            this.getProductionRoute();\n          }\n        }\n      });\n    }\n    ngOnChanges(changes) {\n      if (changes.refresh && !changes.refresh.firstChange) {\n        this.getProductionRoute();\n      }\n    }\n    ngOnInit() {}\n    getProductionRoute() {\n      this.prController.getProductionRouteByID(this.currentOrgID, this.productionRouteID).subscribe(res => {\n        this.productionRoute = res;\n        this.initCanvas();\n      });\n    }\n    drawNonProductInputs() {\n      this.createInputLine(this.inputLines_y - 5, ELECTRICITY_INPUT_COLOR);\n      this.loadImage(this.electricitySvgString, 5, 5, image => {\n        this.ctx.drawImage(image, 40, this.inputLines_y - 15, 15, 15);\n        this.ctx.fillText('Electricity', 0, this.inputLines_y - 5);\n      });\n      this.createInputLine(this.inputLines_y + 15, HEAT_INPUT_COLOR);\n      this.loadImage(this.heatSvgString, 5, 5, image => {\n        this.ctx.drawImage(image, 35, this.inputLines_y + 5, 15, 15);\n        this.ctx.fillText('Heat', 10, this.inputLines_y + 15);\n      });\n    }\n    ngAfterViewInit() {}\n    drawRoundedRectangle(x, y, width, height, radius) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(x + radius, y);\n      this.ctx.lineTo(x + width - radius, y);\n      this.ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n      this.ctx.lineTo(x + width, y + height - radius);\n      this.ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n      this.ctx.lineTo(x + radius, y + height);\n      this.ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n      this.ctx.lineTo(x, y + radius);\n      this.ctx.quadraticCurveTo(x, y, x + radius, y);\n      this.ctx.closePath();\n      this.ctx.stroke();\n    }\n    initCanvas() {\n      this.canvasRef.nativeElement.width = 1100;\n      this.canvasRef.nativeElement.height = 200;\n      this.canvasWidth = this.canvasRef.nativeElement.width;\n      this.ctx = this.canvasRef.nativeElement.getContext('2d');\n      // this.adjustCanvasResolution();\n      let processArr = this.productionRoute.process;\n      this.nodeCount = processArr.length;\n      let no_of_rows = this.nodeCount / this.nodesPerRow;\n      if (this.nodeCount % this.nodesPerRow > 0) {\n        no_of_rows += 1;\n      }\n      this.total_rows = Math.floor(no_of_rows);\n      this.row_output_max = new Array(this.total_rows).fill(1);\n      processArr.forEach((process, index) => {\n        let row = Math.floor(index / this.nodesPerRow);\n        if (process.output.length > this.row_output_max[row]) {\n          this.row_output_max[row] = process.output.length;\n        }\n      });\n      {\n        /* block to adjust height of canvas according to need (based on number of outputs) */\n        /* sum of all max outputs from each row */\n        const total_max_outputs = this.row_output_max.reduce((accumulator, r_max) => {\n          return accumulator + r_max;\n        }, 0);\n        this.canvasRef.nativeElement.height += 200 * this.total_rows;\n        this.canvasRef.nativeElement.height += 25 * total_max_outputs;\n      }\n      this.createInstallationBoundary();\n      this.drawNonProductInputs();\n      // this.ctx.clearRect(0, 0, this.canvasRef.nativeElement.width, this.canvasRef.nativeElement.height);\n      this.initializeProcess();\n    }\n    // adjustCanvasResolution(): void {\n    //     const canvas = this.canvasRef.nativeElement;\n    //     const rect = canvas.getBoundingClientRect();\n    //     const scale = window.devicePixelRatio || 1;\n    //     const width = rect.width;\n    //     const height = rect.height;\n    //     // Increase the canvas resolution\n    //     canvas.width = width * scale;\n    //     canvas.height = height * scale;\n    //     // Scale the canvas back down to logical size\n    //     canvas.style.width = width + 'px';\n    //     canvas.style.height = height + 'px';\n    //     // Scale the context to match the increased resolution\n    //     this.ctx.scale(scale, scale);\n    // }\n    createInstallationBoundary() {\n      this.ctx.beginPath();\n      this.ctx.setLineDash([5, 5]); // Set the line dash pattern\n      this.drawRoundedRect(this.ctx, 70, 50, this.canvasRef.nativeElement.width - 140, this.canvasRef.nativeElement.height - 100, CURVE_RADIUS);\n      this.ctx.setLineDash([]);\n      this.drawTextVertically('Installation boundary', 65, this.canvasRef.nativeElement.height / 2);\n    }\n    drawTextVertically(text, x, y) {\n      this.ctx.save(); // Save the current drawing state\n      this.ctx.translate(x, y); // Move the origin to the desired position\n      this.ctx.rotate(-Math.PI / 2); // Rotate the canvas 90 degrees clockwise (in radians)\n      this.ctx.textAlign = \"center\"; // Set the text alignment to center\n      this.ctx.fillText(text, 0, 0); // Draw the text\n      this.ctx.restore(); // Restore the saved drawing state\n    }\n\n    createInputLine(yAxis, input_color) {\n      this.ctx.fillStyle = input_color;\n      this.ctx.strokeStyle = input_color;\n      this.ctx.beginPath();\n      this.ctx.arc(60, yAxis, 5, 0, 2 * Math.PI);\n      this.ctx.fill();\n      this.ctx.stroke();\n      this.ctx.beginPath();\n      this.ctx.moveTo(54, yAxis);\n      this.ctx.lineTo(this.canvasWidth, yAxis);\n      this.ctx.stroke();\n      this.ctx.fillStyle = DEFAULT_STROKE_COLOR;\n      this.ctx.strokeStyle = DEFAULT_STROKE_COLOR; // Change 'blue' to any color you desire\n    }\n\n    drawProcesses() {\n      this.nodes.forEach((process, index) => {\n        let row = Math.floor(index / this.nodesPerRow);\n        if (process.outputs.length > this.row_output_max[row]) {\n          this.row_output_max[row] = process.outputs.length;\n        }\n        function drawCenteredAndWrappedText(ctx, text, x, y, width, height, maxLength) {\n          ctx.save();\n          ctx.font = '12px Arial'; // Set font properties\n          ctx.textAlign = 'center'; // Center horizontally\n          ctx.textBaseline = 'middle'; // Center vertically\n          const centerX = x + width / 2;\n          const lineHeight = 20;\n          let lines = [text];\n          let startY = y + height / 2;\n          // Check if text length exceeds the maximum length\n          if (text.length > maxLength) {\n            const words = text.split(' ');\n            lines = [];\n            let currentLine = words[0];\n            // Create lines of text that fit within the specified width\n            for (let i = 1; i < words.length; i++) {\n              const testLine = currentLine + ' ' + words[i];\n              if (ctx.measureText(testLine).width > width) {\n                lines.push(currentLine);\n                currentLine = words[i];\n              } else {\n                currentLine = testLine;\n              }\n            }\n            lines.push(currentLine);\n            // Calculate the starting Y position to center the text block vertically\n            startY = y + (height - lines.length * lineHeight) / 2 + lineHeight / 2;\n          }\n          // Draw each line of text\n          lines.forEach((line, index) => {\n            ctx.fillText(line, centerX, startY + index * lineHeight);\n          });\n          ctx.restore();\n        }\n        this.ctx.strokeStyle = DEFAULT_STROKE_COLOR;\n        this.drawRoundedRect(this.ctx, process.x, process.y, process.width, process.height, CURVE_RADIUS);\n        drawCenteredAndWrappedText(this.ctx, process.name, process.x, process.y, process.width, process.height, 20);\n        // Draw external inputs\n        let input_length = process.externalInputs.length;\n        process.externalInputs.forEach(input => {\n          let input_y = input.y;\n          let input_line_color = DEFAULT_STROKE_COLOR;\n          let extendFromInputLine = false;\n          if (input.type == 'top') {\n            /* for inputs that are in 1st row and are of type either electricity or heat */\n            if (input['keyID'] == PROCESS_INPUT_ENUM.ELECTRICITY) {\n              input_line_color = ELECTRICITY_INPUT_COLOR;\n            } else {\n              input_line_color = HEAT_INPUT_COLOR;\n            }\n          }\n          if (index < this.nodesPerRow) {\n            extendFromInputLine = input.type == 'top';\n            if (extendFromInputLine) {\n              /* for inputs that are in 1st row and are of type either electricity or heat */\n              if (input['keyID'] == PROCESS_INPUT_ENUM.ELECTRICITY) {\n                input_y = this.inputLines_y - 5;\n              } else {\n                input_y = this.inputLines_y + 15;\n              }\n            }\n          }\n          this.drawExternalInput(extendFromInputLine, process.x, process.y, input.x, input_y, input.type, input.name, input_line_color, input_length, input['keyID']);\n        });\n        process.outputs.forEach((output, oIndex) => {\n          this.drawOutput(process.x, process.y, output.x, output.y, output.name, oIndex, process.outputs.length, index);\n        });\n      });\n    }\n    initializeProcess() {\n      this.nodes = [];\n      let processArr = this.productionRoute.process;\n      this.nodeCount = processArr.length;\n      this.canvasWidth = this.canvasRef.nativeElement.width;\n      const canvasHeight = this.canvasRef.nativeElement.height;\n      let prevOutput = [];\n      for (let i = 0; i < this.nodeCount; i++) {\n        let externalInputs = [];\n        let inputs = processArr[i]['input'];\n        let outputs = [];\n        const inputCount = inputs.length;\n        let left_count = 0;\n        for (let j = 0; j < inputCount; j++) {\n          const type = inputs[j]['type']['keyID'] == PROCESS_INPUT_ENUM.ELECTRICITY || inputs[j]['type']['keyID'] == PROCESS_INPUT_ENUM.HEAT ? 'top' : 'left';\n          if (type == 'left') {\n            /* change to type of inputs */\n            if (inputs[j].entities != null) {\n              inputs[j].entities.forEach(entity => {\n                if (!prevOutput.includes(entity.name)) {\n                  ++left_count;\n                  let managed_y = left_count * SPACE_BW_LEFT_INPUTS + (left_count < 4 ? 0 : SPACE_BW_LEFT_INPUTS + 5);\n                  externalInputs.push({\n                    x: -20,\n                    y: managed_y,\n                    type: type,\n                    name: entity['name'],\n                    keyID: entity['keyID']\n                  });\n                }\n              });\n            }\n          } else {\n            let x = this.nodeWidth / this.nodesPerRow;\n            /* TODO check this condition */\n            if (inputs[j]['type']['keyID'] == PROCESS_INPUT_ENUM.ELECTRICITY) x = this.nodeWidth / this.nodesPerRow * 2;\n            externalInputs.push({\n              x: x,\n              y: -20,\n              type: type,\n              name: inputs[j]['type']['name'],\n              keyID: inputs[j]['type']['keyID']\n            });\n          }\n        }\n        prevOutput = [];\n        let outputsx = processArr[i]['output'];\n        const outputCount = outputsx.length;\n        let count = 0; /* number of outputs exported from process */\n        this.multi_connections[i] = [];\n        for (let k = 0; k < outputCount; k++) {\n          let space = count;\n          const {\n            keyID,\n            name\n          } = outputsx[k]['type'];\n          switch (keyID) {\n            case PROCESS_OUTPUT_ENUM.PRECURSOR_PRODUCT:\n            case PROCESS_OUTPUT_ENUM.INTERMEDIATE_PRODUCT:\n            case PROCESS_OUTPUT_ENUM.CO_PRODUCT:\n            case PROCESS_OUTPUT_ENUM.FINISHED_PRODUCT:\n            case PROCESS_OUTPUT_ENUM.BY_PRODUCT_AND_WASTE:\n              outputsx[k]['entities'].forEach((entity, j) => {\n                if (this.isExported(keyID, outputsx[k]['entitySource'], entity.id)) {\n                  ++count;\n                  outputs.push({\n                    x: -20,\n                    y: (space + j + 1) * HORIZONTAL_SPACE_BW_OUTPUTS,\n                    name: entity.name,\n                    keyID: entity.keyID\n                  });\n                }\n                if (this.isUsedInProductionRoute(keyID, outputsx[k]['entitySource'], entity.id)) {\n                  if (keyID == PROCESS_OUTPUT_ENUM.INTERMEDIATE_PRODUCT || keyID == PROCESS_OUTPUT_ENUM.PRECURSOR_PRODUCT || keyID == PROCESS_OUTPUT_ENUM.FINISHED_PRODUCT) {\n                    prevOutput.push(entity.name);\n                    this.multi_connections[i].push({\n                      from: i,\n                      to: i + 1,\n                      name: entity.name\n                    });\n                  }\n                }\n              });\n              break;\n            case PROCESS_OUTPUT_ENUM.ELECTRICITY:\n            case PROCESS_OUTPUT_ENUM.HEAT:\n            case PROCESS_OUTPUT_ENUM.WASTE_GAS_STREAM:\n              if (this.isExported(keyID, outputsx[k]['entitySource'])) {\n                ++count;\n                outputs.push({\n                  x: -20,\n                  y: (space + 1) * HORIZONTAL_SPACE_BW_OUTPUTS,\n                  name: name,\n                  keyID: keyID\n                });\n              } else {\n                this.multi_connections[i].push({\n                  from: i,\n                  to: i + 1,\n                  name: name\n                });\n              }\n              break;\n          }\n        }\n        const row = Math.floor(i / this.nodesPerRow);\n        const column = i % this.nodesPerRow;\n        if (count > this.row_output_max[row]) {\n          this.row_output_max[row] = outputsx.length;\n        }\n        let x = (this.canvasWidth - (this.nodeWidth + 100) * this.nodesPerRow + 100) / 2 + column * (this.nodeWidth + 100);\n        if (this.nodeCount == 1) {\n          x = this.canvasWidth / 2 - this.nodeWidth / 2;\n        } else if (this.nodeCount == 2) {\n          x = (this.canvasWidth - (this.nodeWidth + 100) * (this.nodesPerRow - 1) + 100) / 2 + column * (this.nodeWidth + 100);\n        }\n        // let y = (canvasHeight - (this.nodeHeight + 100) * Math.ceil(this.nodeCount / this.nodesPerRow) + 100) / 2 + row * (this.nodeHeight + 100);\n        let y = 150;\n        if (row > 0) {\n          y += (this.nodeHeight + 100) * row;\n          let totalSpace = 0;\n          totalSpace = this.row_output_max.slice(0, row).reduce((accumulator, currentValue) => accumulator + currentValue, 0);\n          y += totalSpace * 25;\n        }\n        this.nodes.push({\n          x,\n          y,\n          width: this.nodeWidth,\n          height: this.nodeHeight,\n          name: processArr[i]['name'],\n          externalInputs,\n          outputs\n        });\n      }\n      // Draw nodes and connections\n      this.drawProcesses();\n      this.drawConnections();\n    }\n    clear() {\n      this.ctx.clearRect(0, 0, this.canvasRef.nativeElement.width, this.canvasRef.nativeElement.height);\n    }\n    drawOutput(nodeX, nodeY, outputX, outputY, name, index, outputCount, rowIndex) {\n      this.ctx.strokeStyle = PROCESS_OUTPUT_COLOR;\n      // const startX = nodeX + outputX ;\n      const startX = nodeX;\n      const startY = nodeY + outputY + 125; // Move starting point to the bottom border of the node\n      // Move downwards by the vertical offset\n      // const bendY = startY + verticalOffset;\n      const bendY = startY;\n      // Calculate the horizontal offset between output lines\n      const horizontalOffset = this.nodeWidth / (outputCount + 1); // Adjust this value as needed for the spacing between output lines\n      const bendX = startX - (index + 1) * horizontalOffset; // Move left by the length of the output line\n      const endX = bendX; // Move left from the bend point\n      const endY = bendY;\n      const outputJoin = startX + (index + 1) * horizontalOffset;\n      function drawCurvyOutput(ctx, outputJoin, nodeY, bendY, startX, radius) {\n        ctx.beginPath();\n        // Move to the starting point\n        ctx.moveTo(outputJoin, nodeY + 100);\n        // Draw a straight line down first\n        ctx.lineTo(outputJoin, bendY - 20 - radius);\n        ctx.quadraticCurveTo(outputJoin, bendY - 20, outputJoin - radius, bendY - 20);\n        // Draw a horizontal line to the left with a curve\n        ctx.lineTo(startX + radius, bendY - 20);\n        ctx.quadraticCurveTo(startX, bendY - 20, startX, bendY - 20);\n        ctx.stroke();\n      }\n      // Draw line\n      drawCurvyOutput(this.ctx, outputJoin, nodeY, bendY, startX, CURVE_RADIUS);\n      // Draw arrow at the end point (left line of the output)\n      this.drawArrowhead(startX, bendY - 20, startX - 10, endY - 20); // Arrow points to the left\n      // Draw output name\n      this.ctx.fillText(name, startX + 10, bendY - 10);\n      this.ctx.strokeStyle = PROCESS_OUTPUT_COLOR; // Change 'blue' to any color you desire\n    }\n\n    drawExternalInput(extendFromInputLine, nodeX, nodeY, inputX, inputY, type, name, color, totalInputs, key_id) {\n      this.ctx.save();\n      this.ctx.font = '12px Arial'; // Set font properties\n      // this.ctx.textAlign = 'center'; // Center horizontally\n      // this.ctx.textBaseline = 'middle'; // Center vertically\n      const x = nodeX + inputX;\n      let y = nodeY + inputY;\n      if (extendFromInputLine) {\n        y = inputY;\n      }\n      // Draw line connecting arrow to node\n      this.ctx.beginPath();\n      if (type === 'left') {\n        this.ctx.strokeStyle = PRODUCT_INPUT_COLOR;\n        this.ctx.moveTo(nodeX, y);\n        this.ctx.lineTo(x - 60, y);\n        // this.ctx.fillText(name, nodeX - 100, y - 3, 130);\n        this.writeTextWithEllipsis(this.ctx, name, nodeX - 80, y - 3, 12);\n      } else {\n        this.ctx.strokeStyle = color;\n        if (type == 'top' && !extendFromInputLine) y = y - 20;\n        this.ctx.moveTo(x, nodeY);\n        this.ctx.lineTo(x, y);\n        let icon = this.electricitySvgString;\n        if (key_id == PROCESS_INPUT_ENUM.HEAT) {\n          icon = this.heatSvgString;\n        }\n        this.loadImage(icon, x, nodeY, image => {\n          this.ctx.save();\n          this.ctx.beginPath();\n          this.ctx.arc(x, y + 2, CURVE_RADIUS - 8, 0, 2 * Math.PI);\n          this.ctx.fillStyle = 'white';\n          this.ctx.fill();\n          this.ctx.stroke();\n          this.ctx.restore();\n          this.ctx.drawImage(image, x - 6, y - 5, 12, 12);\n        });\n        // this.ctx.fillText(name, x - 45, nodeY - 30);\n        // this.drawTextWithEllipsis(this.ctx, name, x - 30, nodeY - 30, 12 /* max_length */);\n      }\n\n      this.ctx.stroke();\n      // Draw arrow\n      this.ctx.beginPath();\n      if (type === 'left') {\n        this.ctx.moveTo(nodeX - 10, y - 5);\n        this.ctx.lineTo(nodeX, y);\n        this.ctx.lineTo(nodeX - 10, y + 5);\n      } else {\n        this.ctx.moveTo(x - 5, nodeY - 10);\n        this.ctx.lineTo(x, nodeY);\n        this.ctx.lineTo(x + 5, nodeY - 10);\n      }\n      this.ctx.stroke();\n      this.ctx.strokeStyle = DEFAULT_STROKE_COLOR;\n      this.ctx.restore();\n    }\n    drawConnections() {\n      const number_of_nodes = this.nodes.length;\n      this.multi_connections.forEach((connections, node_i) => {\n        let count = 0;\n        connections.forEach((connection, index) => {\n          if (connection !== null) {\n            let row = Math.floor(index / this.nodesPerRow);\n            const row_space = this.row_output_max[row] * 25 + 75;\n            const fromNode = this.nodes[connection.from];\n            let startX, startY, endX, endY;\n            if (connection.to != number_of_nodes) {\n              const toNode = this.nodes[connection.to];\n              startX = fromNode.x + fromNode.width; // Right middle X\n              startY = fromNode.y + fromNode.height / 2 + count * SPACE_BW_LEFT_INPUTS; // Right middle Y\n              endX = toNode.x; // Left edge X\n              endY = toNode.y + toNode.height / 2 + count * SPACE_BW_LEFT_INPUTS; // Middle Y\n            } else {\n              startX = fromNode.x + fromNode.width; // Right middle X\n              startY = fromNode.y + fromNode.height / 2 + count * SPACE_BW_LEFT_INPUTS; // Right middle Y\n              endX = startX + 100; // Left edge X\n              if (connection.to == number_of_nodes) {\n                endX -= 50;\n              }\n              endY = fromNode.y + fromNode.height / 2 + count * SPACE_BW_LEFT_INPUTS; // Middle Y\n            }\n            // Draw line\n            this.ctx.strokeStyle = PROCESS_CONNECTION_COLOR;\n            function drawCurvyConnection(ctx, startX, startY, endX, endY, row_space, radius) {\n              ctx.beginPath();\n              // Move to the starting point\n              ctx.moveTo(startX, startY);\n              // Horizontal line to the right with a curve to the vertical line down\n              ctx.lineTo(startX + 20 - radius, startY);\n              ctx.quadraticCurveTo(startX + 20, startY, startX + 20, startY + radius);\n              // Vertical line down with a curve to the horizontal line right\n              ctx.lineTo(startX + 20, startY + row_space - radius);\n              ctx.quadraticCurveTo(startX + 20, startY + row_space, startX + 20 - radius, startY + row_space);\n              // Horizontal line to the right with a curve to the vertical line down\n              ctx.lineTo(endX - 20 + radius, startY + row_space);\n              ctx.quadraticCurveTo(endX - 20, startY + row_space, endX - 20, startY + row_space + radius);\n              // Vertical line down with a curve to the horizontal line right\n              ctx.lineTo(endX - 20, endY - radius);\n              ctx.quadraticCurveTo(endX - 20, endY, endX - 20 + radius, endY);\n              // Final horizontal line to the end point\n              ctx.lineTo(endX, endY);\n              ctx.stroke();\n            }\n            this.ctx.beginPath();\n            if (node_i != 0 && node_i % this.nodesPerRow == 2 && node_i != number_of_nodes - 1) {\n              drawCurvyConnection(this.ctx, startX, startY, endX, endY, row_space, CURVE_RADIUS);\n            } else {\n              this.ctx.moveTo(startX, startY);\n              this.ctx.lineTo(endX, endY);\n            }\n            this.ctx.stroke();\n            // Calculate midpoint\n            const midX = (startX + endX) / 2;\n            const midY = (startY + endY) / 2;\n            if (node_i % 2 == 0 && node_i % this.nodesPerRow == 2) {\n              this.drawArrowhead(endX - 20, endY, endX, endY);\n              this.writeTextWithEllipsis(this.ctx, connection.name, midX - 20, midY + 48, 12);\n            } else {\n              this.drawArrowhead(startX, startY, endX, endY);\n              this.writeTextWithEllipsis(this.ctx, connection.name, midX - 25, midY + 10, 12);\n            }\n            this.ctx.strokeStyle = DEFAULT_STROKE_COLOR;\n            ++count;\n          }\n        });\n      });\n    }\n    drawArrowhead(startX, startY, endX, endY) {\n      const dx = endX - startX;\n      const dy = endY - startY;\n      const angle = Math.atan2(dy, dx);\n      this.ctx.beginPath();\n      this.ctx.moveTo(endX, endY);\n      this.ctx.lineTo(endX - 10 * Math.cos(angle - Math.PI / 6), endY - 10 * Math.sin(angle - Math.PI / 6));\n      this.ctx.lineTo(endX - 10 * Math.cos(angle + Math.PI / 6), endY - 10 * Math.sin(angle + Math.PI / 6));\n      this.ctx.closePath();\n      this.ctx.stroke();\n    }\n    writeTextWithEllipsis(ctx, text, x, y, maxLength) {\n      const ellipsis = '...';\n      let displayText = text;\n      if (text.length > maxLength) {\n        displayText = text.substring(0, maxLength - ellipsis.length) + ellipsis;\n        ctx.canvas.title = text; // Set the full text as the tooltip\n      }\n\n      ctx.fillText(displayText, x, y);\n    }\n  }\n  ProcessMapComponent.ɵfac = function ProcessMapComponent_Factory(t) {\n    return new (t || ProcessMapComponent)(i0.ɵɵdirectiveInject(i1.ActivatedRoute), i0.ɵɵdirectiveInject(i2.StorageService), i0.ɵɵdirectiveInject(i3.ProductionRouteController));\n  };\n  ProcessMapComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: ProcessMapComponent,\n    selectors: [[\"production-route\"]],\n    viewQuery: function ProcessMapComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.canvasRef = _t.first);\n      }\n    },\n    inputs: {\n      refresh: \"refresh\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 8,\n    vars: 1,\n    consts: [[1, \"headerContainer\"], [1, \"headerLeftContainer\"], [1, \"headerRightContainerInner\"], [1, \"cardTitle\"], [1, \"ps-5\"], [\"myCanvas\", \"\"]],\n    template: function ProcessMapComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵelementStart(1, \"div\", 1);\n        i0.ɵɵelementStart(2, \"div\", 2);\n        i0.ɵɵelementStart(3, \"div\", 3);\n        i0.ɵɵelementStart(4, \"span\", 4);\n        i0.ɵɵtext(5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(6, \"canvas\", null, 5);\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(5);\n        i0.ɵɵtextInterpolate1(\" \", ctx.productionRoute == null ? null : ctx.productionRoute.name, \" \");\n      }\n    },\n    styles: [\"\"]\n  });\n  return ProcessMapComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}