import { __awaiter } from "tslib";
import { Component, ViewChild } from '@angular/core';
import { FormControl, Validators } from '@angular/forms';
import * as moment from 'moment-timezone';
import { merge, fromEvent, of as observableOf } from 'rxjs';
import { map, startWith, switchMap, catchError, filter } from "rxjs/operators";
import { AlertPageLabelEnum, AlertStatusEnum, AlertStatusLabelEnum, AlertTypeEnum } from '../../../../enum/alert.enum';
import { COMMON_CONSTANT, MaterialFormFieldAppearance, StatusEnum, TABLE_CONSTANT } from '@library/tsc-common';
import * as i0 from "@angular/core";
import * as i1 from "@library/date";
import * as i2 from "@library/storage-service";
import * as i3 from "@library/organization-service";
import * as i4 from "../../../../controller/alert.controller";
import * as i5 from "@angular/material/form-field";
import * as i6 from "@angular/material/datepicker";
import * as i7 from "@angular/material/button-toggle";
import * as i8 from "@library/tsc-common";
import * as i9 from "@angular/material/table";
import * as i10 from "@angular/material/sort";
import * as i11 from "@angular/material/paginator";
import * as i12 from "@angular/material/input";
import * as i13 from "@angular/forms";
import * as i14 from "@angular/material/tooltip";
import * as i15 from "@angular/common";
// /tsc-library/
export class GeneratedAlarmPageComponent {
    constructor(dateService, storageService, organizationService, alertController) {
        this.dateService = dateService;
        this.storageService = storageService;
        this.organizationService = organizationService;
        this.alertController = alertController;
        this.TABLE_CONSTANT = TABLE_CONSTANT;
        this.COMMON_CONSTANT = COMMON_CONSTANT;
        this.StatusEnum = StatusEnum;
        this.AlertStatusEnum = AlertStatusEnum;
        this.AlertTypeEnum = AlertTypeEnum;
        this.AlertPageLabelEnum = AlertPageLabelEnum;
        this.AlertStatusLabelEnum = AlertStatusLabelEnum;
        this.MaterialFormFieldAppearance = MaterialFormFieldAppearance;
        this.displayedColumn = ['id', 'alertName', 'parameterLabel', 'associatedWith', 'description', 'time', 'type', 'status'];
        this.resultLength = 0;
        this.dataSource = [];
        this.searchFlag = false;
        this.searchArr = [];
        this.timeZone = null;
        this.today = new Date();
        this.selectedMonthFC = new FormControl(moment().format('YYYY-MM'));
        this.startDateFC = new FormControl();
        this.endDateFC = new FormControl();
        this.statusFC = new FormControl(AlertStatusEnum.ACTIVE, Validators.required);
    }
    ngOnInit() {
        this.orgID = this.storageService.getStorage('currentOrgID');
        this.getTimezone();
    }
    getTimezone() {
        return __awaiter(this, void 0, void 0, function* () {
            this.timeZone = (yield this.organizationService.getOrgTimezone());
            this.startDateFC.patchValue(moment().startOf('month').tz(this.timeZone).format());
            this.endDateFC.patchValue(moment().add(1, 'months').startOf('month').tz(this.timeZone).format());
            if (this.statusFC.value == AlertStatusEnum.ACTIVE) {
                this.getActiveAlertByPage();
            }
            else {
                this.getResolvedAlertByPage();
            }
        });
    }
    monthSelectedHandler(normalizedMonth, datepicker) {
        let duration = this.dateService.monthSelectedHandler(normalizedMonth, datepicker);
        this.selectedMonthFC.setValue(duration);
        this.startDateFC.patchValue(moment(normalizedMonth).startOf('month').tz(this.timeZone).format());
        this.endDateFC.patchValue(moment(normalizedMonth).add(1, 'months').startOf('month').tz(this.timeZone).format());
        if (this.statusFC.value == AlertStatusEnum.ACTIVE) {
            this.getActiveAlertByPage();
        }
        else {
            this.getResolvedAlertByPage();
        }
    }
    getActiveAlertByPage() {
        merge(this.paginator.page, this.sort.sortChange, fromEvent(this.refreshBtn.nativeElement, 'click')).pipe(startWith({}), filter(() => this.statusFC.value == AlertStatusEnum.ACTIVE), switchMap(() => {
            let requestBody = {};
            if (this.searchFlag) {
                requestBody['search'] = this.searchValue;
            }
            requestBody['pageNo'] = this.paginator.pageIndex;
            requestBody['pageSize'] = this.paginator.pageSize;
            requestBody['sortBy'] = this.sort.active;
            requestBody['orderBy'] = this.sort.direction;
            requestBody['startDate'] = this.startDateFC.value;
            requestBody['endDate'] = this.endDateFC.value;
            return this.alertController.getActiveAlertByPage(this.orgID, requestBody).pipe(catchError(() => observableOf(null)));
        }), map((response) => {
            if (response == null) {
                this.resultLength = 0;
                return [];
            }
            this.resultLength = response["totalCount"];
            return response["records"];
        })).subscribe((dataSource) => {
            this.dataSource = dataSource;
        });
    }
    getResolvedAlertByPage() {
        merge(this.paginator.page, this.sort.sortChange, fromEvent(this.refreshBtn.nativeElement, 'click')).pipe(startWith({}), filter(() => this.statusFC.value == AlertStatusEnum.RESOLVED), switchMap(() => {
            let requestBody = {};
            if (this.searchFlag) {
                requestBody['search'] = this.searchValue;
            }
            requestBody['pageNo'] = this.paginator.pageIndex;
            requestBody['pageSize'] = this.paginator.pageSize;
            requestBody['sortBy'] = this.sort.active;
            requestBody['orderBy'] = this.sort.direction;
            requestBody['startDate'] = this.startDateFC.value;
            requestBody['endDate'] = this.endDateFC.value;
            return this.alertController.getResolvedAlertByPage(this.orgID, requestBody).pipe(catchError(() => observableOf(null)));
        }), map((response) => {
            if (response == null) {
                this.resultLength = 0;
                return [];
            }
            this.resultLength = response["totalCount"];
            return response["records"];
        })).subscribe((dataSource) => {
            this.dataSource = dataSource;
        });
    }
    statusChange() {
        let alertStatus;
        switch (this.statusFC.value) {
            case AlertStatusEnum.ACTIVE:
                alertStatus = AlertStatusEnum.ACTIVE;
                this.getActiveAlertByPage();
                break;
            case AlertStatusEnum.RESOLVED:
                alertStatus = AlertStatusEnum.RESOLVED;
                this.getResolvedAlertByPage();
                break;
            default:
                console.log("undefined case encountered!");
        }
        this.statusFC.patchValue(alertStatus);
    }
    searchFn(value) {
        this.searchFlag = true;
        this.searchValue = value;
        if (value.length == 0) {
            this.resetSearch();
        }
        else {
            this.paginator.pageIndex = 0;
        }
        this.refreshBtn.nativeElement.click();
    }
    resetSearch() {
        this.searchFlag = false;
        this.searchBar.searchClear();
    }
    getTimeLabel(dateTime) {
        return dateTime ? moment.tz(dateTime, this.timeZone).fromNow() : COMMON_CONSTANT.HYPHEN;
    }
}
GeneratedAlarmPageComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: GeneratedAlarmPageComponent, deps: [{ token: i1.DateService }, { token: i2.StorageService }, { token: i3.OrganizationService }, { token: i4.AlertRuleController }], target: i0.ɵɵFactoryTarget.Component });
GeneratedAlarmPageComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: GeneratedAlarmPageComponent, selector: "lib-page", viewQueries: [{ propertyName: "sort", first: true, predicate: ["sort"], descendants: true }, { propertyName: "paginator", first: true, predicate: ["paginator"], descendants: true }, { propertyName: "refreshBtn", first: true, predicate: ["refreshBtn"], descendants: true }, { propertyName: "searchBar", first: true, predicate: ["searchBar"], descendants: true }], ngImport: i0, template: "<div class=\"card main-card cardOverwrite h100\">\n    <div class=\"headerContainer\">\n        <div class=\"headerLeftContainer\">\n            <div class=\"pageTitle\">Generated Alarms</div>\n        </div>\n    </div>\n\n    <button #refreshBtn class=\"d-none\"></button>\n\n    <div class=\"card-body\">\n        <div class=\"row\">\n            <div class=\"col-sm-2\">\n                <mat-form-field id=\"monthlyField\" appMonthYearFormat (click)=\"dateService.openDatepickerOnClick(monthly)\"\n                    (keydown.arrowdown)=\"dateService.openDatepickerOnClick(monthly)\"\n                    (keydown.enter)=\"dateService.openDatepickerOnClick(monthly)\" class=\"matFieldWidth100 cursorPointer\"\n                    [appearance]=\"MaterialFormFieldAppearance.FORM_FIELD_APPEARANCE\">\n                    <mat-label class=\"formLabel\">Select month</mat-label>\n                    <input matInput class=\"noFocus\" [matDatepicker]=\"monthly\" [formControl]=\"selectedMonthFC\" [max]=\"today\" readonly />\n                    <mat-datepicker-toggle matSuffix class=\"fs-5\" [for]=\"monthly\"></mat-datepicker-toggle>\n                    <mat-datepicker panelClass=\"monthPicker\" #monthly startView=\"year\"\n                        (monthSelected)=\"monthSelectedHandler($event, monthly)\" (closed)=\"dateService.takeFocusAway('monthlyField')\">\n                    </mat-datepicker>\n                </mat-form-field>\n            </div>\n            <div class=\"col-sm-10\">\n                <div class=\"float-end me-1 mt-2\">\n                    <mat-button-toggle-group class=\"matBtnFilter\" [formControl]=\"statusFC\" (change)=\"statusChange()\">\n                        <mat-button-toggle value=\"{{ AlertStatusEnum.ACTIVE }}\">\n                            {{ AlertStatusLabelEnum.ACTIVE_LABEL }}\n                        </mat-button-toggle>\n                        <mat-button-toggle value=\"{{ AlertStatusEnum.RESOLVED }}\">\n                            {{ AlertStatusLabelEnum.RESOLVED_LABEL }}\n                        </mat-button-toggle>\n                    </mat-button-toggle-group>\n                </div>\n            </div>\n        </div>\n\n        <div class=\"row\">\n            <div class=\"col-sm-12\">\n                <lib-search-bar-one class=\"me-1 float-end\" #searchBar searchBy=\"parameter name\" (emitSearch)=\"searchFn($event)\">\n                </lib-search-bar-one>\n            </div>\n        </div>\n\n        <div class=\"overflowX customScrollBar\">\n            <table class=\"w-100\" mat-table [dataSource]=\"dataSource\" #sort=\"matSort\" matSort matSortActive=\"id\"\n                matSortDirection=\"asc\" matSortDisableClear>\n\n                <ng-container matColumnDef=\"id\">\n                    <th class=\"px-3 columnWidth1\" mat-header-cell *matHeaderCellDef mat-sort-header disableClear>\n                        ID\n                    </th>\n                    <td class=\"px-3 columnWidth1\" mat-cell *matCellDef=\"let row\">\n                        {{ row.id ? row.id: COMMON_CONSTANT.HYPHEN }}\n                    </td>\n                </ng-container>\n\n                <ng-container matColumnDef=\"alertName\">\n                    <th class=\"px-3 columnWidth4\" mat-header-cell *matHeaderCellDef> Name </th>\n                    <td class=\"px-3 columnWidth4\" mat-cell *matCellDef=\"let row\"\n                        [matTooltip]=\"row?.['alertName']?.length>15? row['alertName']: ''\" matTooltipPosition=\"above\"\n                        matTooltipClass=\"nameTooltip\">\n                        {{ (row.alertName ? row.alertName: COMMON_CONSTANT.HYPHEN) | dotdotdot:15}}\n                    </td>\n                </ng-container>\n\n                <ng-container matColumnDef=\"parameterLabel\">\n                    <th class=\"px-3 columnWidth4\" mat-header-cell *matHeaderCellDef>\n                        Parameter name\n                    </th>\n                    <td class=\"px-3 columnWidth4\" mat-cell *matCellDef=\"let row\">\n                        {{ row.parameterLabel ? row.parameterLabel: COMMON_CONSTANT.HYPHEN }}\n                    </td>\n                </ng-container>\n\n                <ng-container matColumnDef=\"associatedWith\">\n                    <th class=\"px-3 columnWidth3\" mat-header-cell *matHeaderCellDef> Associated with </th>\n                    <td class=\"px-3 columnWidth3\" mat-cell *matCellDef=\"let row\"\n                        [matTooltip]=\"row?.['associatedWith']?.length>30? row['associatedWith']: ''\"\n                        matTooltipPosition=\"above\" matTooltipClass=\"nameTooltip\">\n                        {{ (row.associatedWith ? row.associatedWith: COMMON_CONSTANT.HYPHEN) | dotdotdot:30}}\n                    </td>\n                </ng-container>\n\n                <ng-container matColumnDef=\"description\">\n                    <th class=\"px-3 columnWidth3\" mat-header-cell *matHeaderCellDef> Rule </th>\n                    <td class=\"px-3 columnWidth3\" mat-cell *matCellDef=\"let row\"\n                        [matTooltip]=\"row?.['description']?.length>30? row['description']: ''\"\n                        matTooltipPosition=\"above\" matTooltipClass=\"nameTooltip\">\n                        {{ (row.description ? row.description: COMMON_CONSTANT.HYPHEN) | dotdotdot:30}}\n                    </td>\n                </ng-container>\n\n                <ng-container matColumnDef=\"time\">\n                    <th class=\"px-3 columnWidth1\" mat-header-cell *matHeaderCellDef>\n                        Time\n                    </th>\n                    <td class=\"px-3 columnWidth1\" mat-cell *matCellDef=\"let row\">\n                        {{ getTimeLabel(row.time) }}\n                    </td>\n                </ng-container>\n\n                <ng-container matColumnDef=\"type\">\n                    <th class=\"px-3 columnWidth1\" mat-header-cell *matHeaderCellDef> Type </th>\n                    <td class=\"px-3 columnWidth1\" mat-cell *matCellDef=\"let row\">\n                        <span class=\"badge rounded-pill bg-light text-dark\" [ngSwitch]=\"row?.type\">\n                            <ng-container *ngSwitchCase=\"AlertTypeEnum.INSTANTANEOUS\">{{\n                                AlertPageLabelEnum.INSTANTANEOUS_LABEL\n                                }}</ng-container>\n                            <ng-container *ngSwitchCase=\"AlertTypeEnum.PERIODIC\">{{ AlertPageLabelEnum.PERIODIC_LABEL\n                                }}</ng-container>\n                        </span>\n                    </td>\n                </ng-container>\n\n                <ng-container matColumnDef=\"status\">\n                    <th class=\"px-3 columnWidth1\" mat-header-cell *matHeaderCellDef> Status </th>\n                    <td class=\"px-3 columnWidth1\" mat-cell *matCellDef=\"let row\">\n                        <span class=\"badge rounded-pill\"\n                            [ngClass]=\"{'bg-success': row?.status, 'bg-danger': !row?.status}\">\n                            {{ row?.status ? StatusEnum.ACTIVE_STATUS : StatusEnum.INACTIVE_STATUS }}\n                        </span>\n                    </td>\n                </ng-container>\n\n                <tr mat-header-row *matHeaderRowDef=\"displayedColumn\"></tr>\n                <tr mat-row *matRowDef=\"let task; columns: displayedColumn;\"></tr>\n\n                <tr class=\"mat-row\" *matNoDataRow>\n                    <td class=\"mat-cell text-center\" [attr.colspan]=\"displayedColumn.length\">\n                        {{ TABLE_CONSTANT.TABLE_NO_DATA }}\n                    </td>\n                </tr>\n            </table>\n        </div>\n\n        <mat-paginator #paginator class=\"roundedBorder\" showFirstLastButtons [length]=\"resultLength\"\n            [pageSize]=\"TABLE_CONSTANT.DEFAULT_PAGE_SIZE\" [pageSizeOptions]=\"TABLE_CONSTANT.PAGE_SIZE_OPTION\">\n        </mat-paginator>\n    </div>\n\n</div>", styles: [".columnWidth1{min-width:120px}.columnWidth2{min-width:250px}.columnWidth3{min-width:300px}.columnWidth4{min-width:150px}.matBtnFilter mat-button-toggle{width:80px}.badge{text-transform:none}\n"], components: [{ type: i5.MatFormField, selector: "mat-form-field", inputs: ["color", "floatLabel", "appearance", "hideRequiredMarker", "hintLabel"], exportAs: ["matFormField"] }, { type: i6.MatDatepickerToggle, selector: "mat-datepicker-toggle", inputs: ["tabIndex", "disabled", "for", "aria-label", "disableRipple"], exportAs: ["matDatepickerToggle"] }, { type: i6.MatDatepicker, selector: "mat-datepicker", exportAs: ["matDatepicker"] }, { type: i7.MatButtonToggle, selector: "mat-button-toggle", inputs: ["disableRipple", "aria-labelledby", "tabIndex", "appearance", "checked", "disabled", "id", "name", "aria-label", "value"], outputs: ["change"], exportAs: ["matButtonToggle"] }, { type: i8.SearchBarOneComponent, selector: "lib-search-bar-one", inputs: ["type", "searchBy", "clear"], outputs: ["emitSearch"] }, { type: i9.MatTable, selector: "mat-table, table[mat-table]", exportAs: ["matTable"] }, { type: i10.MatSortHeader, selector: "[mat-sort-header]", inputs: ["disabled", "arrowPosition", "sortActionDescription", "disableClear", "mat-sort-header", "start"], exportAs: ["matSortHeader"] }, { type: i9.MatHeaderRow, selector: "mat-header-row, tr[mat-header-row]", exportAs: ["matHeaderRow"] }, { type: i9.MatRow, selector: "mat-row, tr[mat-row]", exportAs: ["matRow"] }, { type: i11.MatPaginator, selector: "mat-paginator", inputs: ["disabled"], exportAs: ["matPaginator"] }], directives: [{ type: i1.MonthYearFormatDirective, selector: "[appMonthYearFormat]" }, { type: i5.MatLabel, selector: "mat-label" }, { type: i12.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["id", "disabled", "required", "type", "value", "readonly", "placeholder", "errorStateMatcher", "aria-describedby"], exportAs: ["matInput"] }, { type: i6.MatDatepickerInput, selector: "input[matDatepicker]", inputs: ["matDatepicker", "min", "max", "matDatepickerFilter"], exportAs: ["matDatepickerInput"] }, { type: i13.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i13.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i13.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { type: i5.MatSuffix, selector: "[matSuffix]" }, { type: i7.MatButtonToggleGroup, selector: "mat-button-toggle-group", inputs: ["appearance", "name", "vertical", "value", "multiple", "disabled"], outputs: ["valueChange", "change"], exportAs: ["matButtonToggleGroup"] }, { type: i10.MatSort, selector: "[matSort]", inputs: ["matSortDisabled", "matSortStart", "matSortDirection", "matSortDisableClear", "matSortActive"], outputs: ["matSortChange"], exportAs: ["matSort"] }, { type: i9.MatColumnDef, selector: "[matColumnDef]", inputs: ["sticky", "matColumnDef"] }, { type: i9.MatHeaderCellDef, selector: "[matHeaderCellDef]" }, { type: i9.MatHeaderCell, selector: "mat-header-cell, th[mat-header-cell]" }, { type: i9.MatCellDef, selector: "[matCellDef]" }, { type: i9.MatCell, selector: "mat-cell, td[mat-cell]" }, { type: i14.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { type: i15.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { type: i15.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { type: i15.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i9.MatHeaderRowDef, selector: "[matHeaderRowDef]", inputs: ["matHeaderRowDef", "matHeaderRowDefSticky"] }, { type: i9.MatRowDef, selector: "[matRowDef]", inputs: ["matRowDefColumns", "matRowDefWhen"] }, { type: i9.MatNoDataRow, selector: "ng-template[matNoDataRow]" }], pipes: { "dotdotdot": i8.EllipsisPipeService } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: GeneratedAlarmPageComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'lib-page',
                    templateUrl: './page.component.html',
                    styleUrls: ['./page.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i1.DateService }, { type: i2.StorageService }, { type: i3.OrganizationService }, { type: i4.AlertRuleController }]; }, propDecorators: { sort: [{
                type: ViewChild,
                args: ['sort']
            }], paginator: [{
                type: ViewChild,
                args: ['paginator']
            }], refreshBtn: [{
                type: ViewChild,
                args: ['refreshBtn']
            }], searchBar: [{
                type: ViewChild,
                args: ['searchBar']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFnZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9saWJyYXJ5L2FsZXJ0cy9zcmMvbGliL3RzYy9jb21wb25lbnQvYWxhcm0vZ2VuZXJhdGVkL3BhZ2UvcGFnZS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9saWJyYXJ5L2FsZXJ0cy9zcmMvbGliL3RzYy9jb21wb25lbnQvYWxhcm0vZ2VuZXJhdGVkL3BhZ2UvcGFnZS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBc0IsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3pFLE9BQU8sRUFBRSxXQUFXLEVBQUUsVUFBVSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFPekQsT0FBTyxLQUFLLE1BQU0sTUFBTSxpQkFBaUIsQ0FBQztBQUUxQyxPQUFPLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxFQUFFLElBQUksWUFBWSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzVELE9BQU8sRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFL0UsT0FBTyxFQUFFLGtCQUFrQixFQUFFLGVBQWUsRUFBRSxvQkFBb0IsRUFBRSxhQUFhLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQU92SCxPQUFPLEVBQUUsZUFBZSxFQUFFLDJCQUEyQixFQUFnQyxVQUFVLEVBQUUsY0FBYyxFQUFFLE1BQU0scUJBQXFCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRzdJLGdCQUFnQjtBQVFoQixNQUFNLE9BQU8sMkJBQTJCO0lBb0NwQyxZQUNXLFdBQXdCLEVBQ3ZCLGNBQThCLEVBQzlCLG1CQUF3QyxFQUN4QyxlQUFvQztRQUhyQyxnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQUN2QixtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7UUFDOUIsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFxQjtRQUN4QyxvQkFBZSxHQUFmLGVBQWUsQ0FBcUI7UUF0Q2hELG1CQUFjLEdBQUcsY0FBYyxDQUFDO1FBQ2hDLG9CQUFlLEdBQUcsZUFBZSxDQUFDO1FBRWxDLGVBQVUsR0FBRyxVQUFVLENBQUM7UUFDeEIsb0JBQWUsR0FBRyxlQUFlLENBQUM7UUFDbEMsa0JBQWEsR0FBRyxhQUFhLENBQUM7UUFDOUIsdUJBQWtCLEdBQUcsa0JBQWtCLENBQUM7UUFDeEMseUJBQW9CLEdBQUcsb0JBQW9CLENBQUM7UUFDNUMsZ0NBQTJCLEdBQUcsMkJBQTJCLENBQUM7UUFJMUQsb0JBQWUsR0FBYSxDQUFDLElBQUksRUFBRSxXQUFXLEVBQUUsZ0JBQWdCLEVBQUUsZ0JBQWdCLEVBQUUsYUFBYSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDN0gsaUJBQVksR0FBVyxDQUFDLENBQUM7UUFDekIsZUFBVSxHQUFVLEVBQUUsQ0FBQztRQUV2QixlQUFVLEdBQVksS0FBSyxDQUFDO1FBRTVCLGNBQVMsR0FBVSxFQUFFLENBQUM7UUFDdEIsYUFBUSxHQUFXLElBQUksQ0FBQztRQUV4QixVQUFLLEdBQVMsSUFBSSxJQUFJLEVBQUUsQ0FBQztRQUV6QixvQkFBZSxHQUFnQixJQUFJLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztRQUMzRSxnQkFBVyxHQUFnQixJQUFJLFdBQVcsRUFBRSxDQUFDO1FBQzdDLGNBQVMsR0FBZ0IsSUFBSSxXQUFXLEVBQUUsQ0FBQztRQUUzQyxhQUFRLEdBQWdCLElBQUksV0FBVyxDQUFDLGVBQWUsQ0FBQyxNQUFNLEVBQUUsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBWWpGLENBQUM7SUFFTCxRQUFRO1FBQ0osSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUU1RCxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDdkIsQ0FBQztJQUVLLFdBQVc7O1lBQ2IsSUFBSSxDQUFDLFFBQVEsSUFBVyxNQUFNLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxjQUFjLEVBQUUsQ0FBQSxDQUFDO1lBRXhFLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7WUFDbEYsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1lBRWpHLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLElBQUksZUFBZSxDQUFDLE1BQU0sRUFBRTtnQkFDL0MsSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUM7YUFDL0I7aUJBQU07Z0JBQ0gsSUFBSSxDQUFDLHNCQUFzQixFQUFFLENBQUM7YUFDakM7UUFDTCxDQUFDO0tBQUE7SUFFRCxvQkFBb0IsQ0FBQyxlQUF1QixFQUFFLFVBQWlDO1FBQzNFLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsb0JBQW9CLENBQUMsZUFBZSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBQ2xGLElBQUksQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRXhDLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1FBQ2pHLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7UUFFaEgsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssSUFBSSxlQUFlLENBQUMsTUFBTSxFQUFFO1lBQy9DLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1NBQy9CO2FBQU07WUFDSCxJQUFJLENBQUMsc0JBQXNCLEVBQUUsQ0FBQztTQUNqQztJQUNMLENBQUM7SUFFRCxvQkFBb0I7UUFDaEIsS0FBSyxDQUNELElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUNuQixJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFDcEIsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxFQUFFLE9BQU8sQ0FBQyxDQUNwRCxDQUFDLElBQUksQ0FDRixTQUFTLENBQUMsRUFBRSxDQUFDLEVBQ2IsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxJQUFJLGVBQWUsQ0FBQyxNQUFNLENBQUMsRUFDM0QsU0FBUyxDQUFDLEdBQUcsRUFBRTtZQUNYLElBQUksV0FBVyxHQUFHLEVBQUUsQ0FBQztZQUVyQixJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7Z0JBQ2pCLFdBQVcsQ0FBQyxRQUFRLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO2FBQzVDO1lBQ0QsV0FBVyxDQUFDLFFBQVEsQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDO1lBQ2pELFdBQVcsQ0FBQyxVQUFVLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQztZQUNsRCxXQUFXLENBQUMsUUFBUSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7WUFDekMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDO1lBQzdDLFdBQVcsQ0FBQyxXQUFXLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQztZQUNsRCxXQUFXLENBQUMsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUM7WUFFOUMsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUN2RSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNqRCxDQUFDLENBQUMsRUFDRixHQUFHLENBQUMsQ0FBQyxRQUEyQixFQUFPLEVBQUU7WUFDckMsSUFBSSxRQUFRLElBQUksSUFBSSxFQUFFO2dCQUNsQixJQUFJLENBQUMsWUFBWSxHQUFHLENBQUMsQ0FBQztnQkFDdEIsT0FBTyxFQUFFLENBQUM7YUFDYjtZQUNELElBQUksQ0FBQyxZQUFZLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQzNDLE9BQU8sUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQy9CLENBQUMsQ0FBQyxDQUNMLENBQUMsU0FBUyxDQUFDLENBQUMsVUFBVSxFQUFFLEVBQUU7WUFDdkIsSUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7UUFDakMsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQsc0JBQXNCO1FBQ2xCLEtBQUssQ0FDRCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFDbkIsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQ3BCLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FDcEQsQ0FBQyxJQUFJLENBQ0YsU0FBUyxDQUFDLEVBQUUsQ0FBQyxFQUNiLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssSUFBSSxlQUFlLENBQUMsUUFBUSxDQUFDLEVBQzdELFNBQVMsQ0FBQyxHQUFHLEVBQUU7WUFDWCxJQUFJLFdBQVcsR0FBRyxFQUFFLENBQUM7WUFFckIsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFO2dCQUNqQixXQUFXLENBQUMsUUFBUSxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQzthQUM1QztZQUNELFdBQVcsQ0FBQyxRQUFRLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQztZQUNqRCxXQUFXLENBQUMsVUFBVSxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUM7WUFDbEQsV0FBVyxDQUFDLFFBQVEsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO1lBQ3pDLFdBQVcsQ0FBQyxTQUFTLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQztZQUM3QyxXQUFXLENBQUMsV0FBVyxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUM7WUFDbEQsV0FBVyxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDO1lBRTlDLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FDekUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakQsQ0FBQyxDQUFDLEVBQ0YsR0FBRyxDQUFDLENBQUMsUUFBMkIsRUFBTyxFQUFFO1lBQ3JDLElBQUksUUFBUSxJQUFJLElBQUksRUFBRTtnQkFDbEIsSUFBSSxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUM7Z0JBQ3RCLE9BQU8sRUFBRSxDQUFDO2FBQ2I7WUFDRCxJQUFJLENBQUMsWUFBWSxHQUFHLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUMzQyxPQUFPLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMvQixDQUFDLENBQUMsQ0FDTCxDQUFDLFNBQVMsQ0FBQyxDQUFDLFVBQVUsRUFBRSxFQUFFO1lBQ3ZCLElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO1FBQ2pDLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVELFlBQVk7UUFDUixJQUFJLFdBQVcsQ0FBQztRQUVoQixRQUFRLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFO1lBQ3pCLEtBQUssZUFBZSxDQUFDLE1BQU07Z0JBQ3ZCLFdBQVcsR0FBRyxlQUFlLENBQUMsTUFBTSxDQUFDO2dCQUNyQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztnQkFDNUIsTUFBTTtZQUNWLEtBQUssZUFBZSxDQUFDLFFBQVE7Z0JBQ3pCLFdBQVcsR0FBRyxlQUFlLENBQUMsUUFBUSxDQUFDO2dCQUN2QyxJQUFJLENBQUMsc0JBQXNCLEVBQUUsQ0FBQztnQkFDOUIsTUFBTTtZQUNWO2dCQUNJLE9BQU8sQ0FBQyxHQUFHLENBQUMsNkJBQTZCLENBQUMsQ0FBQztTQUNsRDtRQUNELElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFRCxRQUFRLENBQUMsS0FBYTtRQUNsQixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztRQUN2QixJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztRQUN6QixJQUFJLEtBQUssQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFO1lBQ25CLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUN0QjthQUFNO1lBQ0gsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDO1NBQ2hDO1FBQ0QsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDMUMsQ0FBQztJQUVELFdBQVc7UUFDUCxJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztRQUN4QixJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ2pDLENBQUM7SUFFRCxZQUFZLENBQUMsUUFBUTtRQUNqQixPQUFPLFFBQVEsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDO0lBQzVGLENBQUM7O3lIQTFMUSwyQkFBMkI7NkdBQTNCLDJCQUEyQiwyWkMvQnhDLDh6UEE4SU07NEZEL0dPLDJCQUEyQjtrQkFOdkMsU0FBUzttQkFBQztvQkFDUCxRQUFRLEVBQUUsVUFBVTtvQkFDcEIsV0FBVyxFQUFFLHVCQUF1QjtvQkFDcEMsU0FBUyxFQUFFLENBQUMsdUJBQXVCLENBQUM7aUJBQ3ZDO21NQWlDc0IsSUFBSTtzQkFBdEIsU0FBUzt1QkFBQyxNQUFNO2dCQUNPLFNBQVM7c0JBQWhDLFNBQVM7dUJBQUMsV0FBVztnQkFDRyxVQUFVO3NCQUFsQyxTQUFTO3VCQUFDLFlBQVk7Z0JBQ0MsU0FBUztzQkFBaEMsU0FBUzt1QkFBQyxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBPbkluaXQsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybUNvbnRyb2wsIFZhbGlkYXRvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IE1hdFNvcnQgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9zb3J0JztcbmltcG9ydCB7IE1hdFBhZ2luYXRvciB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL3BhZ2luYXRvcic7XG5pbXBvcnQgeyBNYXREYXRlcGlja2VyIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvZGF0ZXBpY2tlcic7XG5cbmltcG9ydCB7IE1vbWVudCB9IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgKiBhcyBtb21lbnQgZnJvbSAnbW9tZW50LXRpbWV6b25lJztcblxuaW1wb3J0IHsgbWVyZ2UsIGZyb21FdmVudCwgb2YgYXMgb2JzZXJ2YWJsZU9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAsIHN0YXJ0V2l0aCwgc3dpdGNoTWFwLCBjYXRjaEVycm9yLCBmaWx0ZXIgfSBmcm9tIFwicnhqcy9vcGVyYXRvcnNcIjtcblxuaW1wb3J0IHsgQWxlcnRQYWdlTGFiZWxFbnVtLCBBbGVydFN0YXR1c0VudW0sIEFsZXJ0U3RhdHVzTGFiZWxFbnVtLCBBbGVydFR5cGVFbnVtIH0gZnJvbSAnLi4vLi4vLi4vLi4vZW51bS9hbGVydC5lbnVtJztcbmltcG9ydCB7IEFsYXJtUGFnZU0gfSBmcm9tICcuLi8uLi8uLi8uLi9tb2RlbC9hbGFybS5tb2RlbCc7XG5cbmltcG9ydCB7IEFsZXJ0UnVsZUNvbnRyb2xsZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9jb250cm9sbGVyL2FsZXJ0LmNvbnRyb2xsZXInO1xuXG4vLyB0c2MtbGlicmFyeVxuaW1wb3J0IHsgRGF0ZVNlcnZpY2UgfSBmcm9tICdAbGlicmFyeS9kYXRlJztcbmltcG9ydCB7IENPTU1PTl9DT05TVEFOVCwgTWF0ZXJpYWxGb3JtRmllbGRBcHBlYXJhbmNlLCBQYWdlTSwgU2VhcmNoQmFyT25lQ29tcG9uZW50LCBTdGF0dXNFbnVtLCBUQUJMRV9DT05TVEFOVCB9IGZyb20gJ0BsaWJyYXJ5L3RzYy1jb21tb24nO1xuaW1wb3J0IHsgU3RvcmFnZVNlcnZpY2UgfSBmcm9tICdAbGlicmFyeS9zdG9yYWdlLXNlcnZpY2UnO1xuaW1wb3J0IHsgT3JnYW5pemF0aW9uU2VydmljZSB9IGZyb20gJ0BsaWJyYXJ5L29yZ2FuaXphdGlvbi1zZXJ2aWNlJztcbi8vIC90c2MtbGlicmFyeS9cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdsaWItcGFnZScsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3BhZ2UuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3BhZ2UuY29tcG9uZW50LnNjc3MnXVxufSlcblxuZXhwb3J0IGNsYXNzIEdlbmVyYXRlZEFsYXJtUGFnZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICBUQUJMRV9DT05TVEFOVCA9IFRBQkxFX0NPTlNUQU5UO1xuICAgIENPTU1PTl9DT05TVEFOVCA9IENPTU1PTl9DT05TVEFOVDtcblxuICAgIFN0YXR1c0VudW0gPSBTdGF0dXNFbnVtO1xuICAgIEFsZXJ0U3RhdHVzRW51bSA9IEFsZXJ0U3RhdHVzRW51bTtcbiAgICBBbGVydFR5cGVFbnVtID0gQWxlcnRUeXBlRW51bTtcbiAgICBBbGVydFBhZ2VMYWJlbEVudW0gPSBBbGVydFBhZ2VMYWJlbEVudW07XG4gICAgQWxlcnRTdGF0dXNMYWJlbEVudW0gPSBBbGVydFN0YXR1c0xhYmVsRW51bTtcbiAgICBNYXRlcmlhbEZvcm1GaWVsZEFwcGVhcmFuY2UgPSBNYXRlcmlhbEZvcm1GaWVsZEFwcGVhcmFuY2U7XG5cbiAgICBvcmdJRDogYW55O1xuXG4gICAgZGlzcGxheWVkQ29sdW1uOiBzdHJpbmdbXSA9IFsnaWQnLCAnYWxlcnROYW1lJywgJ3BhcmFtZXRlckxhYmVsJywgJ2Fzc29jaWF0ZWRXaXRoJywgJ2Rlc2NyaXB0aW9uJywgJ3RpbWUnLCAndHlwZScsICdzdGF0dXMnXTtcbiAgICByZXN1bHRMZW5ndGg6IG51bWJlciA9IDA7XG4gICAgZGF0YVNvdXJjZTogYW55W10gPSBbXTtcblxuICAgIHNlYXJjaEZsYWc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBzZWFyY2hWYWx1ZTogc3RyaW5nO1xuICAgIHNlYXJjaEFycjogYW55W10gPSBbXTtcbiAgICB0aW1lWm9uZTogc3RyaW5nID0gbnVsbDtcblxuICAgIHRvZGF5OiBEYXRlID0gbmV3IERhdGUoKTtcblxuICAgIHNlbGVjdGVkTW9udGhGQzogRm9ybUNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2wobW9tZW50KCkuZm9ybWF0KCdZWVlZLU1NJykpO1xuICAgIHN0YXJ0RGF0ZUZDOiBGb3JtQ29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCgpO1xuICAgIGVuZERhdGVGQzogRm9ybUNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woKTtcblxuICAgIHN0YXR1c0ZDOiBGb3JtQ29udHJvbCA9IG5ldyBGb3JtQ29udHJvbChBbGVydFN0YXR1c0VudW0uQUNUSVZFLCBWYWxpZGF0b3JzLnJlcXVpcmVkKTtcblxuICAgIEBWaWV3Q2hpbGQoJ3NvcnQnKSBzb3J0OiBNYXRTb3J0O1xuICAgIEBWaWV3Q2hpbGQoJ3BhZ2luYXRvcicpIHBhZ2luYXRvcjogTWF0UGFnaW5hdG9yO1xuICAgIEBWaWV3Q2hpbGQoJ3JlZnJlc2hCdG4nKSByZWZyZXNoQnRuOiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGQoJ3NlYXJjaEJhcicpIHNlYXJjaEJhcjogU2VhcmNoQmFyT25lQ29tcG9uZW50O1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyBkYXRlU2VydmljZTogRGF0ZVNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgc3RvcmFnZVNlcnZpY2U6IFN0b3JhZ2VTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIG9yZ2FuaXphdGlvblNlcnZpY2U6IE9yZ2FuaXphdGlvblNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgYWxlcnRDb250cm9sbGVyOiBBbGVydFJ1bGVDb250cm9sbGVyXG4gICAgKSB7IH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9yZ0lEID0gdGhpcy5zdG9yYWdlU2VydmljZS5nZXRTdG9yYWdlKCdjdXJyZW50T3JnSUQnKTtcblxuICAgICAgICB0aGlzLmdldFRpbWV6b25lKCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0VGltZXpvbmUoKSB7XG4gICAgICAgIHRoaXMudGltZVpvbmUgPSA8c3RyaW5nPmF3YWl0IHRoaXMub3JnYW5pemF0aW9uU2VydmljZS5nZXRPcmdUaW1lem9uZSgpO1xuXG4gICAgICAgIHRoaXMuc3RhcnREYXRlRkMucGF0Y2hWYWx1ZShtb21lbnQoKS5zdGFydE9mKCdtb250aCcpLnR6KHRoaXMudGltZVpvbmUpLmZvcm1hdCgpKTtcbiAgICAgICAgdGhpcy5lbmREYXRlRkMucGF0Y2hWYWx1ZShtb21lbnQoKS5hZGQoMSwgJ21vbnRocycpLnN0YXJ0T2YoJ21vbnRoJykudHoodGhpcy50aW1lWm9uZSkuZm9ybWF0KCkpO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YXR1c0ZDLnZhbHVlID09IEFsZXJ0U3RhdHVzRW51bS5BQ1RJVkUpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0QWN0aXZlQWxlcnRCeVBhZ2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0UmVzb2x2ZWRBbGVydEJ5UGFnZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9udGhTZWxlY3RlZEhhbmRsZXIobm9ybWFsaXplZE1vbnRoOiBNb21lbnQsIGRhdGVwaWNrZXI6IE1hdERhdGVwaWNrZXI8TW9tZW50Pik6IHZvaWQge1xuICAgICAgICBsZXQgZHVyYXRpb24gPSB0aGlzLmRhdGVTZXJ2aWNlLm1vbnRoU2VsZWN0ZWRIYW5kbGVyKG5vcm1hbGl6ZWRNb250aCwgZGF0ZXBpY2tlcik7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRNb250aEZDLnNldFZhbHVlKGR1cmF0aW9uKTtcblxuICAgICAgICB0aGlzLnN0YXJ0RGF0ZUZDLnBhdGNoVmFsdWUobW9tZW50KG5vcm1hbGl6ZWRNb250aCkuc3RhcnRPZignbW9udGgnKS50eih0aGlzLnRpbWVab25lKS5mb3JtYXQoKSk7XG4gICAgICAgIHRoaXMuZW5kRGF0ZUZDLnBhdGNoVmFsdWUobW9tZW50KG5vcm1hbGl6ZWRNb250aCkuYWRkKDEsICdtb250aHMnKS5zdGFydE9mKCdtb250aCcpLnR6KHRoaXMudGltZVpvbmUpLmZvcm1hdCgpKTtcblxuICAgICAgICBpZiAodGhpcy5zdGF0dXNGQy52YWx1ZSA9PSBBbGVydFN0YXR1c0VudW0uQUNUSVZFKSB7XG4gICAgICAgICAgICB0aGlzLmdldEFjdGl2ZUFsZXJ0QnlQYWdlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdldFJlc29sdmVkQWxlcnRCeVBhZ2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEFjdGl2ZUFsZXJ0QnlQYWdlKCkge1xuICAgICAgICBtZXJnZShcbiAgICAgICAgICAgIHRoaXMucGFnaW5hdG9yLnBhZ2UsXG4gICAgICAgICAgICB0aGlzLnNvcnQuc29ydENoYW5nZSxcbiAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLnJlZnJlc2hCdG4ubmF0aXZlRWxlbWVudCwgJ2NsaWNrJylcbiAgICAgICAgKS5waXBlKFxuICAgICAgICAgICAgc3RhcnRXaXRoKHt9KSxcbiAgICAgICAgICAgIGZpbHRlcigoKSA9PiB0aGlzLnN0YXR1c0ZDLnZhbHVlID09IEFsZXJ0U3RhdHVzRW51bS5BQ1RJVkUpLFxuICAgICAgICAgICAgc3dpdGNoTWFwKCgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVxdWVzdEJvZHkgPSB7fTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlYXJjaEZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHlbJ3NlYXJjaCddID0gdGhpcy5zZWFyY2hWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVxdWVzdEJvZHlbJ3BhZ2VObyddID0gdGhpcy5wYWdpbmF0b3IucGFnZUluZGV4O1xuICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5WydwYWdlU2l6ZSddID0gdGhpcy5wYWdpbmF0b3IucGFnZVNpemU7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEJvZHlbJ3NvcnRCeSddID0gdGhpcy5zb3J0LmFjdGl2ZTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keVsnb3JkZXJCeSddID0gdGhpcy5zb3J0LmRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keVsnc3RhcnREYXRlJ10gPSB0aGlzLnN0YXJ0RGF0ZUZDLnZhbHVlO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5WydlbmREYXRlJ10gPSB0aGlzLmVuZERhdGVGQy52YWx1ZTtcbiAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hbGVydENvbnRyb2xsZXIuZ2V0QWN0aXZlQWxlcnRCeVBhZ2UodGhpcy5vcmdJRCwgcmVxdWVzdEJvZHlcbiAgICAgICAgICAgICAgICApLnBpcGUoY2F0Y2hFcnJvcigoKSA9PiBvYnNlcnZhYmxlT2YobnVsbCkpKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbWFwKChyZXNwb25zZTogUGFnZU08QWxhcm1QYWdlTT4pOiBhbnkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0TGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdExlbmd0aCA9IHJlc3BvbnNlW1widG90YWxDb3VudFwiXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VbXCJyZWNvcmRzXCJdO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKS5zdWJzY3JpYmUoKGRhdGFTb3VyY2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2U7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldFJlc29sdmVkQWxlcnRCeVBhZ2UoKSB7XG4gICAgICAgIG1lcmdlKFxuICAgICAgICAgICAgdGhpcy5wYWdpbmF0b3IucGFnZSxcbiAgICAgICAgICAgIHRoaXMuc29ydC5zb3J0Q2hhbmdlLFxuICAgICAgICAgICAgZnJvbUV2ZW50KHRoaXMucmVmcmVzaEJ0bi5uYXRpdmVFbGVtZW50LCAnY2xpY2snKVxuICAgICAgICApLnBpcGUoXG4gICAgICAgICAgICBzdGFydFdpdGgoe30pLFxuICAgICAgICAgICAgZmlsdGVyKCgpID0+IHRoaXMuc3RhdHVzRkMudmFsdWUgPT0gQWxlcnRTdGF0dXNFbnVtLlJFU09MVkVEKSxcbiAgICAgICAgICAgIHN3aXRjaE1hcCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHJlcXVlc3RCb2R5ID0ge307XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWFyY2hGbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5WydzZWFyY2gnXSA9IHRoaXMuc2VhcmNoVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5WydwYWdlTm8nXSA9IHRoaXMucGFnaW5hdG9yLnBhZ2VJbmRleDtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keVsncGFnZVNpemUnXSA9IHRoaXMucGFnaW5hdG9yLnBhZ2VTaXplO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5Wydzb3J0QnknXSA9IHRoaXMuc29ydC5hY3RpdmU7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEJvZHlbJ29yZGVyQnknXSA9IHRoaXMuc29ydC5kaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgcmVxdWVzdEJvZHlbJ3N0YXJ0RGF0ZSddID0gdGhpcy5zdGFydERhdGVGQy52YWx1ZTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keVsnZW5kRGF0ZSddID0gdGhpcy5lbmREYXRlRkMudmFsdWU7XG4gICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxlcnRDb250cm9sbGVyLmdldFJlc29sdmVkQWxlcnRCeVBhZ2UodGhpcy5vcmdJRCwgcmVxdWVzdEJvZHlcbiAgICAgICAgICAgICAgICApLnBpcGUoY2F0Y2hFcnJvcigoKSA9PiBvYnNlcnZhYmxlT2YobnVsbCkpKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbWFwKChyZXNwb25zZTogUGFnZU08QWxhcm1QYWdlTT4pOiBhbnkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0TGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdExlbmd0aCA9IHJlc3BvbnNlW1widG90YWxDb3VudFwiXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VbXCJyZWNvcmRzXCJdO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKS5zdWJzY3JpYmUoKGRhdGFTb3VyY2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2U7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXR1c0NoYW5nZSgpIHtcbiAgICAgICAgbGV0IGFsZXJ0U3RhdHVzO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0dXNGQy52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBBbGVydFN0YXR1c0VudW0uQUNUSVZFOlxuICAgICAgICAgICAgICAgIGFsZXJ0U3RhdHVzID0gQWxlcnRTdGF0dXNFbnVtLkFDVElWRTtcbiAgICAgICAgICAgICAgICB0aGlzLmdldEFjdGl2ZUFsZXJ0QnlQYWdlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEFsZXJ0U3RhdHVzRW51bS5SRVNPTFZFRDpcbiAgICAgICAgICAgICAgICBhbGVydFN0YXR1cyA9IEFsZXJ0U3RhdHVzRW51bS5SRVNPTFZFRDtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFJlc29sdmVkQWxlcnRCeVBhZ2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1bmRlZmluZWQgY2FzZSBlbmNvdW50ZXJlZCFcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0dXNGQy5wYXRjaFZhbHVlKGFsZXJ0U3RhdHVzKTtcbiAgICB9XG5cbiAgICBzZWFyY2hGbih2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoRmxhZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2VhcmNoVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0U2VhcmNoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhZ2luYXRvci5wYWdlSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmcmVzaEJ0bi5uYXRpdmVFbGVtZW50LmNsaWNrKCk7XG4gICAgfVxuXG4gICAgcmVzZXRTZWFyY2goKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoRmxhZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlYXJjaEJhci5zZWFyY2hDbGVhcigpO1xuICAgIH1cblxuICAgIGdldFRpbWVMYWJlbChkYXRlVGltZSkge1xuICAgICAgICByZXR1cm4gZGF0ZVRpbWUgPyBtb21lbnQudHooZGF0ZVRpbWUsIHRoaXMudGltZVpvbmUpLmZyb21Ob3coKSA6IENPTU1PTl9DT05TVEFOVC5IWVBIRU47XG4gICAgfVxuXG59XG4iLCI8ZGl2IGNsYXNzPVwiY2FyZCBtYWluLWNhcmQgY2FyZE92ZXJ3cml0ZSBoMTAwXCI+XG4gICAgPGRpdiBjbGFzcz1cImhlYWRlckNvbnRhaW5lclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaGVhZGVyTGVmdENvbnRhaW5lclwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2VUaXRsZVwiPkdlbmVyYXRlZCBBbGFybXM8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8YnV0dG9uICNyZWZyZXNoQnRuIGNsYXNzPVwiZC1ub25lXCI+PC9idXR0b24+XG5cbiAgICA8ZGl2IGNsYXNzPVwiY2FyZC1ib2R5XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMlwiPlxuICAgICAgICAgICAgICAgIDxtYXQtZm9ybS1maWVsZCBpZD1cIm1vbnRobHlGaWVsZFwiIGFwcE1vbnRoWWVhckZvcm1hdCAoY2xpY2spPVwiZGF0ZVNlcnZpY2Uub3BlbkRhdGVwaWNrZXJPbkNsaWNrKG1vbnRobHkpXCJcbiAgICAgICAgICAgICAgICAgICAgKGtleWRvd24uYXJyb3dkb3duKT1cImRhdGVTZXJ2aWNlLm9wZW5EYXRlcGlja2VyT25DbGljayhtb250aGx5KVwiXG4gICAgICAgICAgICAgICAgICAgIChrZXlkb3duLmVudGVyKT1cImRhdGVTZXJ2aWNlLm9wZW5EYXRlcGlja2VyT25DbGljayhtb250aGx5KVwiIGNsYXNzPVwibWF0RmllbGRXaWR0aDEwMCBjdXJzb3JQb2ludGVyXCJcbiAgICAgICAgICAgICAgICAgICAgW2FwcGVhcmFuY2VdPVwiTWF0ZXJpYWxGb3JtRmllbGRBcHBlYXJhbmNlLkZPUk1fRklFTERfQVBQRUFSQU5DRVwiPlxuICAgICAgICAgICAgICAgICAgICA8bWF0LWxhYmVsIGNsYXNzPVwiZm9ybUxhYmVsXCI+U2VsZWN0IG1vbnRoPC9tYXQtbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBtYXRJbnB1dCBjbGFzcz1cIm5vRm9jdXNcIiBbbWF0RGF0ZXBpY2tlcl09XCJtb250aGx5XCIgW2Zvcm1Db250cm9sXT1cInNlbGVjdGVkTW9udGhGQ1wiIFttYXhdPVwidG9kYXlcIiByZWFkb25seSAvPlxuICAgICAgICAgICAgICAgICAgICA8bWF0LWRhdGVwaWNrZXItdG9nZ2xlIG1hdFN1ZmZpeCBjbGFzcz1cImZzLTVcIiBbZm9yXT1cIm1vbnRobHlcIj48L21hdC1kYXRlcGlja2VyLXRvZ2dsZT5cbiAgICAgICAgICAgICAgICAgICAgPG1hdC1kYXRlcGlja2VyIHBhbmVsQ2xhc3M9XCJtb250aFBpY2tlclwiICNtb250aGx5IHN0YXJ0Vmlldz1cInllYXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKG1vbnRoU2VsZWN0ZWQpPVwibW9udGhTZWxlY3RlZEhhbmRsZXIoJGV2ZW50LCBtb250aGx5KVwiIChjbG9zZWQpPVwiZGF0ZVNlcnZpY2UudGFrZUZvY3VzQXdheSgnbW9udGhseUZpZWxkJylcIj5cbiAgICAgICAgICAgICAgICAgICAgPC9tYXQtZGF0ZXBpY2tlcj5cbiAgICAgICAgICAgICAgICA8L21hdC1mb3JtLWZpZWxkPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZsb2F0LWVuZCBtZS0xIG10LTJcIj5cbiAgICAgICAgICAgICAgICAgICAgPG1hdC1idXR0b24tdG9nZ2xlLWdyb3VwIGNsYXNzPVwibWF0QnRuRmlsdGVyXCIgW2Zvcm1Db250cm9sXT1cInN0YXR1c0ZDXCIgKGNoYW5nZSk9XCJzdGF0dXNDaGFuZ2UoKVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPG1hdC1idXR0b24tdG9nZ2xlIHZhbHVlPVwie3sgQWxlcnRTdGF0dXNFbnVtLkFDVElWRSB9fVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IEFsZXJ0U3RhdHVzTGFiZWxFbnVtLkFDVElWRV9MQUJFTCB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9tYXQtYnV0dG9uLXRvZ2dsZT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxtYXQtYnV0dG9uLXRvZ2dsZSB2YWx1ZT1cInt7IEFsZXJ0U3RhdHVzRW51bS5SRVNPTFZFRCB9fVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IEFsZXJ0U3RhdHVzTGFiZWxFbnVtLlJFU09MVkVEX0xBQkVMIH19XG4gICAgICAgICAgICAgICAgICAgICAgICA8L21hdC1idXR0b24tdG9nZ2xlPlxuICAgICAgICAgICAgICAgICAgICA8L21hdC1idXR0b24tdG9nZ2xlLWdyb3VwPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTJcIj5cbiAgICAgICAgICAgICAgICA8bGliLXNlYXJjaC1iYXItb25lIGNsYXNzPVwibWUtMSBmbG9hdC1lbmRcIiAjc2VhcmNoQmFyIHNlYXJjaEJ5PVwicGFyYW1ldGVyIG5hbWVcIiAoZW1pdFNlYXJjaCk9XCJzZWFyY2hGbigkZXZlbnQpXCI+XG4gICAgICAgICAgICAgICAgPC9saWItc2VhcmNoLWJhci1vbmU+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm92ZXJmbG93WCBjdXN0b21TY3JvbGxCYXJcIj5cbiAgICAgICAgICAgIDx0YWJsZSBjbGFzcz1cInctMTAwXCIgbWF0LXRhYmxlIFtkYXRhU291cmNlXT1cImRhdGFTb3VyY2VcIiAjc29ydD1cIm1hdFNvcnRcIiBtYXRTb3J0IG1hdFNvcnRBY3RpdmU9XCJpZFwiXG4gICAgICAgICAgICAgICAgbWF0U29ydERpcmVjdGlvbj1cImFzY1wiIG1hdFNvcnREaXNhYmxlQ2xlYXI+XG5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyIG1hdENvbHVtbkRlZj1cImlkXCI+XG4gICAgICAgICAgICAgICAgICAgIDx0aCBjbGFzcz1cInB4LTMgY29sdW1uV2lkdGgxXCIgbWF0LWhlYWRlci1jZWxsICptYXRIZWFkZXJDZWxsRGVmIG1hdC1zb3J0LWhlYWRlciBkaXNhYmxlQ2xlYXI+XG4gICAgICAgICAgICAgICAgICAgICAgICBJRFxuICAgICAgICAgICAgICAgICAgICA8L3RoPlxuICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJweC0zIGNvbHVtbldpZHRoMVwiIG1hdC1jZWxsICptYXRDZWxsRGVmPVwibGV0IHJvd1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAge3sgcm93LmlkID8gcm93LmlkOiBDT01NT05fQ09OU1RBTlQuSFlQSEVOIH19XG4gICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyIG1hdENvbHVtbkRlZj1cImFsZXJ0TmFtZVwiPlxuICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XCJweC0zIGNvbHVtbldpZHRoNFwiIG1hdC1oZWFkZXItY2VsbCAqbWF0SGVhZGVyQ2VsbERlZj4gTmFtZSA8L3RoPlxuICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJweC0zIGNvbHVtbldpZHRoNFwiIG1hdC1jZWxsICptYXRDZWxsRGVmPVwibGV0IHJvd1wiXG4gICAgICAgICAgICAgICAgICAgICAgICBbbWF0VG9vbHRpcF09XCJyb3c/LlsnYWxlcnROYW1lJ10/Lmxlbmd0aD4xNT8gcm93WydhbGVydE5hbWUnXTogJydcIiBtYXRUb29sdGlwUG9zaXRpb249XCJhYm92ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRUb29sdGlwQ2xhc3M9XCJuYW1lVG9vbHRpcFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAge3sgKHJvdy5hbGVydE5hbWUgPyByb3cuYWxlcnROYW1lOiBDT01NT05fQ09OU1RBTlQuSFlQSEVOKSB8IGRvdGRvdGRvdDoxNX19XG4gICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyIG1hdENvbHVtbkRlZj1cInBhcmFtZXRlckxhYmVsXCI+XG4gICAgICAgICAgICAgICAgICAgIDx0aCBjbGFzcz1cInB4LTMgY29sdW1uV2lkdGg0XCIgbWF0LWhlYWRlci1jZWxsICptYXRIZWFkZXJDZWxsRGVmPlxuICAgICAgICAgICAgICAgICAgICAgICAgUGFyYW1ldGVyIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgPC90aD5cbiAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVwicHgtMyBjb2x1bW5XaWR0aDRcIiBtYXQtY2VsbCAqbWF0Q2VsbERlZj1cImxldCByb3dcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt7IHJvdy5wYXJhbWV0ZXJMYWJlbCA/IHJvdy5wYXJhbWV0ZXJMYWJlbDogQ09NTU9OX0NPTlNUQU5ULkhZUEhFTiB9fVxuICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBtYXRDb2x1bW5EZWY9XCJhc3NvY2lhdGVkV2l0aFwiPlxuICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XCJweC0zIGNvbHVtbldpZHRoM1wiIG1hdC1oZWFkZXItY2VsbCAqbWF0SGVhZGVyQ2VsbERlZj4gQXNzb2NpYXRlZCB3aXRoIDwvdGg+XG4gICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cInB4LTMgY29sdW1uV2lkdGgzXCIgbWF0LWNlbGwgKm1hdENlbGxEZWY9XCJsZXQgcm93XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFttYXRUb29sdGlwXT1cInJvdz8uWydhc3NvY2lhdGVkV2l0aCddPy5sZW5ndGg+MzA/IHJvd1snYXNzb2NpYXRlZFdpdGgnXTogJydcIlxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0VG9vbHRpcFBvc2l0aW9uPVwiYWJvdmVcIiBtYXRUb29sdGlwQ2xhc3M9XCJuYW1lVG9vbHRpcFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAge3sgKHJvdy5hc3NvY2lhdGVkV2l0aCA/IHJvdy5hc3NvY2lhdGVkV2l0aDogQ09NTU9OX0NPTlNUQU5ULkhZUEhFTikgfCBkb3Rkb3Rkb3Q6MzB9fVxuICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBtYXRDb2x1bW5EZWY9XCJkZXNjcmlwdGlvblwiPlxuICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XCJweC0zIGNvbHVtbldpZHRoM1wiIG1hdC1oZWFkZXItY2VsbCAqbWF0SGVhZGVyQ2VsbERlZj4gUnVsZSA8L3RoPlxuICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJweC0zIGNvbHVtbldpZHRoM1wiIG1hdC1jZWxsICptYXRDZWxsRGVmPVwibGV0IHJvd1wiXG4gICAgICAgICAgICAgICAgICAgICAgICBbbWF0VG9vbHRpcF09XCJyb3c/LlsnZGVzY3JpcHRpb24nXT8ubGVuZ3RoPjMwPyByb3dbJ2Rlc2NyaXB0aW9uJ106ICcnXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdFRvb2x0aXBQb3NpdGlvbj1cImFib3ZlXCIgbWF0VG9vbHRpcENsYXNzPVwibmFtZVRvb2x0aXBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt7IChyb3cuZGVzY3JpcHRpb24gPyByb3cuZGVzY3JpcHRpb246IENPTU1PTl9DT05TVEFOVC5IWVBIRU4pIHwgZG90ZG90ZG90OjMwfX1cbiAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgbWF0Q29sdW1uRGVmPVwidGltZVwiPlxuICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XCJweC0zIGNvbHVtbldpZHRoMVwiIG1hdC1oZWFkZXItY2VsbCAqbWF0SGVhZGVyQ2VsbERlZj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFRpbWVcbiAgICAgICAgICAgICAgICAgICAgPC90aD5cbiAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVwicHgtMyBjb2x1bW5XaWR0aDFcIiBtYXQtY2VsbCAqbWF0Q2VsbERlZj1cImxldCByb3dcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt7IGdldFRpbWVMYWJlbChyb3cudGltZSkgfX1cbiAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgbWF0Q29sdW1uRGVmPVwidHlwZVwiPlxuICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XCJweC0zIGNvbHVtbldpZHRoMVwiIG1hdC1oZWFkZXItY2VsbCAqbWF0SGVhZGVyQ2VsbERlZj4gVHlwZSA8L3RoPlxuICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJweC0zIGNvbHVtbldpZHRoMVwiIG1hdC1jZWxsICptYXRDZWxsRGVmPVwibGV0IHJvd1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJiYWRnZSByb3VuZGVkLXBpbGwgYmctbGlnaHQgdGV4dC1kYXJrXCIgW25nU3dpdGNoXT1cInJvdz8udHlwZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nU3dpdGNoQ2FzZT1cIkFsZXJ0VHlwZUVudW0uSU5TVEFOVEFORU9VU1wiPnt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsZXJ0UGFnZUxhYmVsRW51bS5JTlNUQU5UQU5FT1VTX0xBQkVMXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19PC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdTd2l0Y2hDYXNlPVwiQWxlcnRUeXBlRW51bS5QRVJJT0RJQ1wiPnt7IEFsZXJ0UGFnZUxhYmVsRW51bS5QRVJJT0RJQ19MQUJFTFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fTwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBtYXRDb2x1bW5EZWY9XCJzdGF0dXNcIj5cbiAgICAgICAgICAgICAgICAgICAgPHRoIGNsYXNzPVwicHgtMyBjb2x1bW5XaWR0aDFcIiBtYXQtaGVhZGVyLWNlbGwgKm1hdEhlYWRlckNlbGxEZWY+IFN0YXR1cyA8L3RoPlxuICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJweC0zIGNvbHVtbldpZHRoMVwiIG1hdC1jZWxsICptYXRDZWxsRGVmPVwibGV0IHJvd1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJiYWRnZSByb3VuZGVkLXBpbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cInsnYmctc3VjY2Vzcyc6IHJvdz8uc3RhdHVzLCAnYmctZGFuZ2VyJzogIXJvdz8uc3RhdHVzfVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IHJvdz8uc3RhdHVzID8gU3RhdHVzRW51bS5BQ1RJVkVfU1RBVFVTIDogU3RhdHVzRW51bS5JTkFDVElWRV9TVEFUVVMgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICAgICAgICAgIDx0ciBtYXQtaGVhZGVyLXJvdyAqbWF0SGVhZGVyUm93RGVmPVwiZGlzcGxheWVkQ29sdW1uXCI+PC90cj5cbiAgICAgICAgICAgICAgICA8dHIgbWF0LXJvdyAqbWF0Um93RGVmPVwibGV0IHRhc2s7IGNvbHVtbnM6IGRpc3BsYXllZENvbHVtbjtcIj48L3RyPlxuXG4gICAgICAgICAgICAgICAgPHRyIGNsYXNzPVwibWF0LXJvd1wiICptYXROb0RhdGFSb3c+XG4gICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cIm1hdC1jZWxsIHRleHQtY2VudGVyXCIgW2F0dHIuY29sc3Bhbl09XCJkaXNwbGF5ZWRDb2x1bW4ubGVuZ3RoXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICB7eyBUQUJMRV9DT05TVEFOVC5UQUJMRV9OT19EQVRBIH19XG4gICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxtYXQtcGFnaW5hdG9yICNwYWdpbmF0b3IgY2xhc3M9XCJyb3VuZGVkQm9yZGVyXCIgc2hvd0ZpcnN0TGFzdEJ1dHRvbnMgW2xlbmd0aF09XCJyZXN1bHRMZW5ndGhcIlxuICAgICAgICAgICAgW3BhZ2VTaXplXT1cIlRBQkxFX0NPTlNUQU5ULkRFRkFVTFRfUEFHRV9TSVpFXCIgW3BhZ2VTaXplT3B0aW9uc109XCJUQUJMRV9DT05TVEFOVC5QQUdFX1NJWkVfT1BUSU9OXCI+XG4gICAgICAgIDwvbWF0LXBhZ2luYXRvcj5cbiAgICA8L2Rpdj5cblxuPC9kaXY+Il19