import { Component, ViewChild } from '@angular/core';
import { merge, fromEvent, of as observableOf } from 'rxjs';
import { map, startWith, switchMap, catchError } from "rxjs/operators";
import { faPlus, faEllipsisV } from '@fortawesome/free-solid-svg-icons';
import { CreateUpdateLayoutComponent } from '../_dialog/create-update/layout/layout.component';
import { DialogEnum, DialogOneComponent, DialogOneEnum, TABLE_CONSTANT, ButtonLabelEnum } from '@library/tsc-common';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
import * as i2 from "@library/storage-service";
import * as i3 from "@library/layout-service";
import * as i4 from "@library/tsc-common";
import * as i5 from "@angular/material/dialog";
import * as i6 from "@fortawesome/angular-fontawesome";
import * as i7 from "@angular/material/table";
import * as i8 from "@angular/material/sort";
import * as i9 from "@angular/material/paginator";
import * as i10 from "@angular/material/core";
import * as i11 from "@angular/material/tooltip";
import * as i12 from "@ng-bootstrap/ng-bootstrap";
// /tsc-library/
export class PageComponent {
    constructor(router, storageService, layoutController, commonEvent, dialog) {
        this.router = router;
        this.storageService = storageService;
        this.layoutController = layoutController;
        this.commonEvent = commonEvent;
        this.dialog = dialog;
        this.TABLE_CONSTANT = TABLE_CONSTANT;
        this.ButtonLabelEnum = ButtonLabelEnum;
        this.faPlus = faPlus;
        this.faEllipsisV = faEllipsisV;
        this.displayedColumn = ['id', 'name', 'description', 'option'];
        this.resultLength = 0;
        this.dataSource = [];
        this.searchFlag = false;
        this.searchArr = [];
    }
    ngOnInit() {
        this.orgID = this.storageService.getStorage('currentOrgID');
    }
    ngAfterViewInit() {
        merge(this.paginator.page, this.sort.sortChange, fromEvent(this.refreshBtn.nativeElement, 'click')).pipe(startWith({}), switchMap(() => {
            this.searchArr = [];
            if (this.searchFlag) {
                this.searchArr.push('name:' + this.searchValue);
            }
            return this.layoutController.getLayoutByPage(this.paginator.pageIndex, this.paginator.pageSize, this.sort.active, this.sort.direction, this.searchArr, this.orgID).pipe(catchError(() => observableOf(null)));
        }), map((response) => {
            if (response == null) {
                this.resultLength = 0;
                return [];
            }
            this.resultLength = response["totalCount"];
            return response["records"];
        })).subscribe((dataSource) => {
            this.dataSource = dataSource;
        });
    }
    searchFn(value) {
        this.searchFlag = true;
        this.searchValue = value;
        if (value.length == 0) {
            this.resetSearch();
        }
        else {
            this.paginator.pageIndex = 0;
        }
        this.refreshBtn.nativeElement.click();
    }
    resetSearch() {
        this.searchFlag = false;
        this.searchBar.searchClear();
    }
    navigateToViewPage(id) {
        this.router.navigate([`layout/${id}/list`]);
    }
    openCreateUpdateLayoutDialog(action, layoutID) {
        let dialogRef;
        if (action == 'create') {
            dialogRef = this.dialog.open(CreateUpdateLayoutComponent, {
                data: {
                    action: action
                },
                minWidth: '550px',
                maxWidth: '550px'
            });
            dialogRef.afterClosed().subscribe((dialogRes) => {
                if (dialogRes.result == DialogEnum.SUCCESS_DR) {
                    // Emit the layoutChange event
                    this.commonEvent.layoutChange.next('YES');
                    this.router.navigate([`layout/${dialogRes.layoutID}/list`]);
                }
            });
        }
        else {
            dialogRef = this.dialog.open(CreateUpdateLayoutComponent, {
                data: {
                    action: action,
                    layoutID: layoutID
                },
                minWidth: '550px',
                maxWidth: '550px'
            });
            dialogRef.afterClosed().subscribe((dialogRes) => {
                if (dialogRes.result == DialogEnum.SUCCESS_DR) {
                    // Emit the layoutChange event
                    this.commonEvent.layoutChange.next('YES');
                    window.location.reload();
                }
            });
        }
    }
    openDeleteLayoutDialog(layoutID, layoutName) {
        const dialog = this.dialog.open(DialogOneComponent, {
            minWidth: '450px',
            maxWidth: '450px',
            data: {
                type: DialogOneEnum.DELETE,
                icon: 'dangerous',
                header: 'Delete layout?',
                body: '<b>' + layoutName + '</b>' + ' will be deleted permanently.</br></br>Are you sure you want to continue?',
                buttonOne: ButtonLabelEnum.CANCEL_BTN_LABEL,
                buttonTwo: ButtonLabelEnum.DELETE_BTN_LABEL
            }
        });
        dialog.afterClosed().subscribe(res => {
            if (res) {
                this.deleteLayout(layoutID);
            }
        });
    }
    deleteLayout(layoutID) {
        this.layoutController.deleteLayout(this.orgID, layoutID).subscribe((deleteRes) => {
            // Emit the layoutChange event
            this.commonEvent.layoutChange.next('YES');
            this.refreshBtn.nativeElement.click();
        });
    }
}
PageComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: PageComponent, deps: [{ token: i1.Router }, { token: i2.StorageService }, { token: i3.LayoutController }, { token: i4.CommonEvent }, { token: i5.MatDialog }], target: i0.ɵɵFactoryTarget.Component });
PageComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: PageComponent, selector: "app-page", viewQueries: [{ propertyName: "sort", first: true, predicate: ["sort"], descendants: true }, { propertyName: "paginator", first: true, predicate: ["paginator"], descendants: true }, { propertyName: "refreshBtn", first: true, predicate: ["refreshBtn"], descendants: true }, { propertyName: "searchBar", first: true, predicate: ["searchBar"], descendants: true }], ngImport: i0, template: "<div class=\"card main-card cardOverwrite h100\">\n    <div class=\"headerContainer\">\n        <div class=\"headerLeftContainer\">\n            <div class=\"pageTitle\">Layout</div>\n        </div>\n        <div class=\"headerRightContainer\">\n            <div class=\"headerRightContainerInner\">\n                <lib-search-bar-one class=\"me-3\" #searchBar searchBy=\"name\" (emitSearch)=\"searchFn($event)\">\n                </lib-search-bar-one>\n                <a class=\"btn btn-sm btn-success btnBase\" matRipple (click)=\"openCreateUpdateLayoutDialog('create', null)\">\n                    <fa-icon [icon]=\"faPlus\"></fa-icon>&nbsp; Layout\n                </a>\n            </div>\n        </div>\n    </div>\n\n    <button #refreshBtn class=\"d-none\"></button>\n\n    <table mat-table [dataSource]=\"dataSource\" #sort=\"matSort\" matSort matSortActive=\"id\" matSortDirection=\"asc\"\n        matSortDisableClear>\n\n        <ng-container matColumnDef=\"id\">\n            <th class=\"columnWidth1 px-3\" mat-header-cell *matHeaderCellDef mat-sort-header disableClear>\n                ID\n            </th>\n            <td class=\"columnWidth1\" mat-cell *matCellDef=\"let row\" (click)=\"navigateToViewPage(row['id'])\">\n                {{ row['id'] }}\n            </td>\n        </ng-container>\n\n        <ng-container matColumnDef=\"name\">\n            <th class=\"columnWidth2 px-3\" mat-header-cell *matHeaderCellDef> Name </th>\n            <td class=\"columnWidth2 px-3\" mat-cell *matCellDef=\"let row\"\n                [matTooltip]=\"row?.['name']?.length>24? row['name']: ''\" matTooltipPosition=\"above\"\n                matTooltipClass=\"nameTooltip\" (click)=\"navigateToViewPage(row['id'])\">\n                {{ row?.['name'] | dotdotdot:24 }}\n            </td>\n        </ng-container>\n\n        <ng-container matColumnDef=\"description\">\n            <th class=\"columnWidth2 px-3\" mat-header-cell *matHeaderCellDef> Description </th>\n            <td class=\"columnWidth2 px-3\" mat-cell *matCellDef=\"let row\"\n                [matTooltip]=\"row?.['description']?.length>24? row['description']: ''\" matTooltipPosition=\"above\"\n                matTooltipClass=\"nameTooltip\" (click)=\"navigateToViewPage(row['id'])\">\n                {{ row?.['description'] | dotdotdot:24 }}\n            </td>\n        </ng-container>\n\n        <ng-container matColumnDef=\"option\">\n            <th class=\"columnWidth3\" mat-header-cell *matHeaderCellDef> Action </th>\n            <td class=\"columnWidth3 text-center\" mat-cell *matCellDef=\"let row\">\n                <div class=\"d-flex align-items-center\">\n                    <div class=\"btn-group\" ngbDropdown placement=\"left\">\n                        <button type=\"button\" ngbDropdownToggle class=\"dropdown-after dropdownAfter btn\">\n                            <fa-icon [icon]=\"faEllipsisV\"></fa-icon>\n                        </button>\n                        <div ngbDropdownMenu>\n                            <button class=\"dropdown-item\" (click)=\"openCreateUpdateLayoutDialog('update', row.id)\">\n                                {{ ButtonLabelEnum.UPDATE_BTN_LABEL }}\n                            </button>\n                            <!-- <button class=\"btn btn-outline-danger rounded-0 dropdown-item\" (click)=\"openDeleteLayoutDialog(row.id, row.name)\">\n                                {{ ButtonLabelEnum.DELETE_BTN_LABEL }}\n                            </button> -->\n                        </div>\n                    </div>\n                </div>\n            </td>\n        </ng-container>\n\n        <tr mat-header-row *matHeaderRowDef=\"displayedColumn\"></tr>\n        <tr mat-row *matRowDef=\"let row; columns: displayedColumn;\" class=\"data-row\"></tr>\n\n        <tr class=\"mat-row\" *matNoDataRow>\n            <td class=\"mat-cell text-center\" [attr.colspan]=\"displayedColumn.length\">\n                {{ TABLE_CONSTANT.TABLE_NO_DATA }}\n            </td>\n        </tr>\n    </table>\n\n    <mat-paginator #paginator class=\"roundedBorder\" showFirstLastButtons [length]=\"resultLength\"\n        [pageSize]=\"TABLE_CONSTANT.DEFAULT_PAGE_SIZE\" [pageSizeOptions]=\"TABLE_CONSTANT.PAGE_SIZE_OPTION\">\n    </mat-paginator>\n</div>", styles: [".columnWidth1{min-width:120px}.columnWidth2{min-width:200px}.columnWidth3{min-width:140px}\n"], components: [{ type: i4.SearchBarOneComponent, selector: "lib-search-bar-one", inputs: ["type", "searchBy", "clear", "emitValueOnChange"], outputs: ["emitSearch"] }, { type: i6.FaIconComponent, selector: "fa-icon", inputs: ["classes", "icon", "title", "spin", "pulse", "mask", "styles", "flip", "size", "pull", "border", "inverse", "symbol", "rotate", "fixedWidth", "transform", "a11yRole"] }, { type: i7.MatTable, selector: "mat-table, table[mat-table]", exportAs: ["matTable"] }, { type: i8.MatSortHeader, selector: "[mat-sort-header]", inputs: ["disabled", "arrowPosition", "sortActionDescription", "disableClear", "mat-sort-header", "start"], exportAs: ["matSortHeader"] }, { type: i7.MatHeaderRow, selector: "mat-header-row, tr[mat-header-row]", exportAs: ["matHeaderRow"] }, { type: i7.MatRow, selector: "mat-row, tr[mat-row]", exportAs: ["matRow"] }, { type: i9.MatPaginator, selector: "mat-paginator", inputs: ["disabled"], exportAs: ["matPaginator"] }], directives: [{ type: i10.MatRipple, selector: "[mat-ripple], [matRipple]", inputs: ["matRippleRadius", "matRippleDisabled", "matRippleTrigger", "matRippleColor", "matRippleUnbounded", "matRippleCentered", "matRippleAnimation"], exportAs: ["matRipple"] }, { type: i8.MatSort, selector: "[matSort]", inputs: ["matSortDisabled", "matSortStart", "matSortDirection", "matSortDisableClear", "matSortActive"], outputs: ["matSortChange"], exportAs: ["matSort"] }, { type: i7.MatColumnDef, selector: "[matColumnDef]", inputs: ["sticky", "matColumnDef"] }, { type: i7.MatHeaderCellDef, selector: "[matHeaderCellDef]" }, { type: i7.MatHeaderCell, selector: "mat-header-cell, th[mat-header-cell]" }, { type: i7.MatCellDef, selector: "[matCellDef]" }, { type: i7.MatCell, selector: "mat-cell, td[mat-cell]" }, { type: i11.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { type: i12.NgbDropdown, selector: "[ngbDropdown]", inputs: ["autoClose", "dropdownClass", "open", "placement", "container", "display"], outputs: ["openChange"], exportAs: ["ngbDropdown"] }, { type: i12.NgbDropdownToggle, selector: "[ngbDropdownToggle]" }, { type: i12.NgbDropdownMenu, selector: "[ngbDropdownMenu]" }, { type: i7.MatHeaderRowDef, selector: "[matHeaderRowDef]", inputs: ["matHeaderRowDef", "matHeaderRowDefSticky"] }, { type: i7.MatRowDef, selector: "[matRowDef]", inputs: ["matRowDefColumns", "matRowDefWhen"] }, { type: i7.MatNoDataRow, selector: "ng-template[matNoDataRow]" }], pipes: { "dotdotdot": i4.EllipsisPipeService } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: PageComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'app-page',
                    templateUrl: './page.component.html',
                    styleUrls: ['./page.component.scss']
                }]
        }], ctorParameters: function () { return [{ type: i1.Router }, { type: i2.StorageService }, { type: i3.LayoutController }, { type: i4.CommonEvent }, { type: i5.MatDialog }]; }, propDecorators: { sort: [{
                type: ViewChild,
                args: ['sort']
            }], paginator: [{
                type: ViewChild,
                args: ['paginator']
            }], refreshBtn: [{
                type: ViewChild,
                args: ['refreshBtn']
            }], searchBar: [{
                type: ViewChild,
                args: ['searchBar']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFnZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9saWJyYXJ5L3RzYy1saXRlL3NyYy9saWIvdHNjL2NvbXBvbmVudC9sYXlvdXQvcGFnZS9wYWdlLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2xpYnJhcnkvdHNjLWxpdGUvc3JjL2xpYi90c2MvY29tcG9uZW50L2xheW91dC9wYWdlL3BhZ2UuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBc0IsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBT3pFLE9BQU8sRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLEVBQUUsSUFBSSxZQUFZLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDNUQsT0FBTyxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRXZFLE9BQU8sRUFBRSxNQUFNLEVBQUUsV0FBVyxFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFFeEUsT0FBTyxFQUFFLDJCQUEyQixFQUFFLE1BQU0sa0RBQWtELENBQUM7QUFJL0YsT0FBTyxFQUFlLFVBQVUsRUFBRSxrQkFBa0IsRUFBRSxhQUFhLEVBQWdDLGNBQWMsRUFBRSxlQUFlLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7QUFFaEssZ0JBQWdCO0FBUWhCLE1BQU0sT0FBTyxhQUFhO0lBb0J0QixZQUNZLE1BQWMsRUFDZCxjQUE4QixFQUM5QixnQkFBa0MsRUFDbEMsV0FBd0IsRUFDeEIsTUFBaUI7UUFKakIsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQUNkLG1CQUFjLEdBQWQsY0FBYyxDQUFnQjtRQUM5QixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBQ2xDLGdCQUFXLEdBQVgsV0FBVyxD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S0FBSyxDQUFDLENBQUM7WUFFMUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDMUMsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDOzsyR0F4SlEsYUFBYTsrRkFBYixhQUFhLDJaQzFCMUIsNnJJQWtGTTs0RkR4RE8sYUFBYTtrQkFOekIsU0FBUzttQkFBQztvQkFDUCxRQUFRLEVBQUUsVUFBVTtvQkFDcEIsV0FBVyxFQUFFLHVCQUF1QjtvQkFDcEMsU0FBUyxFQUFFLENBQUMsdUJBQXVCLENBQUM7aUJBQ3ZDOzJNQWlCc0IsSUFBSTtzQkFBdEIsU0FBUzt1QkFBQyxNQUFNO2dCQUNPLFNBQVM7c0JBQWhDLFNBQVM7dUJBQUMsV0FBVztnQkFDRyxVQUFVO3NCQUFsQyxTQUFTO3VCQUFDLFlBQVk7Z0JBQ0MsU0FBUztzQkFBaEMsU0FBUzt1QkFBQyxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBPbkluaXQsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUm91dGVyIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcblxuaW1wb3J0IHsgTWF0U29ydCB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL3NvcnQnO1xuaW1wb3J0IHsgTWF0UGFnaW5hdG9yIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvcGFnaW5hdG9yJztcbmltcG9ydCB7IE1hdERpYWxvZyB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL2RpYWxvZyc7XG5cbmltcG9ydCB7IG1lcmdlLCBmcm9tRXZlbnQsIG9mIGFzIG9ic2VydmFibGVPZiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwLCBzdGFydFdpdGgsIHN3aXRjaE1hcCwgY2F0Y2hFcnJvciB9IGZyb20gXCJyeGpzL29wZXJhdG9yc1wiO1xuXG5pbXBvcnQgeyBmYVBsdXMsIGZhRWxsaXBzaXNWIH0gZnJvbSAnQGZvcnRhd2Vzb21lL2ZyZWUtc29saWQtc3ZnLWljb25zJztcblxuaW1wb3J0IHsgQ3JlYXRlVXBkYXRlTGF5b3V0Q29tcG9uZW50IH0gZnJvbSAnLi4vX2RpYWxvZy9jcmVhdGUtdXBkYXRlL2xheW91dC9sYXlvdXQuY29tcG9uZW50JztcblxuLy8gdHNjLWxpYnJhcnlcbmltcG9ydCB7IFN0b3JhZ2VTZXJ2aWNlIH0gZnJvbSAnQGxpYnJhcnkvc3RvcmFnZS1zZXJ2aWNlJztcbmltcG9ydCB7IENvbW1vbkV2ZW50LCBEaWFsb2dFbnVtLCBEaWFsb2dPbmVDb21wb25lbnQsIERpYWxvZ09uZUVudW0sIFBhZ2VNLCBTZWFyY2hCYXJPbmVDb21wb25lbnQsIFRBQkxFX0NPTlNUQU5ULCBCdXR0b25MYWJlbEVudW0gfSBmcm9tICdAbGlicmFyeS90c2MtY29tbW9uJztcbmltcG9ydCB7IExheW91dE0sIExheW91dENvbnRyb2xsZXIgfSBmcm9tICdAbGlicmFyeS9sYXlvdXQtc2VydmljZSc7XG4vLyAvdHNjLWxpYnJhcnkvXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXBwLXBhZ2UnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9wYWdlLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi9wYWdlLmNvbXBvbmVudC5zY3NzJ11cbn0pXG5cbmV4cG9ydCBjbGFzcyBQYWdlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgICBUQUJMRV9DT05TVEFOVCA9IFRBQkxFX0NPTlNUQU5UO1xuICAgIEJ1dHRvbkxhYmVsRW51bSA9IEJ1dHRvbkxhYmVsRW51bTtcblxuICAgIGZhUGx1cyA9IGZhUGx1cztcbiAgICBmYUVsbGlwc2lzViA9IGZhRWxsaXBzaXNWO1xuXG4gICAgb3JnSUQ6IGFueTtcbiAgICBkaXNwbGF5ZWRDb2x1bW46IHN0cmluZ1tdID0gWydpZCcsICduYW1lJywgJ2Rlc2NyaXB0aW9uJywgJ29wdGlvbiddO1xuICAgIHJlc3VsdExlbmd0aDogbnVtYmVyID0gMDtcbiAgICBkYXRhU291cmNlOiBhbnlbXSA9IFtdO1xuICAgIHNlYXJjaEZsYWc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBzZWFyY2hWYWx1ZTogc3RyaW5nO1xuICAgIHNlYXJjaEFycjogYW55W10gPSBbXTtcblxuICAgIEBWaWV3Q2hpbGQoJ3NvcnQnKSBzb3J0OiBNYXRTb3J0O1xuICAgIEBWaWV3Q2hpbGQoJ3BhZ2luYXRvcicpIHBhZ2luYXRvcjogTWF0UGFnaW5hdG9yO1xuICAgIEBWaWV3Q2hpbGQoJ3JlZnJlc2hCdG4nKSByZWZyZXNoQnRuOiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGQoJ3NlYXJjaEJhcicpIHNlYXJjaEJhcjogU2VhcmNoQmFyT25lQ29tcG9uZW50O1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgcm91dGVyOiBSb3V0ZXIsXG4gICAgICAgIHByaXZhdGUgc3RvcmFnZVNlcnZpY2U6IFN0b3JhZ2VTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIGxheW91dENvbnRyb2xsZXI6IExheW91dENvbnRyb2xsZXIsXG4gICAgICAgIHByaXZhdGUgY29tbW9uRXZlbnQ6IENvbW1vbkV2ZW50LFxuICAgICAgICBwcml2YXRlIGRpYWxvZzogTWF0RGlhbG9nLFxuICAgICkgeyB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vcmdJRCA9IHRoaXMuc3RvcmFnZVNlcnZpY2UuZ2V0U3RvcmFnZSgnY3VycmVudE9yZ0lEJyk7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBtZXJnZShcbiAgICAgICAgICAgIHRoaXMucGFnaW5hdG9yLnBhZ2UsXG4gICAgICAgICAgICB0aGlzLnNvcnQuc29ydENoYW5nZSxcbiAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLnJlZnJlc2hCdG4ubmF0aXZlRWxlbWVudCwgJ2NsaWNrJylcbiAgICAgICAgKS5waXBlKFxuICAgICAgICAgICAgc3RhcnRXaXRoKHt9KSxcbiAgICAgICAgICAgIHN3aXRjaE1hcCgoKTogYW55ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaEFyciA9IFtdO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlYXJjaEZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hBcnIucHVzaCgnbmFtZTonICsgdGhpcy5zZWFyY2hWYWx1ZSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXRDb250cm9sbGVyLmdldExheW91dEJ5UGFnZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWdpbmF0b3IucGFnZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhZ2luYXRvci5wYWdlU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3J0LmFjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3J0LmRpcmVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hBcnIsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3JnSURcbiAgICAgICAgICAgICAgICApLnBpcGUoY2F0Y2hFcnJvcigoKSA9PiBvYnNlcnZhYmxlT2YobnVsbCkpKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbWFwKChyZXNwb25zZTogUGFnZU08TGF5b3V0TT4pOiBhbnkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0TGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdExlbmd0aCA9IHJlc3BvbnNlW1widG90YWxDb3VudFwiXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VbXCJyZWNvcmRzXCJdO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKS5zdWJzY3JpYmUoKGRhdGFTb3VyY2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2U7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNlYXJjaEZuKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hGbGFnID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZWFyY2hWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRTZWFyY2goKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFnaW5hdG9yLnBhZ2VJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWZyZXNoQnRuLm5hdGl2ZUVsZW1lbnQuY2xpY2soKTtcbiAgICB9XG5cbiAgICByZXNldFNlYXJjaCgpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hGbGFnID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VhcmNoQmFyLnNlYXJjaENsZWFyKCk7XG4gICAgfVxuXG4gICAgbmF2aWdhdGVUb1ZpZXdQYWdlKGlkKSB7XG4gICAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlKFtgbGF5b3V0LyR7aWR9L2xpc3RgXSk7XG4gICAgfVxuXG4gICAgb3BlbkNyZWF0ZVVwZGF0ZUxheW91dERpYWxvZyhhY3Rpb24sIGxheW91dElEKSB7XG4gICAgICAgIGxldCBkaWFsb2dSZWY7XG4gICAgICAgIGlmIChhY3Rpb24gPT0gJ2NyZWF0ZScpIHtcbiAgICAgICAgICAgIGRpYWxvZ1JlZiA9IHRoaXMuZGlhbG9nLm9wZW4oQ3JlYXRlVXBkYXRlTGF5b3V0Q29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGFjdGlvblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWluV2lkdGg6ICc1NTBweCcsXG4gICAgICAgICAgICAgICAgbWF4V2lkdGg6ICc1NTBweCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGlhbG9nUmVmLmFmdGVyQ2xvc2VkKCkuc3Vic2NyaWJlKChkaWFsb2dSZXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZGlhbG9nUmVzLnJlc3VsdCA9PSBEaWFsb2dFbnVtLlNVQ0NFU1NfRFIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW1pdCB0aGUgbGF5b3V0Q2hhbmdlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbW9uRXZlbnQubGF5b3V0Q2hhbmdlLm5leHQoJ1lFUycpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlKFtgbGF5b3V0LyR7ZGlhbG9nUmVzLmxheW91dElEfS9saXN0YF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaWFsb2dSZWYgPSB0aGlzLmRpYWxvZy5vcGVuKENyZWF0ZVVwZGF0ZUxheW91dENvbXBvbmVudCwge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGxheW91dElEOiBsYXlvdXRJRFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWluV2lkdGg6ICc1NTBweCcsXG4gICAgICAgICAgICAgICAgbWF4V2lkdGg6ICc1NTBweCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGlhbG9nUmVmLmFmdGVyQ2xvc2VkKCkuc3Vic2NyaWJlKChkaWFsb2dSZXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZGlhbG9nUmVzLnJlc3VsdCA9PSBEaWFsb2dFbnVtLlNVQ0NFU1NfRFIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW1pdCB0aGUgbGF5b3V0Q2hhbmdlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbW9uRXZlbnQubGF5b3V0Q2hhbmdlLm5leHQoJ1lFUycpO1xuXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3BlbkRlbGV0ZUxheW91dERpYWxvZyhsYXlvdXRJRCwgbGF5b3V0TmFtZSkge1xuICAgICAgICBjb25zdCBkaWFsb2cgPSB0aGlzLmRpYWxvZy5vcGVuKERpYWxvZ09uZUNvbXBvbmVudCwge1xuICAgICAgICAgICAgbWluV2lkdGg6ICc0NTBweCcsXG4gICAgICAgICAgICBtYXhXaWR0aDogJzQ1MHB4JyxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBEaWFsb2dPbmVFbnVtLkRFTEVURSxcbiAgICAgICAgICAgICAgICBpY29uOiAnZGFuZ2Vyb3VzJyxcbiAgICAgICAgICAgICAgICBoZWFkZXI6ICdEZWxldGUgbGF5b3V0PycsXG4gICAgICAgICAgICAgICAgYm9keTogJzxiPicgKyBsYXlvdXROYW1lICsgJzwvYj4nICsgJyB3aWxsIGJlIGRlbGV0ZWQgcGVybWFuZW50bHkuPC9icj48L2JyPkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBjb250aW51ZT8nLFxuICAgICAgICAgICAgICAgIGJ1dHRvbk9uZTogQnV0dG9uTGFiZWxFbnVtLkNBTkNFTF9CVE5fTEFCRUwsXG4gICAgICAgICAgICAgICAgYnV0dG9uVHdvOiBCdXR0b25MYWJlbEVudW0uREVMRVRFX0JUTl9MQUJFTFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZGlhbG9nLmFmdGVyQ2xvc2VkKCkuc3Vic2NyaWJlKHJlcyA9PiB7XG4gICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVMYXlvdXQobGF5b3V0SUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGRlbGV0ZUxheW91dChsYXlvdXRJRCkge1xuICAgICAgICB0aGlzLmxheW91dENvbnRyb2xsZXIuZGVsZXRlTGF5b3V0KHRoaXMub3JnSUQsIGxheW91dElEKS5zdWJzY3JpYmUoKGRlbGV0ZVJlcykgPT4ge1xuICAgICAgICAgICAgLy8gRW1pdCB0aGUgbGF5b3V0Q2hhbmdlIGV2ZW50XG4gICAgICAgICAgICB0aGlzLmNvbW1vbkV2ZW50LmxheW91dENoYW5nZS5uZXh0KCdZRVMnKTtcblxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoQnRuLm5hdGl2ZUVsZW1lbnQuY2xpY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSIsIjxkaXYgY2xhc3M9XCJjYXJkIG1haW4tY2FyZCBjYXJkT3ZlcndyaXRlIGgxMDBcIj5cbiAgICA8ZGl2IGNsYXNzPVwiaGVhZGVyQ29udGFpbmVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJoZWFkZXJMZWZ0Q29udGFpbmVyXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZVRpdGxlXCI+TGF5b3V0PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaGVhZGVyUmlnaHRDb250YWluZXJcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJoZWFkZXJSaWdodENvbnRhaW5lcklubmVyXCI+XG4gICAgICAgICAgICAgICAgPGxpYi1zZWFyY2gtYmFyLW9uZSBjbGFzcz1cIm1lLTNcIiAjc2VhcmNoQmFyIHNlYXJjaEJ5PVwibmFtZVwiIChlbWl0U2VhcmNoKT1cInNlYXJjaEZuKCRldmVudClcIj5cbiAgICAgICAgICAgICAgICA8L2xpYi1zZWFyY2gtYmFyLW9uZT5cbiAgICAgICAgICAgICAgICA8YSBjbGFzcz1cImJ0biBidG4tc20gYnRuLXN1Y2Nlc3MgYnRuQmFzZVwiIG1hdFJpcHBsZSAoY2xpY2spPVwib3BlbkNyZWF0ZVVwZGF0ZUxheW91dERpYWxvZygnY3JlYXRlJywgbnVsbClcIj5cbiAgICAgICAgICAgICAgICAgICAgPGZhLWljb24gW2ljb25dPVwiZmFQbHVzXCI+PC9mYS1pY29uPiZuYnNwOyBMYXlvdXRcbiAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8YnV0dG9uICNyZWZyZXNoQnRuIGNsYXNzPVwiZC1ub25lXCI+PC9idXR0b24+XG5cbiAgICA8dGFibGUgbWF0LXRhYmxlIFtkYXRhU291cmNlXT1cImRhdGFTb3VyY2VcIiAjc29ydD1cIm1hdFNvcnRcIiBtYXRTb3J0IG1hdFNvcnRBY3RpdmU9XCJpZFwiIG1hdFNvcnREaXJlY3Rpb249XCJhc2NcIlxuICAgICAgICBtYXRTb3J0RGlzYWJsZUNsZWFyPlxuXG4gICAgICAgIDxuZy1jb250YWluZXIgbWF0Q29sdW1uRGVmPVwiaWRcIj5cbiAgICAgICAgICAgIDx0aCBjbGFzcz1cImNvbHVtbldpZHRoMSBweC0zXCIgbWF0LWhlYWRlci1jZWxsICptYXRIZWFkZXJDZWxsRGVmIG1hdC1zb3J0LWhlYWRlciBkaXNhYmxlQ2xlYXI+XG4gICAgICAgICAgICAgICAgSURcbiAgICAgICAgICAgIDwvdGg+XG4gICAgICAgICAgICA8dGQgY2xhc3M9XCJjb2x1bW5XaWR0aDFcIiBtYXQtY2VsbCAqbWF0Q2VsbERlZj1cImxldCByb3dcIiAoY2xpY2spPVwibmF2aWdhdGVUb1ZpZXdQYWdlKHJvd1snaWQnXSlcIj5cbiAgICAgICAgICAgICAgICB7eyByb3dbJ2lkJ10gfX1cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgIDxuZy1jb250YWluZXIgbWF0Q29sdW1uRGVmPVwibmFtZVwiPlxuICAgICAgICAgICAgPHRoIGNsYXNzPVwiY29sdW1uV2lkdGgyIHB4LTNcIiBtYXQtaGVhZGVyLWNlbGwgKm1hdEhlYWRlckNlbGxEZWY+IE5hbWUgPC90aD5cbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cImNvbHVtbldpZHRoMiBweC0zXCIgbWF0LWNlbGwgKm1hdENlbGxEZWY9XCJsZXQgcm93XCJcbiAgICAgICAgICAgICAgICBbbWF0VG9vbHRpcF09XCJyb3c/LlsnbmFtZSddPy5sZW5ndGg+MjQ/IHJvd1snbmFtZSddOiAnJ1wiIG1hdFRvb2x0aXBQb3NpdGlvbj1cImFib3ZlXCJcbiAgICAgICAgICAgICAgICBtYXRUb29sdGlwQ2xhc3M9XCJuYW1lVG9vbHRpcFwiIChjbGljayk9XCJuYXZpZ2F0ZVRvVmlld1BhZ2Uocm93WydpZCddKVwiPlxuICAgICAgICAgICAgICAgIHt7IHJvdz8uWyduYW1lJ10gfCBkb3Rkb3Rkb3Q6MjQgfX1cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgIDxuZy1jb250YWluZXIgbWF0Q29sdW1uRGVmPVwiZGVzY3JpcHRpb25cIj5cbiAgICAgICAgICAgIDx0aCBjbGFzcz1cImNvbHVtbldpZHRoMiBweC0zXCIgbWF0LWhlYWRlci1jZWxsICptYXRIZWFkZXJDZWxsRGVmPiBEZXNjcmlwdGlvbiA8L3RoPlxuICAgICAgICAgICAgPHRkIGNsYXNzPVwiY29sdW1uV2lkdGgyIHB4LTNcIiBtYXQtY2VsbCAqbWF0Q2VsbERlZj1cImxldCByb3dcIlxuICAgICAgICAgICAgICAgIFttYXRUb29sdGlwXT1cInJvdz8uWydkZXNjcmlwdGlvbiddPy5sZW5ndGg+MjQ/IHJvd1snZGVzY3JpcHRpb24nXTogJydcIiBtYXRUb29sdGlwUG9zaXRpb249XCJhYm92ZVwiXG4gICAgICAgICAgICAgICAgbWF0VG9vbHRpcENsYXNzPVwibmFtZVRvb2x0aXBcIiAoY2xpY2spPVwibmF2aWdhdGVUb1ZpZXdQYWdlKHJvd1snaWQnXSlcIj5cbiAgICAgICAgICAgICAgICB7eyByb3c/LlsnZGVzY3JpcHRpb24nXSB8IGRvdGRvdGRvdDoyNCB9fVxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgPG5nLWNvbnRhaW5lciBtYXRDb2x1bW5EZWY9XCJvcHRpb25cIj5cbiAgICAgICAgICAgIDx0aCBjbGFzcz1cImNvbHVtbldpZHRoM1wiIG1hdC1oZWFkZXItY2VsbCAqbWF0SGVhZGVyQ2VsbERlZj4gQWN0aW9uIDwvdGg+XG4gICAgICAgICAgICA8dGQgY2xhc3M9XCJjb2x1bW5XaWR0aDMgdGV4dC1jZW50ZXJcIiBtYXQtY2VsbCAqbWF0Q2VsbERlZj1cImxldCByb3dcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZC1mbGV4IGFsaWduLWl0ZW1zLWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwXCIgbmdiRHJvcGRvd24gcGxhY2VtZW50PVwibGVmdFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgbmdiRHJvcGRvd25Ub2dnbGUgY2xhc3M9XCJkcm9wZG93bi1hZnRlciBkcm9wZG93bkFmdGVyIGJ0blwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxmYS1pY29uIFtpY29uXT1cImZhRWxsaXBzaXNWXCI+PC9mYS1pY29uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IG5nYkRyb3Bkb3duTWVudT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiZHJvcGRvd24taXRlbVwiIChjbGljayk9XCJvcGVuQ3JlYXRlVXBkYXRlTGF5b3V0RGlhbG9nKCd1cGRhdGUnLCByb3cuaWQpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IEJ1dHRvbkxhYmVsRW51bS5VUERBVEVfQlROX0xBQkVMIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLWRhbmdlciByb3VuZGVkLTAgZHJvcGRvd24taXRlbVwiIChjbGljayk9XCJvcGVuRGVsZXRlTGF5b3V0RGlhbG9nKHJvdy5pZCwgcm93Lm5hbWUpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IEJ1dHRvbkxhYmVsRW51bS5ERUxFVEVfQlROX0xBQkVMIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+IC0tPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgPHRyIG1hdC1oZWFkZXItcm93ICptYXRIZWFkZXJSb3dEZWY9XCJkaXNwbGF5ZWRDb2x1bW5cIj48L3RyPlxuICAgICAgICA8dHIgbWF0LXJvdyAqbWF0Um93RGVmPVwibGV0IHJvdzsgY29sdW1uczogZGlzcGxheWVkQ29sdW1uO1wiIGNsYXNzPVwiZGF0YS1yb3dcIj48L3RyPlxuXG4gICAgICAgIDx0ciBjbGFzcz1cIm1hdC1yb3dcIiAqbWF0Tm9EYXRhUm93PlxuICAgICAgICAgICAgPHRkIGNsYXNzPVwibWF0LWNlbGwgdGV4dC1jZW50ZXJcIiBbYXR0ci5jb2xzcGFuXT1cImRpc3BsYXllZENvbHVtbi5sZW5ndGhcIj5cbiAgICAgICAgICAgICAgICB7eyBUQUJMRV9DT05TVEFOVC5UQUJMRV9OT19EQVRBIH19XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICA8L3RyPlxuICAgIDwvdGFibGU+XG5cbiAgICA8bWF0LXBhZ2luYXRvciAjcGFnaW5hdG9yIGNsYXNzPVwicm91bmRlZEJvcmRlclwiIHNob3dGaXJzdExhc3RCdXR0b25zIFtsZW5ndGhdPVwicmVzdWx0TGVuZ3RoXCJcbiAgICAgICAgW3BhZ2VTaXplXT1cIlRBQkxFX0NPTlNUQU5ULkRFRkFVTFRfUEFHRV9TSVpFXCIgW3BhZ2VTaXplT3B0aW9uc109XCJUQUJMRV9DT05TVEFOVC5QQUdFX1NJWkVfT1BUSU9OXCI+XG4gICAgPC9tYXQtcGFnaW5hdG9yPlxuPC9kaXY+Il19