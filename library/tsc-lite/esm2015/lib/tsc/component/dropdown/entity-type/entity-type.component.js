import { __awaiter } from "tslib";
import { Component, EventEmitter, Output } from '@angular/core';
import { FormControl, Validators } from '@angular/forms';
import { EntityType } from '../../../model/entity.model';
import { COMMON_CONSTANT, FormErrorEnum, MatSelectSearchService, MaterialFormFieldAppearance } from '@library/tsc-common';
import * as i0 from "@angular/core";
import * as i1 from "@library/storage-service";
import * as i2 from "../../../service/entity.service";
import * as i3 from "@angular/material/form-field";
import * as i4 from "@angular/material/select";
import * as i5 from "@angular/material/core";
import * as i6 from "ngx-mat-select-search";
import * as i7 from "@angular/forms";
import * as i8 from "@angular/common";
// /tsc-library/
export class EntityTypeComponent {
    constructor(storageService, entityService) {
        this.storageService = storageService;
        this.entityService = entityService;
        this.materialFormFieldAppearance = MaterialFormFieldAppearance;
        this.commonConstant = COMMON_CONSTANT;
        this.FormErrorEnum = FormErrorEnum;
        this.entityTypeM = [new EntityType()];
        this.entityTypeFC = new FormControl('', Validators.required);
        this.entityTypeSearchUtil = new MatSelectSearchService(['type']);
        this.emitFilter = new EventEmitter();
    }
    ngOnInit() {
        this.orgID = this.storageService.getStorage('currentOrgID');
        this.layoutID = this.storageService.getStorage('layoutID');
        this.getEntityTypeByLayoutID();
    }
    getEntityTypeByLayoutID() {
        return __awaiter(this, void 0, void 0, function* () {
            this.entityTypeM = (yield this.entityService.getEntityTypeByLayoutID(this.orgID, 'NO'));
            this.entityTypeSearchUtil.entityArr = this.entityTypeM;
            this.entityTypeSearchUtil.createSubscription();
            if (this.entityTypeM && this.entityTypeM.length > 0) {
                const defaultEntityType = this.entityTypeM[0].type;
                if (defaultEntityType) {
                    this.entityTypeFC.patchValue(defaultEntityType);
                    this.emitFilter.emit();
                }
            }
        });
    }
    onChange(selectedType) {
        this.entityTypeFC.patchValue(selectedType);
        this.emitFilter.emit();
    }
}
EntityTypeComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: EntityTypeComponent, deps: [{ token: i1.StorageService }, { token: i2.EntityService }], target: i0.ɵɵFactoryTarget.Component });
EntityTypeComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: EntityTypeComponent, selector: "lib-entity-type", outputs: { emitFilter: "emitFilter" }, ngImport: i0, template: "<mat-form-field class=\"matFieldWidth100\" [appearance]=\"materialFormFieldAppearance.FORM_FIELD_APPEARANCE\">\n    <mat-label>Select entity type</mat-label>\n    <mat-select (selectionChange)=\"onChange($event.value)\" [formControl]=\"entityTypeFC\" required>\n        <ng-container *ngIf=\"entityTypeM && entityTypeM.length > 0 && entityTypeM?.[0]?.type; else noDataFound\">\n            <mat-option>\n                <ngx-mat-select-search [formControl]=\"entityTypeSearchUtil.filterFC\" placeholderLabel=\"Search by name\"\n                    noEntriesFoundLabel=\"No matching name found.\">\n                </ngx-mat-select-search>\n            </mat-option>\n            <mat-option *ngFor=\"let type of entityTypeSearchUtil.filteredEntities | async\" [value]=\"type.type\">\n                {{ type.type | titlecase }}\n            </mat-option>\n        </ng-container>\n        <ng-template #noDataFound>\n            <mat-option disabled>\n                {{ commonConstant.NO_DATA_FOUND }}\n            </mat-option>\n        </ng-template>\n    </mat-select>\n    <mat-error *ngIf=\"entityTypeFC.touched && entityTypeFC.hasError('required')\">\n        {{ FormErrorEnum.REQUIRED }}\n    </mat-error>\n</mat-form-field>", components: [{ type: i3.MatFormField, selector: "mat-form-field", inputs: ["color", "floatLabel", "appearance", "hideRequiredMarker", "hintLabel"], exportAs: ["matFormField"] }, { type: i4.MatSelect, selector: "mat-select", inputs: ["disabled", "disableRipple", "tabIndex"], exportAs: ["matSelect"] }, { type: i5.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { type: i6.MatSelectSearchComponent, selector: "ngx-mat-select-search", inputs: ["placeholderLabel", "type", "closeIcon", "closeSvgIcon", "noEntriesFoundLabel", "indexAndLengthScreenReaderText", "clearSearchInput", "searching", "disableInitialFocus", "enableClearOnEscapePressed", "preventHomeEndKeyPropagation", "disableScrollToActiveOnOptionsChanged", "ariaLabel", "showToggleAllCheckbox", "toggleAllCheckboxChecked", "toggleAllCheckboxIndeterminate", "toggleAllCheckboxTooltipMessage", "toogleAllCheckboxTooltipPosition", "hideClearSearchButton", "alwaysRestoreSelectedOptionsMulti"], outputs: ["toggleAll"] }], directives: [{ type: i3.MatLabel, selector: "mat-label" }, { type: i7.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i7.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i7.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { type: i8.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i8.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.MatError, selector: "mat-error", inputs: ["id"] }], pipes: { "async": i8.AsyncPipe, "titlecase": i8.TitleCasePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: EntityTypeComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'lib-entity-type',
                    templateUrl: './entity-type.component.html',
                    styles: []
                }]
        }], ctorParameters: function () { return [{ type: i1.StorageService }, { type: i2.EntityService }]; }, propDecorators: { emitFilter: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW50aXR5LXR5cGUuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbGlicmFyeS90c2MtbGl0ZS9zcmMvbGliL3RzYy9jb21wb25lbnQvZHJvcGRvd24vZW50aXR5LXR5cGUvZW50aXR5LXR5cGUuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbGlicmFyeS90c2MtbGl0ZS9zcmMvbGliL3RzYy9jb21wb25lbnQvZHJvcGRvd24vZW50aXR5LXR5cGUvZW50aXR5LXR5cGUuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFVLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN4RSxPQUFPLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRXpELE9BQU8sRUFBRSxVQUFVLEVBQWUsTUFBTSw2QkFBNkIsQ0FBQztBQU10RSxPQUFPLEVBQUUsZUFBZSxFQUFFLGFBQWEsRUFBRSxzQkFBc0IsRUFBRSwyQkFBMkIsRUFBRSxNQUFNLHFCQUFxQixDQUFDOzs7Ozs7Ozs7O0FBQzFILGdCQUFnQjtBQVFoQixNQUFNLE9BQU8sbUJBQW1CO0lBaUI1QixZQUNZLGNBQThCLEVBQzlCLGFBQTRCO1FBRDVCLG1CQUFjLEdBQWQsY0FBYyxDQUFnQjtRQUM5QixrQkFBYSxHQUFiLGFBQWEsQ0FBZTtRQWpCeEMsZ0NBQTJCLEdBQUcsMkJBQTJCLENBQUM7UUFDMUQsbUJBQWMsR0FBRyxlQUFlLENBQUM7UUFFakMsa0JBQWEsR0FBRyxhQUFhLENBQUM7UUFJOUIsZ0JBQVcsR0FBRyxDQUFDLElBQUksVUFBVSxFQUFFLENBQUMsQ0FBQztRQUNqQyxpQkFBWSxHQUFnQixJQUFJLFdBQVcsQ0FBQyxFQUFFLEVBQUUsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRXJFLHlCQUFvQixHQUEyQixJQUFJLHNCQUFzQixDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUdwRixlQUFVLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztJQUs1QixDQUFDO0lBRUwsUUFBUTtRQUNKLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDNUQsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUUzRCxJQUFJLENBQUMsdUJBQXVCLEVBQUUsQ0FBQztJQUNuQyxDQUFDO0lBRUssdUJBQXVCOztZQUN6QixJQUFJLENBQUMsV0FBVyxJQUFrQixNQUFNLElBQUksQ0FBQyxhQUFhLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQSxDQUFDO1lBRXJHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQztZQUN2RCxJQUFJLENBQUMsb0JBQW9CLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztZQUUvQyxJQUFJLElBQUksQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUNqRCxNQUFNLGlCQUFpQixHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO2dCQUVuRCxJQUFJLGlCQUFpQixFQUFFO29CQUNuQixJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO29CQUNoRCxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxDQUFDO2lCQUMxQjthQUNKO1FBQ0wsQ0FBQztLQUFBO0lBRUQsUUFBUSxDQUFDLFlBQVk7UUFDakIsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDM0MsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUMzQixDQUFDOztpSEFoRFEsbUJBQW1CO3FHQUFuQixtQkFBbUIsOEZDbEJoQyxrdENBc0JpQjs0RkRKSixtQkFBbUI7a0JBTi9CLFNBQVM7bUJBQUM7b0JBQ1AsUUFBUSxFQUFFLGlCQUFpQjtvQkFDM0IsV0FBVyxFQUFFLDhCQUE4QjtvQkFDM0MsTUFBTSxFQUFFLEVBQ1A7aUJBQ0o7aUlBZ0JHLFVBQVU7c0JBRFQsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBPbkluaXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybUNvbnRyb2wsIFZhbGlkYXRvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IEVudGl0eVR5cGUsIEVudGl0eVR5cGVNIH0gZnJvbSAnLi4vLi4vLi4vbW9kZWwvZW50aXR5Lm1vZGVsJztcblxuaW1wb3J0IHsgRW50aXR5U2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3NlcnZpY2UvZW50aXR5LnNlcnZpY2UnO1xuXG4vLyB0c2MtbGlicmFyeVxuaW1wb3J0IHsgU3RvcmFnZVNlcnZpY2UgfSBmcm9tICdAbGlicmFyeS9zdG9yYWdlLXNlcnZpY2UnO1xuaW1wb3J0IHsgQ09NTU9OX0NPTlNUQU5ULCBGb3JtRXJyb3JFbnVtLCBNYXRTZWxlY3RTZWFyY2hTZXJ2aWNlLCBNYXRlcmlhbEZvcm1GaWVsZEFwcGVhcmFuY2UgfSBmcm9tICdAbGlicmFyeS90c2MtY29tbW9uJztcbi8vIC90c2MtbGlicmFyeS9cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdsaWItZW50aXR5LXR5cGUnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9lbnRpdHktdHlwZS5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVzOiBbXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBFbnRpdHlUeXBlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICAgIG1hdGVyaWFsRm9ybUZpZWxkQXBwZWFyYW5jZSA9IE1hdGVyaWFsRm9ybUZpZWxkQXBwZWFyYW5jZTtcbiAgICBjb21tb25Db25zdGFudCA9IENPTU1PTl9DT05TVEFOVDtcblxuICAgIEZvcm1FcnJvckVudW0gPSBGb3JtRXJyb3JFbnVtO1xuXG4gICAgb3JnSUQ6IGFueTtcbiAgICBsYXlvdXRJRDogYW55O1xuICAgIGVudGl0eVR5cGVNID0gW25ldyBFbnRpdHlUeXBlKCldO1xuICAgIGVudGl0eVR5cGVGQzogRm9ybUNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woJycsIFZhbGlkYXRvcnMucmVxdWlyZWQpO1xuXG4gICAgZW50aXR5VHlwZVNlYXJjaFV0aWw6IE1hdFNlbGVjdFNlYXJjaFNlcnZpY2UgPSBuZXcgTWF0U2VsZWN0U2VhcmNoU2VydmljZShbJ3R5cGUnXSk7XG5cbiAgICBAT3V0cHV0KClcbiAgICBlbWl0RmlsdGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgc3RvcmFnZVNlcnZpY2U6IFN0b3JhZ2VTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIGVudGl0eVNlcnZpY2U6IEVudGl0eVNlcnZpY2VcbiAgICApIHsgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMub3JnSUQgPSB0aGlzLnN0b3JhZ2VTZXJ2aWNlLmdldFN0b3JhZ2UoJ2N1cnJlbnRPcmdJRCcpO1xuICAgICAgICB0aGlzLmxheW91dElEID0gdGhpcy5zdG9yYWdlU2VydmljZS5nZXRTdG9yYWdlKCdsYXlvdXRJRCcpO1xuXG4gICAgICAgIHRoaXMuZ2V0RW50aXR5VHlwZUJ5TGF5b3V0SUQoKTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRFbnRpdHlUeXBlQnlMYXlvdXRJRCgpIHtcbiAgICAgICAgdGhpcy5lbnRpdHlUeXBlTSA9IDxFbnRpdHlUeXBlTVtdPmF3YWl0IHRoaXMuZW50aXR5U2VydmljZS5nZXRFbnRpdHlUeXBlQnlMYXlvdXRJRCh0aGlzLm9yZ0lELCAnTk8nKTtcblxuICAgICAgICB0aGlzLmVudGl0eVR5cGVTZWFyY2hVdGlsLmVudGl0eUFyciA9IHRoaXMuZW50aXR5VHlwZU07XG4gICAgICAgIHRoaXMuZW50aXR5VHlwZVNlYXJjaFV0aWwuY3JlYXRlU3Vic2NyaXB0aW9uKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZW50aXR5VHlwZU0gJiYgdGhpcy5lbnRpdHlUeXBlTS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0RW50aXR5VHlwZSA9IHRoaXMuZW50aXR5VHlwZU1bMF0udHlwZTtcblxuICAgICAgICAgICAgaWYgKGRlZmF1bHRFbnRpdHlUeXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRpdHlUeXBlRkMucGF0Y2hWYWx1ZShkZWZhdWx0RW50aXR5VHlwZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0RmlsdGVyLmVtaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uQ2hhbmdlKHNlbGVjdGVkVHlwZSkge1xuICAgICAgICB0aGlzLmVudGl0eVR5cGVGQy5wYXRjaFZhbHVlKHNlbGVjdGVkVHlwZSk7XG4gICAgICAgIHRoaXMuZW1pdEZpbHRlci5lbWl0KCk7XG4gICAgfVxufVxuIiwiPG1hdC1mb3JtLWZpZWxkIGNsYXNzPVwibWF0RmllbGRXaWR0aDEwMFwiIFthcHBlYXJhbmNlXT1cIm1hdGVyaWFsRm9ybUZpZWxkQXBwZWFyYW5jZS5GT1JNX0ZJRUxEX0FQUEVBUkFOQ0VcIj5cbiAgICA8bWF0LWxhYmVsPlNlbGVjdCBlbnRpdHkgdHlwZTwvbWF0LWxhYmVsPlxuICAgIDxtYXQtc2VsZWN0IChzZWxlY3Rpb25DaGFuZ2UpPVwib25DaGFuZ2UoJGV2ZW50LnZhbHVlKVwiIFtmb3JtQ29udHJvbF09XCJlbnRpdHlUeXBlRkNcIiByZXF1aXJlZD5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImVudGl0eVR5cGVNICYmIGVudGl0eVR5cGVNLmxlbmd0aCA+IDAgJiYgZW50aXR5VHlwZU0/LlswXT8udHlwZTsgZWxzZSBub0RhdGFGb3VuZFwiPlxuICAgICAgICAgICAgPG1hdC1vcHRpb24+XG4gICAgICAgICAgICAgICAgPG5neC1tYXQtc2VsZWN0LXNlYXJjaCBbZm9ybUNvbnRyb2xdPVwiZW50aXR5VHlwZVNlYXJjaFV0aWwuZmlsdGVyRkNcIiBwbGFjZWhvbGRlckxhYmVsPVwiU2VhcmNoIGJ5IG5hbWVcIlxuICAgICAgICAgICAgICAgICAgICBub0VudHJpZXNGb3VuZExhYmVsPVwiTm8gbWF0Y2hpbmcgbmFtZSBmb3VuZC5cIj5cbiAgICAgICAgICAgICAgICA8L25neC1tYXQtc2VsZWN0LXNlYXJjaD5cbiAgICAgICAgICAgIDwvbWF0LW9wdGlvbj5cbiAgICAgICAgICAgIDxtYXQtb3B0aW9uICpuZ0Zvcj1cImxldCB0eXBlIG9mIGVudGl0eVR5cGVTZWFyY2hVdGlsLmZpbHRlcmVkRW50aXRpZXMgfCBhc3luY1wiIFt2YWx1ZV09XCJ0eXBlLnR5cGVcIj5cbiAgICAgICAgICAgICAgICB7eyB0eXBlLnR5cGUgfCB0aXRsZWNhc2UgfX1cbiAgICAgICAgICAgIDwvbWF0LW9wdGlvbj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjbm9EYXRhRm91bmQ+XG4gICAgICAgICAgICA8bWF0LW9wdGlvbiBkaXNhYmxlZD5cbiAgICAgICAgICAgICAgICB7eyBjb21tb25Db25zdGFudC5OT19EQVRBX0ZPVU5EIH19XG4gICAgICAgICAgICA8L21hdC1vcHRpb24+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPC9tYXQtc2VsZWN0PlxuICAgIDxtYXQtZXJyb3IgKm5nSWY9XCJlbnRpdHlUeXBlRkMudG91Y2hlZCAmJiBlbnRpdHlUeXBlRkMuaGFzRXJyb3IoJ3JlcXVpcmVkJylcIj5cbiAgICAgICAge3sgRm9ybUVycm9yRW51bS5SRVFVSVJFRCB9fVxuICAgIDwvbWF0LWVycm9yPlxuPC9tYXQtZm9ybS1maWVsZD4iXX0=