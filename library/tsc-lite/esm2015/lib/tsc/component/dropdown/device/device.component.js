import { __awaiter } from "tslib";
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { FormControl, Validators } from '@angular/forms';
import { DropdownTypeEnum } from '../../../enum/dropdown.enum';
import { Device } from '../../../model/device.model';
import { COMMON_CONSTANT, FormErrorEnum, MaterialFormFieldAppearance, MatSelectSearchService } from '@library/tsc-common';
import * as i0 from "@angular/core";
import * as i1 from "@library/storage-service";
import * as i2 from "../../../service/device.service";
import * as i3 from "@angular/material/form-field";
import * as i4 from "@angular/material/select";
import * as i5 from "@angular/material/core";
import * as i6 from "ngx-mat-select-search";
import * as i7 from "@angular/common";
import * as i8 from "@angular/forms";
// /tsc-library/
export class DeviceComponent {
    constructor(storageService, deviceService) {
        this.storageService = storageService;
        this.deviceService = deviceService;
        this.commonConstant = COMMON_CONSTANT;
        this.materialFormFieldAppearance = MaterialFormFieldAppearance;
        this.dropdownTypeEnum = DropdownTypeEnum;
        this.FormErrorEnum = FormErrorEnum;
        this.deviceM = [new Device()];
        this.allDeviceID = [];
        this.totalDeviceCount = 0;
        this.deviceFC = new FormControl('', [Validators.required]);
        this.multipleDeviceFC = new FormControl([], [Validators.required]);
        this.deviceSearchUtil = new MatSelectSearchService(['name']);
        this.emitFilter = new EventEmitter();
    }
    ngOnInit() {
        this.orgID = this.storageService.getStorage('currentOrgID');
    }
    ngOnChanges(changes) {
        var _a;
        if (changes.dropdownTypeInp && this.dropdownTypeInp) {
            this.dropdownType = this.dropdownTypeInp;
        }
        if (this.entityInp && ((_a = this.entityInp) === null || _a === void 0 ? void 0 : _a.length) != 0) {
            if (changes.entityInp) {
                this.getDevicesByEntityID(this.entityInp);
                this.deviceFC.patchValue(null);
                this.emitFilter.emit();
            }
        }
    }
    getDevicesByEntityID(entityID) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestBody = { 'entityID': this.dropdownTypeInp == 'SINGLE' ? [entityID] : entityID };
            this.deviceM = (yield this.deviceService.getDevicesByEntityID(this.orgID, requestBody));
            this.deviceSearchUtil.entityArr = this.deviceM;
            this.deviceSearchUtil.createSubscription();
            this.totalDeviceCount = this.deviceM.length;
            this.deviceM.forEach(device => this.allDeviceID.push(device['id']));
            this.emitFilter.emit();
        });
    }
    onChange(selectedDevice) {
        this.deviceFC.patchValue(selectedDevice);
        this.emitFilter.emit();
    }
    selectAllDevices() {
        if (!this.multipleDeviceFC.value.includes(-1)) {
            this.multipleDeviceFC.reset([]);
            return;
        }
        this.multipleDeviceFC.setValue([-1, ...this.allDeviceID]);
        this.emitFilter.emit();
    }
    selectedDevices() {
        const selected = this.multipleDeviceFC.value;
        if (selected.includes(-1)) {
            selected.shift();
            this.multipleDeviceFC.patchValue(selected);
        }
        else if (this.multipleDeviceFC.value.length == this.totalDeviceCount) {
            this.allDeviceID.splice(0, 0, -1);
            this.multipleDeviceFC.patchValue(this.allDeviceID);
        }
        else {
            const filteredSelected = selected.filter(s => s != -1);
            this.multipleDeviceFC.patchValue(filteredSelected);
        }
        this.emitFilter.emit();
    }
}
DeviceComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: DeviceComponent, deps: [{ token: i1.StorageService }, { token: i2.DeviceService }], target: i0.ɵɵFactoryTarget.Component });
DeviceComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: DeviceComponent, selector: "lib-device", inputs: { dropdownTypeInp: "dropdownTypeInp", entityInp: "entityInp" }, outputs: { emitFilter: "emitFilter" }, usesOnChanges: true, ngImport: i0, template: "<mat-form-field *ngIf=\"dropdownType == dropdownTypeEnum.SINGLE_DROPDOWN\" class=\"matFieldWidth100\"\n    [appearance]=\"materialFormFieldAppearance.FORM_FIELD_APPEARANCE\">\n    <mat-label>Select device</mat-label>\n    <mat-select (selectionChange)=\"onChange($event.value)\" [formControl]=\"deviceFC\" required>\n        <ng-container *ngIf=\"deviceM && deviceM.length > 0 && deviceM[0]['id']; else noDeviceFound\">\n            <mat-option>\n                <ngx-mat-select-search [formControl]=\"deviceSearchUtil.filterFC\" placeholderLabel=\"Search by name\"\n                    noEntriesFoundLabel=\"No matching name found.\">\n                </ngx-mat-select-search>\n            </mat-option>\n            <mat-option *ngFor=\"let device of deviceSearchUtil.filteredEntities | async\" [value]=\"device.id\">\n                {{ device.name }}\n            </mat-option>\n        </ng-container>\n        <ng-template #noDeviceFound>\n            <mat-option disabled>\n                {{ commonConstant.NO_DATA_FOUND }}\n            </mat-option>\n        </ng-template>\n    </mat-select>\n    <mat-error *ngIf=\"!entityInp\">\n        Please select entity first\n    </mat-error>\n    <mat-error *ngIf=\"deviceFC.touched && deviceFC.hasError('required') && entityInp\">\n        {{ FormErrorEnum.REQUIRED }}\n    </mat-error>\n</mat-form-field>\n\n<mat-form-field *ngIf=\"dropdownType == dropdownTypeEnum.MULTIPLE_DROPDOWN\" class=\"matFieldWidth100\"\n    [appearance]=\"materialFormFieldAppearance.FORM_FIELD_APPEARANCE\">\n    <mat-label>Select device</mat-label>\n\n    <mat-select [formControl]=\"multipleDeviceFC\" multiple required>\n        <ng-container *ngIf=\"deviceM && deviceM.length > 0 && deviceM[0]['id']; else noDataOption\">\n            <ngx-mat-select-search [formControl]=\"deviceSearchUtil.filterFC\" placeholderLabel=\"Search by name\"\n                noEntriesFoundLabel=\"No matching name found.\">\n            </ngx-mat-select-search>\n            <mat-option [value]=\"-1\" (click)=\"selectAllDevices()\" [hidden]=\"deviceSearchUtil.filterFC.value\">\n                Select all\n            </mat-option>\n            <mat-option *ngFor=\"let device of deviceSearchUtil.filteredEntities | async\" [value]=\"device.id\"\n                (click)=\"selectedDevices()\">\n                {{ device.name }}\n            </mat-option>\n        </ng-container>\n        <ng-template #noDataOption>\n            <mat-option disabled>\n                {{ commonConstant.NO_DATA_FOUND }}\n            </mat-option>\n        </ng-template>\n    </mat-select>\n\n    <mat-error *ngIf=\"!entityInp\">\n        Please select entity first\n    </mat-error>\n    <mat-error *ngIf=\"multipleDeviceFC.touched && multipleDeviceFC.hasError('required') && entityInp\">\n        {{ FormErrorEnum.REQUIRED }}\n    </mat-error>\n</mat-form-field>", components: [{ type: i3.MatFormField, selector: "mat-form-field", inputs: ["color", "floatLabel", "appearance", "hideRequiredMarker", "hintLabel"], exportAs: ["matFormField"] }, { type: i4.MatSelect, selector: "mat-select", inputs: ["disabled", "disableRipple", "tabIndex"], exportAs: ["matSelect"] }, { type: i5.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { type: i6.MatSelectSearchComponent, selector: "ngx-mat-select-search", inputs: ["placeholderLabel", "type", "closeIcon", "closeSvgIcon", "noEntriesFoundLabel", "indexAndLengthScreenReaderText", "clearSearchInput", "searching", "disableInitialFocus", "enableClearOnEscapePressed", "preventHomeEndKeyPropagation", "disableScrollToActiveOnOptionsChanged", "ariaLabel", "showToggleAllCheckbox", "toggleAllCheckboxChecked", "toggleAllCheckboxIndeterminate", "toggleAllCheckboxTooltipMessage", "toogleAllCheckboxTooltipPosition", "hideClearSearchButton", "alwaysRestoreSelectedOptionsMulti"], outputs: ["toggleAll"] }], directives: [{ type: i7.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.MatLabel, selector: "mat-label" }, { type: i8.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i8.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i8.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { type: i7.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.MatError, selector: "mat-error", inputs: ["id"] }], pipes: { "async": i7.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: DeviceComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'lib-device',
                    templateUrl: './device.component.html',
                    styles: []
                }]
        }], ctorParameters: function () { return [{ type: i1.StorageService }, { type: i2.DeviceService }]; }, propDecorators: { dropdownTypeInp: [{
                type: Input
            }], entityInp: [{
                type: Input
            }], emitFilter: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGV2aWNlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2xpYnJhcnkvdHNjLWxpdGUvc3JjL2xpYi90c2MvY29tcG9uZW50L2Ryb3Bkb3duL2RldmljZS9kZXZpY2UuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbGlicmFyeS90c2MtbGl0ZS9zcmMvbGliL3RzYy9jb21wb25lbnQvZHJvcGRvd24vZGV2aWNlL2RldmljZS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFVLE1BQU0sRUFBaUIsTUFBTSxlQUFlLENBQUM7QUFDOUYsT0FBTyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUV6RCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUMvRCxPQUFPLEVBQUUsTUFBTSxFQUFXLE1BQU0sNkJBQTZCLENBQUM7QUFNOUQsT0FBTyxFQUFFLGVBQWUsRUFBRSxhQUFhLEVBQUUsMkJBQTJCLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQzs7Ozs7Ozs7OztBQUMxSCxnQkFBZ0I7QUFTaEIsTUFBTSxPQUFPLGVBQWU7SUE0QnhCLFlBQ1ksY0FBOEIsRUFDOUIsYUFBNEI7UUFENUIsbUJBQWMsR0FBZCxjQUFjLENBQWdCO1FBQzlCLGtCQUFhLEdBQWIsYUFBYSxDQUFlO1FBdEJ4QyxtQkFBYyxHQUFHLGVBQWUsQ0FBQztRQUNqQyxnQ0FBMkIsR0FBRywyQkFBMkIsQ0FBQztRQUMxRCxxQkFBZ0IsR0FBRyxnQkFBZ0IsQ0FBQztRQUNwQyxrQkFBYSxHQUFHLGFBQWEsQ0FBQztRQUU5QixZQUFPLEdBQUcsQ0FBQyxJQUFJLE1BQU0sRUFBRSxDQUFDLENBQUM7UUFJekIs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dCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25Jbml0LCBPdXRwdXQsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1Db250cm9sLCBWYWxpZGF0b3JzIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBEcm9wZG93blR5cGVFbnVtIH0gZnJvbSAnLi4vLi4vLi4vZW51bS9kcm9wZG93bi5lbnVtJztcbmltcG9ydCB7IERldmljZSwgRGV2aWNlTSB9IGZyb20gJy4uLy4uLy4uL21vZGVsL2RldmljZS5tb2RlbCc7XG5cbmltcG9ydCB7IERldmljZVNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9zZXJ2aWNlL2RldmljZS5zZXJ2aWNlJztcblxuLy8gdHNjLWxpYnJhcnlcbmltcG9ydCB7IFN0b3JhZ2VTZXJ2aWNlIH0gZnJvbSAnQGxpYnJhcnkvc3RvcmFnZS1zZXJ2aWNlJztcbmltcG9ydCB7IENPTU1PTl9DT05TVEFOVCwgRm9ybUVycm9yRW51bSwgTWF0ZXJpYWxGb3JtRmllbGRBcHBlYXJhbmNlLCBNYXRTZWxlY3RTZWFyY2hTZXJ2aWNlIH0gZnJvbSAnQGxpYnJhcnkvdHNjLWNvbW1vbic7XG4vLyAvdHNjLWxpYnJhcnkvXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnbGliLWRldmljZScsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2RldmljZS5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVzOiBbXG4gICAgXVxufSlcblxuZXhwb3J0IGNsYXNzIERldmljZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICBASW5wdXQoKVxuICAgIGRyb3Bkb3duVHlwZUlucDogRHJvcGRvd25UeXBlRW51bTtcblxuICAgIEBJbnB1dCgpXG4gICAgZW50aXR5SW5wOiBhbnk7XG5cbiAgICBjb21tb25Db25zdGFudCA9IENPTU1PTl9DT05TVEFOVDtcbiAgICBtYXRlcmlhbEZvcm1GaWVsZEFwcGVhcmFuY2UgPSBNYXRlcmlhbEZvcm1GaWVsZEFwcGVhcmFuY2U7XG4gICAgZHJvcGRvd25UeXBlRW51bSA9IERyb3Bkb3duVHlwZUVudW07XG4gICAgRm9ybUVycm9yRW51bSA9IEZvcm1FcnJvckVudW07XG5cbiAgICBkZXZpY2VNID0gW25ldyBEZXZpY2UoKV07XG5cbiAgICBvcmdJRDogYW55O1xuICAgIGRyb3Bkb3duVHlwZTogYW55O1xuICAgIGFsbERldmljZUlEOiBhbnlbXSA9IFtdO1xuICAgIHRvdGFsRGV2aWNlQ291bnQ6IG51bWJlciA9IDA7XG5cbiAgICBkZXZpY2VGQzogRm9ybUNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woJycsIFtWYWxpZGF0b3JzLnJlcXVpcmVkXSk7XG4gICAgbXVsdGlwbGVEZXZpY2VGQzogRm9ybUNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woW10sIFtWYWxpZGF0b3JzLnJlcXVpcmVkXSk7XG5cbiAgICBkZXZpY2VTZWFyY2hVdGlsOiBNYXRTZWxlY3RTZWFyY2hTZXJ2aWNlID0gbmV3IE1hdFNlbGVjdFNlYXJjaFNlcnZpY2UoWyduYW1lJ10pO1xuXG4gICAgQE91dHB1dCgpXG4gICAgZW1pdEZpbHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIHN0b3JhZ2VTZXJ2aWNlOiBTdG9yYWdlU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBkZXZpY2VTZXJ2aWNlOiBEZXZpY2VTZXJ2aWNlXG4gICAgKSB7IH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9yZ0lEID0gdGhpcy5zdG9yYWdlU2VydmljZS5nZXRTdG9yYWdlKCdjdXJyZW50T3JnSUQnKTtcbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmRyb3Bkb3duVHlwZUlucCAmJiB0aGlzLmRyb3Bkb3duVHlwZUlucCkge1xuICAgICAgICAgICAgdGhpcy5kcm9wZG93blR5cGUgPSB0aGlzLmRyb3Bkb3duVHlwZUlucDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmVudGl0eUlucCAmJiB0aGlzLmVudGl0eUlucD8ubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLmVudGl0eUlucCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0RGV2aWNlc0J5RW50aXR5SUQodGhpcy5lbnRpdHlJbnApO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kZXZpY2VGQy5wYXRjaFZhbHVlKG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdEZpbHRlci5lbWl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBnZXREZXZpY2VzQnlFbnRpdHlJRChlbnRpdHlJRCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHsgJ2VudGl0eUlEJzogdGhpcy5kcm9wZG93blR5cGVJbnAgPT0gJ1NJTkdMRScgPyBbZW50aXR5SURdIDogZW50aXR5SUQgfTtcblxuICAgICAgICB0aGlzLmRldmljZU0gPSA8RGV2aWNlTVtdPmF3YWl0IHRoaXMuZGV2aWNlU2VydmljZS5nZXREZXZpY2VzQnlFbnRpdHlJRCh0aGlzLm9yZ0lELCByZXF1ZXN0Qm9keSk7XG5cbiAgICAgICAgdGhpcy5kZXZpY2VTZWFyY2hVdGlsLmVudGl0eUFyciA9IHRoaXMuZGV2aWNlTTtcbiAgICAgICAgdGhpcy5kZXZpY2VTZWFyY2hVdGlsLmNyZWF0ZVN1YnNjcmlwdGlvbigpO1xuXG4gICAgICAgIHRoaXMudG90YWxEZXZpY2VDb3VudCA9IHRoaXMuZGV2aWNlTS5sZW5ndGg7XG4gICAgICAgIHRoaXMuZGV2aWNlTS5mb3JFYWNoKGRldmljZSA9PiB0aGlzLmFsbERldmljZUlELnB1c2goZGV2aWNlWydpZCddKSk7XG4gICAgICAgIHRoaXMuZW1pdEZpbHRlci5lbWl0KCk7XG4gICAgfVxuXG4gICAgb25DaGFuZ2Uoc2VsZWN0ZWREZXZpY2UpIHtcbiAgICAgICAgdGhpcy5kZXZpY2VGQy5wYXRjaFZhbHVlKHNlbGVjdGVkRGV2aWNlKTtcbiAgICAgICAgdGhpcy5lbWl0RmlsdGVyLmVtaXQoKTtcbiAgICB9XG5cbiAgICBzZWxlY3RBbGxEZXZpY2VzKCkge1xuICAgICAgICBpZiAoIXRoaXMubXVsdGlwbGVEZXZpY2VGQy52YWx1ZS5pbmNsdWRlcygtMSkpIHtcbiAgICAgICAgICAgIHRoaXMubXVsdGlwbGVEZXZpY2VGQy5yZXNldChbXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tdWx0aXBsZURldmljZUZDLnNldFZhbHVlKFstMSwgLi4udGhpcy5hbGxEZXZpY2VJRF0pO1xuICAgICAgICB0aGlzLmVtaXRGaWx0ZXIuZW1pdCgpO1xuICAgIH1cblxuICAgIHNlbGVjdGVkRGV2aWNlcygpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLm11bHRpcGxlRGV2aWNlRkMudmFsdWU7XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkLmluY2x1ZGVzKC0xKSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQuc2hpZnQoKTtcbiAgICAgICAgICAgIHRoaXMubXVsdGlwbGVEZXZpY2VGQy5wYXRjaFZhbHVlKHNlbGVjdGVkKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm11bHRpcGxlRGV2aWNlRkMudmFsdWUubGVuZ3RoID09IHRoaXMudG90YWxEZXZpY2VDb3VudCkge1xuICAgICAgICAgICAgdGhpcy5hbGxEZXZpY2VJRC5zcGxpY2UoMCwgMCwgLTEpO1xuICAgICAgICAgICAgdGhpcy5tdWx0aXBsZURldmljZUZDLnBhdGNoVmFsdWUodGhpcy5hbGxEZXZpY2VJRCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJlZFNlbGVjdGVkID0gc2VsZWN0ZWQuZmlsdGVyKHMgPT4gcyAhPSAtMSk7XG4gICAgICAgICAgICB0aGlzLm11bHRpcGxlRGV2aWNlRkMucGF0Y2hWYWx1ZShmaWx0ZXJlZFNlbGVjdGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdEZpbHRlci5lbWl0KCk7XG4gICAgfVxuXG59IiwiPG1hdC1mb3JtLWZpZWxkICpuZ0lmPVwiZHJvcGRvd25UeXBlID09IGRyb3Bkb3duVHlwZUVudW0uU0lOR0xFX0RST1BET1dOXCIgY2xhc3M9XCJtYXRGaWVsZFdpZHRoMTAwXCJcbiAgICBbYXBwZWFyYW5jZV09XCJtYXRlcmlhbEZvcm1GaWVsZEFwcGVhcmFuY2UuRk9STV9GSUVMRF9BUFBFQVJBTkNFXCI+XG4gICAgPG1hdC1sYWJlbD5TZWxlY3QgZGV2aWNlPC9tYXQtbGFiZWw+XG4gICAgPG1hdC1zZWxlY3QgKHNlbGVjdGlvbkNoYW5nZSk9XCJvbkNoYW5nZSgkZXZlbnQudmFsdWUpXCIgW2Zvcm1Db250cm9sXT1cImRldmljZUZDXCIgcmVxdWlyZWQ+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJkZXZpY2VNICYmIGRldmljZU0ubGVuZ3RoID4gMCAmJiBkZXZpY2VNWzBdWydpZCddOyBlbHNlIG5vRGV2aWNlRm91bmRcIj5cbiAgICAgICAgICAgIDxtYXQtb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxuZ3gtbWF0LXNlbGVjdC1zZWFyY2ggW2Zvcm1Db250cm9sXT1cImRldmljZVNlYXJjaFV0aWwuZmlsdGVyRkNcIiBwbGFjZWhvbGRlckxhYmVsPVwiU2VhcmNoIGJ5IG5hbWVcIlxuICAgICAgICAgICAgICAgICAgICBub0VudHJpZXNGb3VuZExhYmVsPVwiTm8gbWF0Y2hpbmcgbmFtZSBmb3VuZC5cIj5cbiAgICAgICAgICAgICAgICA8L25neC1tYXQtc2VsZWN0LXNlYXJjaD5cbiAgICAgICAgICAgIDwvbWF0LW9wdGlvbj5cbiAgICAgICAgICAgIDxtYXQtb3B0aW9uICpuZ0Zvcj1cImxldCBkZXZpY2Ugb2YgZGV2aWNlU2VhcmNoVXRpbC5maWx0ZXJlZEVudGl0aWVzIHwgYXN5bmNcIiBbdmFsdWVdPVwiZGV2aWNlLmlkXCI+XG4gICAgICAgICAgICAgICAge3sgZGV2aWNlLm5hbWUgfX1cbiAgICAgICAgICAgIDwvbWF0LW9wdGlvbj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjbm9EZXZpY2VGb3VuZD5cbiAgICAgICAgICAgIDxtYXQtb3B0aW9uIGRpc2FibGVkPlxuICAgICAgICAgICAgICAgIHt7IGNvbW1vbkNvbnN0YW50Lk5PX0RBVEFfRk9VTkQgfX1cbiAgICAgICAgICAgIDwvbWF0LW9wdGlvbj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L21hdC1zZWxlY3Q+XG4gICAgPG1hdC1lcnJvciAqbmdJZj1cIiFlbnRpdHlJbnBcIj5cbiAgICAgICAgUGxlYXNlIHNlbGVjdCBlbnRpdHkgZmlyc3RcbiAgICA8L21hdC1lcnJvcj5cbiAgICA8bWF0LWVycm9yICpuZ0lmPVwiZGV2aWNlRkMudG91Y2hlZCAmJiBkZXZpY2VGQy5oYXNFcnJvcigncmVxdWlyZWQnKSAmJiBlbnRpdHlJbnBcIj5cbiAgICAgICAge3sgRm9ybUVycm9yRW51bS5SRVFVSVJFRCB9fVxuICAgIDwvbWF0LWVycm9yPlxuPC9tYXQtZm9ybS1maWVsZD5cblxuPG1hdC1mb3JtLWZpZWxkICpuZ0lmPVwiZHJvcGRvd25UeXBlID09IGRyb3Bkb3duVHlwZUVudW0uTVVMVElQTEVfRFJPUERPV05cIiBjbGFzcz1cIm1hdEZpZWxkV2lkdGgxMDBcIlxuICAgIFthcHBlYXJhbmNlXT1cIm1hdGVyaWFsRm9ybUZpZWxkQXBwZWFyYW5jZS5GT1JNX0ZJRUxEX0FQUEVBUkFOQ0VcIj5cbiAgICA8bWF0LWxhYmVsPlNlbGVjdCBkZXZpY2U8L21hdC1sYWJlbD5cblxuICAgIDxtYXQtc2VsZWN0IFtmb3JtQ29udHJvbF09XCJtdWx0aXBsZURldmljZUZDXCIgbXVsdGlwbGUgcmVxdWlyZWQ+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJkZXZpY2VNICYmIGRldmljZU0ubGVuZ3RoID4gMCAmJiBkZXZpY2VNWzBdWydpZCddOyBlbHNlIG5vRGF0YU9wdGlvblwiPlxuICAgICAgICAgICAgPG5neC1tYXQtc2VsZWN0LXNlYXJjaCBbZm9ybUNvbnRyb2xdPVwiZGV2aWNlU2VhcmNoVXRpbC5maWx0ZXJGQ1wiIHBsYWNlaG9sZGVyTGFiZWw9XCJTZWFyY2ggYnkgbmFtZVwiXG4gICAgICAgICAgICAgICAgbm9FbnRyaWVzRm91bmRMYWJlbD1cIk5vIG1hdGNoaW5nIG5hbWUgZm91bmQuXCI+XG4gICAgICAgICAgICA8L25neC1tYXQtc2VsZWN0LXNlYXJjaD5cbiAgICAgICAgICAgIDxtYXQtb3B0aW9uIFt2YWx1ZV09XCItMVwiIChjbGljayk9XCJzZWxlY3RBbGxEZXZpY2VzKClcIiBbaGlkZGVuXT1cImRldmljZVNlYXJjaFV0aWwuZmlsdGVyRkMudmFsdWVcIj5cbiAgICAgICAgICAgICAgICBTZWxlY3QgYWxsXG4gICAgICAgICAgICA8L21hdC1vcHRpb24+XG4gICAgICAgICAgICA8bWF0LW9wdGlvbiAqbmdGb3I9XCJsZXQgZGV2aWNlIG9mIGRldmljZVNlYXJjaFV0aWwuZmlsdGVyZWRFbnRpdGllcyB8IGFzeW5jXCIgW3ZhbHVlXT1cImRldmljZS5pZFwiXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cInNlbGVjdGVkRGV2aWNlcygpXCI+XG4gICAgICAgICAgICAgICAge3sgZGV2aWNlLm5hbWUgfX1cbiAgICAgICAgICAgIDwvbWF0LW9wdGlvbj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjbm9EYXRhT3B0aW9uPlxuICAgICAgICAgICAgPG1hdC1vcHRpb24gZGlzYWJsZWQ+XG4gICAgICAgICAgICAgICAge3sgY29tbW9uQ29uc3RhbnQuTk9fREFUQV9GT1VORCB9fVxuICAgICAgICAgICAgPC9tYXQtb3B0aW9uPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvbWF0LXNlbGVjdD5cblxuICAgIDxtYXQtZXJyb3IgKm5nSWY9XCIhZW50aXR5SW5wXCI+XG4gICAgICAgIFBsZWFzZSBzZWxlY3QgZW50aXR5IGZpcnN0XG4gICAgPC9tYXQtZXJyb3I+XG4gICAgPG1hdC1lcnJvciAqbmdJZj1cIm11bHRpcGxlRGV2aWNlRkMudG91Y2hlZCAmJiBtdWx0aXBsZURldmljZUZDLmhhc0Vycm9yKCdyZXF1aXJlZCcpICYmIGVudGl0eUlucFwiPlxuICAgICAgICB7eyBGb3JtRXJyb3JFbnVtLlJFUVVJUkVEIH19XG4gICAgPC9tYXQtZXJyb3I+XG48L21hdC1mb3JtLWZpZWxkPiJdfQ==