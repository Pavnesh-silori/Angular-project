import { __awaiter } from "tslib";
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { FormControl, Validators } from '@angular/forms';
import { DropdownTypeEnum } from '../../../enum/dropdown.enum';
import { Device } from '../../../model/device.model';
import { COMMON_CONSTANT, MaterialFormFieldAppearance, MatSelectSearchService } from '@library/tsc-common';
import * as i0 from "@angular/core";
import * as i1 from "@library/storage-service";
import * as i2 from "../../../service/device.service";
import * as i3 from "@angular/material/form-field";
import * as i4 from "@angular/material/select";
import * as i5 from "@angular/material/core";
import * as i6 from "ngx-mat-select-search";
import * as i7 from "@angular/common";
import * as i8 from "@angular/forms";
// /tsc-library/
export class DeviceComponent {
    constructor(storageService, deviceService) {
        this.storageService = storageService;
        this.deviceService = deviceService;
        this.commonConstant = COMMON_CONSTANT;
        this.materialFormFieldAppearance = MaterialFormFieldAppearance;
        this.dropdownTypeEnum = DropdownTypeEnum;
        this.deviceM = [new Device()];
        this.allDeviceID = [];
        this.totalDeviceCount = 0;
        this.deviceFC = new FormControl('', [Validators.required]);
        this.multipleDeviceFC = new FormControl([], [Validators.required]);
        this.deviceSearchUtil = new MatSelectSearchService(['name']);
        this.emitFilter = new EventEmitter();
    }
    ngOnInit() {
        this.orgID = this.storageService.getStorage('currentOrgID');
    }
    ngOnChanges(changes) {
        var _a;
        if (changes.dropdownTypeInp && this.dropdownTypeInp) {
            this.dropdownType = this.dropdownTypeInp;
        }
        if (this.entityInp && ((_a = this.entityInp) === null || _a === void 0 ? void 0 : _a.length) != 0) {
            if (changes.entityInp) {
                this.getDevicesByEntityID(this.entityInp);
                this.deviceFC.patchValue(null);
                this.emitFilter.emit();
            }
        }
    }
    getDevicesByEntityID(entityID) {
        return __awaiter(this, void 0, void 0, function* () {
            let requestBody = {};
            requestBody['entityID'] = entityID;
            this.deviceM = (yield this.deviceService.getDevicesByEntityID(this.orgID, requestBody));
            this.deviceSearchUtil.entityArr = this.deviceM;
            this.deviceSearchUtil.createSubscription();
            this.totalDeviceCount = this.deviceM.length;
            this.deviceM.forEach(device => this.allDeviceID.push(device['id']));
            this.emitFilter.emit();
        });
    }
    onChange(selectedDevice) {
        this.deviceFC.patchValue(selectedDevice);
        this.emitFilter.emit();
    }
    selectAllDevices() {
        if (!this.multipleDeviceFC.value.includes(-1)) {
            this.multipleDeviceFC.reset([]);
            return;
        }
        this.multipleDeviceFC.setValue([-1, ...this.allDeviceID]);
        this.emitFilter.emit();
    }
    selectedDevices() {
        const selected = this.multipleDeviceFC.value;
        if (selected.includes(-1)) {
            selected.shift();
            this.multipleDeviceFC.patchValue(selected);
        }
        else if (this.multipleDeviceFC.value.length == this.totalDeviceCount) {
            this.allDeviceID.splice(0, 0, -1);
            this.multipleDeviceFC.patchValue(this.allDeviceID);
        }
        else {
            const filteredSelected = selected.filter(s => s != -1);
            this.multipleDeviceFC.patchValue(filteredSelected);
        }
        this.emitFilter.emit();
    }
}
DeviceComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: DeviceComponent, deps: [{ token: i1.StorageService }, { token: i2.DeviceService }], target: i0.ɵɵFactoryTarget.Component });
DeviceComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: DeviceComponent, selector: "lib-device", inputs: { dropdownTypeInp: "dropdownTypeInp", entityInp: "entityInp" }, outputs: { emitFilter: "emitFilter" }, usesOnChanges: true, ngImport: i0, template: "<mat-form-field *ngIf=\"dropdownType == dropdownTypeEnum.SINGLE_DROPDOWN\" class=\"matFieldWidth100\"\n    [appearance]=\"materialFormFieldAppearance.FORM_FIELD_APPEARANCE\">\n    <mat-label>Select device</mat-label>\n    <mat-select (selectionChange)=\"onChange($event.value)\" [formControl]=\"deviceFC\" required>\n        <ng-container *ngIf=\"deviceM && deviceM.length > 0 && deviceM[0]['id']; else noDeviceFound\">\n            <mat-option>\n                <ngx-mat-select-search [formControl]=\"deviceSearchUtil.filterFC\" placeholderLabel=\"Search by name\"\n                    noEntriesFoundLabel=\"No matching name found.\">\n                </ngx-mat-select-search>\n            </mat-option>\n            <mat-option *ngFor=\"let device of deviceSearchUtil.filteredEntities | async\" [value]=\"device.id\">\n                {{ device.name }}\n            </mat-option>\n        </ng-container>\n        <ng-template #noDeviceFound>\n            <mat-option disabled>\n                {{ commonConstant.NO_DATA_FOUND }}\n            </mat-option>\n        </ng-template>\n    </mat-select>\n    <mat-error *ngIf=\"!entityInp\">\n        Please select entity first\n    </mat-error>\n    <mat-error\n        *ngIf=\"deviceFC.touched && deviceFC.hasError('required') && entityInp\">\n        Select device\n    </mat-error>\n</mat-form-field>\n\n<mat-form-field *ngIf=\"dropdownType == dropdownTypeEnum.MULTIPLE_DROPDOWN\" class=\"matFieldWidth100\"\n    [appearance]=\"materialFormFieldAppearance.FORM_FIELD_APPEARANCE\">\n    <mat-label>Select device</mat-label>\n    <ng-container *ngIf=\"deviceM && deviceM.length > 0 && deviceM[0]['id']; else noDataOption\">\n        <mat-select [formControl]=\"multipleDeviceFC\" multiple required>\n            <ngx-mat-select-search [formControl]=\"deviceSearchUtil.filterFC\" placeholderLabel=\"Search by name\"\n                noEntriesFoundLabel=\"No matching name found.\">\n            </ngx-mat-select-search>\n            <mat-option [value]=\"-1\" (click)=\"selectAllDevices()\"  [hidden]=\"deviceSearchUtil.filterFC.value\">\n                Select all\n            </mat-option>\n            <mat-option *ngFor=\"let device of deviceSearchUtil.filteredEntities | async\" [value]=\"device.id\"\n                (click)=\"selectedDevices()\">\n                {{ device.name }}\n            </mat-option>\n        </mat-select>\n    </ng-container>\n    <ng-template #noDataOption>\n        <mat-select [formControl]=\"multipleDeviceFC\">\n            <mat-option disabled>\n                {{ commonConstant.NO_DATA_FOUND }}\n            </mat-option>\n        </mat-select>\n    </ng-template>\n    <mat-error *ngIf=\"!entityInp\">\n        Please select entity first\n    </mat-error>\n    <mat-error *ngIf=\"multipleDeviceFC.touched && multipleDeviceFC.hasError('required') && entityInp\">\n        Select device\n    </mat-error>\n</mat-form-field>", components: [{ type: i3.MatFormField, selector: "mat-form-field", inputs: ["color", "floatLabel", "appearance", "hideRequiredMarker", "hintLabel"], exportAs: ["matFormField"] }, { type: i4.MatSelect, selector: "mat-select", inputs: ["disabled", "disableRipple", "tabIndex"], exportAs: ["matSelect"] }, { type: i5.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { type: i6.MatSelectSearchComponent, selector: "ngx-mat-select-search", inputs: ["placeholderLabel", "type", "closeIcon", "closeSvgIcon", "noEntriesFoundLabel", "indexAndLengthScreenReaderText", "clearSearchInput", "searching", "disableInitialFocus", "enableClearOnEscapePressed", "preventHomeEndKeyPropagation", "disableScrollToActiveOnOptionsChanged", "ariaLabel", "showToggleAllCheckbox", "toggleAllCheckboxChecked", "toggleAllCheckboxIndeterminate", "toggleAllCheckboxTooltipMessage", "toogleAllCheckboxTooltipPosition", "hideClearSearchButton", "alwaysRestoreSelectedOptionsMulti"], outputs: ["toggleAll"] }], directives: [{ type: i7.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.MatLabel, selector: "mat-label" }, { type: i8.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i8.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i8.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { type: i7.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.MatError, selector: "mat-error", inputs: ["id"] }], pipes: { "async": i7.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: DeviceComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'lib-device',
                    templateUrl: './device.component.html',
                    styles: []
                }]
        }], ctorParameters: function () { return [{ type: i1.StorageService }, { type: i2.DeviceService }]; }, propDecorators: { dropdownTypeInp: [{
                type: Input
            }], entityInp: [{
                type: Input
            }], emitFilter: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGV2aWNlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2xpYnJhcnkvdHNjLWxpdGUvc3JjL2xpYi90c2MvY29tcG9uZW50L2Ryb3Bkb3duL2RldmljZS9kZXZpY2UuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbGlicmFyeS90c2MtbGl0ZS9zcmMvbGliL3RzYy9jb21wb25lbnQvZHJvcGRvd24vZGV2aWNlL2RldmljZS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFVLE1BQU0sRUFBaUIsTUFBTSxlQUFlLENBQUM7QUFFOUYsT0FBTyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUV6RCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUUvRCxPQUFPLEVBQUUsTUFBTSxFQUFXLE1BQU0sNkJBQTZCLENBQUM7QUFNOUQsT0FBTyxFQUFFLGVBQWUsRUFBRSwyQkFBMkIsRUFBRSxzQkFBc0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDOzs7Ozs7Ozs7O0FBQzNHLGdCQUFnQjtBQVNoQixNQUFNLE9BQU8sZUFBZTtJQTJCeEIsWUFDWSxjQUE4QixFQUM5QixhQUE0QjtRQUQ1QixtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7UUFDOUIsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFyQnhDLG1CQUFjLEdBQUcsZUFBZSxDQUFDO1FBQ2pDLGdDQUEyQixHQUFHLDJCQUEyQixDQUFDO1FBQzFELHFCQUFnQixHQUFHLGdCQUFnQixDQUFDO1FBRXBDLFlBQU8sR0FBRyxDQUFDLElBQUksTUFBTSxFQUFFLENBQUMsQ0FBQztRQUl6QixnQkFBVyxHQUFVLEVBQUUsQ0FBQztRQUN4QixxQkFBZ0IsR0FB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N0MsSUFBSSxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDdkIsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ2pCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDOUM7YUFBTSxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtZQUNwRSxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbEMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDdEQ7YUFBTTtZQUNILE1BQU0sZ0JBQWdCLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztTQUN0RDtRQUVELElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDM0IsQ0FBQzs7NkdBOUZRLGVBQWU7aUdBQWYsZUFBZSxzTEN0QjVCLG8yRkEyRGlCOzRGRHJDSixlQUFlO2tCQVAzQixTQUFTO21CQUFDO29CQUNQLFFBQVEsRUFBRSxZQUFZO29CQUN0QixXQUFXLEVBQUUseUJBQXlCO29CQUN0QyxNQUFNLEVBQUUsRUFDUDtpQkFDSjtpSUFLRyxlQUFlO3NCQURkLEtBQUs7Z0JBSU4sU0FBUztzQkFEUixLQUFLO2dCQW9CTixVQUFVO3NCQURULE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uSW5pdCwgT3V0cHV0LCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEZvcm1Db250cm9sLCBWYWxpZGF0b3JzIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBEcm9wZG93blR5cGVFbnVtIH0gZnJvbSAnLi4vLi4vLi4vZW51bS9kcm9wZG93bi5lbnVtJztcblxuaW1wb3J0IHsgRGV2aWNlLCBEZXZpY2VNIH0gZnJvbSAnLi4vLi4vLi4vbW9kZWwvZGV2aWNlLm1vZGVsJztcblxuaW1wb3J0IHsgRGV2aWNlU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3NlcnZpY2UvZGV2aWNlLnNlcnZpY2UnO1xuXG4vLyB0c2MtbGlicmFyeVxuaW1wb3J0IHsgU3RvcmFnZVNlcnZpY2UgfSBmcm9tICdAbGlicmFyeS9zdG9yYWdlLXNlcnZpY2UnO1xuaW1wb3J0IHsgQ09NTU9OX0NPTlNUQU5ULCBNYXRlcmlhbEZvcm1GaWVsZEFwcGVhcmFuY2UsIE1hdFNlbGVjdFNlYXJjaFNlcnZpY2UgfSBmcm9tICdAbGlicmFyeS90c2MtY29tbW9uJztcbi8vIC90c2MtbGlicmFyeS9cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdsaWItZGV2aWNlJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZGV2aWNlLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZXM6IFtcbiAgICBdXG59KVxuXG5leHBvcnQgY2xhc3MgRGV2aWNlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICAgIEBJbnB1dCgpXG4gICAgZHJvcGRvd25UeXBlSW5wOiBEcm9wZG93blR5cGVFbnVtO1xuXG4gICAgQElucHV0KClcbiAgICBlbnRpdHlJbnA6IGFueTtcblxuICAgIGNvbW1vbkNvbnN0YW50ID0gQ09NTU9OX0NPTlNUQU5UO1xuICAgIG1hdGVyaWFsRm9ybUZpZWxkQXBwZWFyYW5jZSA9IE1hdGVyaWFsRm9ybUZpZWxkQXBwZWFyYW5jZTtcbiAgICBkcm9wZG93blR5cGVFbnVtID0gRHJvcGRvd25UeXBlRW51bTtcblxuICAgIGRldmljZU0gPSBbbmV3IERldmljZSgpXTtcblxuICAgIG9yZ0lEOiBhbnk7XG4gICAgZHJvcGRvd25UeXBlOiBhbnk7XG4gICAgYWxsRGV2aWNlSUQ6IGFueVtdID0gW107XG4gICAgdG90YWxEZXZpY2VDb3VudDogbnVtYmVyID0gMDtcblxuICAgIGRldmljZUZDOiBGb3JtQ29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCgnJywgW1ZhbGlkYXRvcnMucmVxdWlyZWRdKTtcbiAgICBtdWx0aXBsZURldmljZUZDOiBGb3JtQ29udHJvbCA9IG5ldyBGb3JtQ29udHJvbChbXSwgW1ZhbGlkYXRvcnMucmVxdWlyZWRdKTtcblxuICAgIGRldmljZVNlYXJjaFV0aWw6IE1hdFNlbGVjdFNlYXJjaFNlcnZpY2UgPSBuZXcgTWF0U2VsZWN0U2VhcmNoU2VydmljZShbJ25hbWUnXSk7XG5cbiAgICBAT3V0cHV0KClcbiAgICBlbWl0RmlsdGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgc3RvcmFnZVNlcnZpY2U6IFN0b3JhZ2VTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIGRldmljZVNlcnZpY2U6IERldmljZVNlcnZpY2VcbiAgICApIHsgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMub3JnSUQgPSB0aGlzLnN0b3JhZ2VTZXJ2aWNlLmdldFN0b3JhZ2UoJ2N1cnJlbnRPcmdJRCcpO1xuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuZHJvcGRvd25UeXBlSW5wICYmIHRoaXMuZHJvcGRvd25UeXBlSW5wKSB7XG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duVHlwZSA9IHRoaXMuZHJvcGRvd25UeXBlSW5wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZW50aXR5SW5wICYmIHRoaXMuZW50aXR5SW5wPy5sZW5ndGggIT0gMCkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMuZW50aXR5SW5wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXREZXZpY2VzQnlFbnRpdHlJRCh0aGlzLmVudGl0eUlucCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRldmljZUZDLnBhdGNoVmFsdWUobnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0RmlsdGVyLmVtaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGdldERldmljZXNCeUVudGl0eUlEKGVudGl0eUlEKSB7XG4gICAgICAgIGxldCByZXF1ZXN0Qm9keSA9IHt9O1xuICAgICAgICByZXF1ZXN0Qm9keVsnZW50aXR5SUQnXSA9IGVudGl0eUlEO1xuXG4gICAgICAgIHRoaXMuZGV2aWNlTSA9IDxEZXZpY2VNW10+YXdhaXQgdGhpcy5kZXZpY2VTZXJ2aWNlLmdldERldmljZXNCeUVudGl0eUlEKHRoaXMub3JnSUQsIHJlcXVlc3RCb2R5KTtcblxuICAgICAgICB0aGlzLmRldmljZVNlYXJjaFV0aWwuZW50aXR5QXJyID0gdGhpcy5kZXZpY2VNO1xuICAgICAgICB0aGlzLmRldmljZVNlYXJjaFV0aWwuY3JlYXRlU3Vic2NyaXB0aW9uKCk7XG5cbiAgICAgICAgdGhpcy50b3RhbERldmljZUNvdW50ID0gdGhpcy5kZXZpY2VNLmxlbmd0aDtcbiAgICAgICAgdGhpcy5kZXZpY2VNLmZvckVhY2goZGV2aWNlID0+IHRoaXMuYWxsRGV2aWNlSUQucHVzaChkZXZpY2VbJ2lkJ10pKTtcbiAgICAgICAgdGhpcy5lbWl0RmlsdGVyLmVtaXQoKTtcbiAgICB9XG5cbiAgICBvbkNoYW5nZShzZWxlY3RlZERldmljZSkge1xuICAgICAgICB0aGlzLmRldmljZUZDLnBhdGNoVmFsdWUoc2VsZWN0ZWREZXZpY2UpO1xuICAgICAgICB0aGlzLmVtaXRGaWx0ZXIuZW1pdCgpO1xuICAgIH1cblxuICAgIHNlbGVjdEFsbERldmljZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5tdWx0aXBsZURldmljZUZDLnZhbHVlLmluY2x1ZGVzKC0xKSkge1xuICAgICAgICAgICAgdGhpcy5tdWx0aXBsZURldmljZUZDLnJlc2V0KFtdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm11bHRpcGxlRGV2aWNlRkMuc2V0VmFsdWUoWy0xLCAuLi50aGlzLmFsbERldmljZUlEXSk7XG4gICAgICAgIHRoaXMuZW1pdEZpbHRlci5lbWl0KCk7XG4gICAgfVxuXG4gICAgc2VsZWN0ZWREZXZpY2VzKCkge1xuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMubXVsdGlwbGVEZXZpY2VGQy52YWx1ZTtcblxuICAgICAgICBpZiAoc2VsZWN0ZWQuaW5jbHVkZXMoLTEpKSB7XG4gICAgICAgICAgICBzZWxlY3RlZC5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5tdWx0aXBsZURldmljZUZDLnBhdGNoVmFsdWUoc2VsZWN0ZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubXVsdGlwbGVEZXZpY2VGQy52YWx1ZS5sZW5ndGggPT0gdGhpcy50b3RhbERldmljZUNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLmFsbERldmljZUlELnNwbGljZSgwLCAwLCAtMSk7XG4gICAgICAgICAgICB0aGlzLm11bHRpcGxlRGV2aWNlRkMucGF0Y2hWYWx1ZSh0aGlzLmFsbERldmljZUlEKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkU2VsZWN0ZWQgPSBzZWxlY3RlZC5maWx0ZXIocyA9PiBzICE9IC0xKTtcbiAgICAgICAgICAgIHRoaXMubXVsdGlwbGVEZXZpY2VGQy5wYXRjaFZhbHVlKGZpbHRlcmVkU2VsZWN0ZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0RmlsdGVyLmVtaXQoKTtcbiAgICB9XG5cbn0iLCI8bWF0LWZvcm0tZmllbGQgKm5nSWY9XCJkcm9wZG93blR5cGUgPT0gZHJvcGRvd25UeXBlRW51bS5TSU5HTEVfRFJPUERPV05cIiBjbGFzcz1cIm1hdEZpZWxkV2lkdGgxMDBcIlxuICAgIFthcHBlYXJhbmNlXT1cIm1hdGVyaWFsRm9ybUZpZWxkQXBwZWFyYW5jZS5GT1JNX0ZJRUxEX0FQUEVBUkFOQ0VcIj5cbiAgICA8bWF0LWxhYmVsPlNlbGVjdCBkZXZpY2U8L21hdC1sYWJlbD5cbiAgICA8bWF0LXNlbGVjdCAoc2VsZWN0aW9uQ2hhbmdlKT1cIm9uQ2hhbmdlKCRldmVudC52YWx1ZSlcIiBbZm9ybUNvbnRyb2xdPVwiZGV2aWNlRkNcIiByZXF1aXJlZD5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImRldmljZU0gJiYgZGV2aWNlTS5sZW5ndGggPiAwICYmIGRldmljZU1bMF1bJ2lkJ107IGVsc2Ugbm9EZXZpY2VGb3VuZFwiPlxuICAgICAgICAgICAgPG1hdC1vcHRpb24+XG4gICAgICAgICAgICAgICAgPG5neC1tYXQtc2VsZWN0LXNlYXJjaCBbZm9ybUNvbnRyb2xdPVwiZGV2aWNlU2VhcmNoVXRpbC5maWx0ZXJGQ1wiIHBsYWNlaG9sZGVyTGFiZWw9XCJTZWFyY2ggYnkgbmFtZVwiXG4gICAgICAgICAgICAgICAgICAgIG5vRW50cmllc0ZvdW5kTGFiZWw9XCJObyBtYXRjaGluZyBuYW1lIGZvdW5kLlwiPlxuICAgICAgICAgICAgICAgIDwvbmd4LW1hdC1zZWxlY3Qtc2VhcmNoPlxuICAgICAgICAgICAgPC9tYXQtb3B0aW9uPlxuICAgICAgICAgICAgPG1hdC1vcHRpb24gKm5nRm9yPVwibGV0IGRldmljZSBvZiBkZXZpY2VTZWFyY2hVdGlsLmZpbHRlcmVkRW50aXRpZXMgfCBhc3luY1wiIFt2YWx1ZV09XCJkZXZpY2UuaWRcIj5cbiAgICAgICAgICAgICAgICB7eyBkZXZpY2UubmFtZSB9fVxuICAgICAgICAgICAgPC9tYXQtb3B0aW9uPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG5nLXRlbXBsYXRlICNub0RldmljZUZvdW5kPlxuICAgICAgICAgICAgPG1hdC1vcHRpb24gZGlzYWJsZWQ+XG4gICAgICAgICAgICAgICAge3sgY29tbW9uQ29uc3RhbnQuTk9fREFUQV9GT1VORCB9fVxuICAgICAgICAgICAgPC9tYXQtb3B0aW9uPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvbWF0LXNlbGVjdD5cbiAgICA8bWF0LWVycm9yICpuZ0lmPVwiIWVudGl0eUlucFwiPlxuICAgICAgICBQbGVhc2Ugc2VsZWN0IGVudGl0eSBmaXJzdFxuICAgIDwvbWF0LWVycm9yPlxuICAgIDxtYXQtZXJyb3JcbiAgICAgICAgKm5nSWY9XCJkZXZpY2VGQy50b3VjaGVkICYmIGRldmljZUZDLmhhc0Vycm9yKCdyZXF1aXJlZCcpICYmIGVudGl0eUlucFwiPlxuICAgICAgICBTZWxlY3QgZGV2aWNlXG4gICAgPC9tYXQtZXJyb3I+XG48L21hdC1mb3JtLWZpZWxkPlxuXG48bWF0LWZvcm0tZmllbGQgKm5nSWY9XCJkcm9wZG93blR5cGUgPT0gZHJvcGRvd25UeXBlRW51bS5NVUxUSVBMRV9EUk9QRE9XTlwiIGNsYXNzPVwibWF0RmllbGRXaWR0aDEwMFwiXG4gICAgW2FwcGVhcmFuY2VdPVwibWF0ZXJpYWxGb3JtRmllbGRBcHBlYXJhbmNlLkZPUk1fRklFTERfQVBQRUFSQU5DRVwiPlxuICAgIDxtYXQtbGFiZWw+U2VsZWN0IGRldmljZTwvbWF0LWxhYmVsPlxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJkZXZpY2VNICYmIGRldmljZU0ubGVuZ3RoID4gMCAmJiBkZXZpY2VNWzBdWydpZCddOyBlbHNlIG5vRGF0YU9wdGlvblwiPlxuICAgICAgICA8bWF0LXNlbGVjdCBbZm9ybUNvbnRyb2xdPVwibXVsdGlwbGVEZXZpY2VGQ1wiIG11bHRpcGxlIHJlcXVpcmVkPlxuICAgICAgICAgICAgPG5neC1tYXQtc2VsZWN0LXNlYXJjaCBbZm9ybUNvbnRyb2xdPVwiZGV2aWNlU2VhcmNoVXRpbC5maWx0ZXJGQ1wiIHBsYWNlaG9sZGVyTGFiZWw9XCJTZWFyY2ggYnkgbmFtZVwiXG4gICAgICAgICAgICAgICAgbm9FbnRyaWVzRm91bmRMYWJlbD1cIk5vIG1hdGNoaW5nIG5hbWUgZm91bmQuXCI+XG4gICAgICAgICAgICA8L25neC1tYXQtc2VsZWN0LXNlYXJjaD5cbiAgICAgICAgICAgIDxtYXQtb3B0aW9uIFt2YWx1ZV09XCItMVwiIChjbGljayk9XCJzZWxlY3RBbGxEZXZpY2VzKClcIiAgW2hpZGRlbl09XCJkZXZpY2VTZWFyY2hVdGlsLmZpbHRlckZDLnZhbHVlXCI+XG4gICAgICAgICAgICAgICAgU2VsZWN0IGFsbFxuICAgICAgICAgICAgPC9tYXQtb3B0aW9uPlxuICAgICAgICAgICAgPG1hdC1vcHRpb24gKm5nRm9yPVwibGV0IGRldmljZSBvZiBkZXZpY2VTZWFyY2hVdGlsLmZpbHRlcmVkRW50aXRpZXMgfCBhc3luY1wiIFt2YWx1ZV09XCJkZXZpY2UuaWRcIlxuICAgICAgICAgICAgICAgIChjbGljayk9XCJzZWxlY3RlZERldmljZXMoKVwiPlxuICAgICAgICAgICAgICAgIHt7IGRldmljZS5uYW1lIH19XG4gICAgICAgICAgICA8L21hdC1vcHRpb24+XG4gICAgICAgIDwvbWF0LXNlbGVjdD5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8bmctdGVtcGxhdGUgI25vRGF0YU9wdGlvbj5cbiAgICAgICAgPG1hdC1zZWxlY3QgW2Zvcm1Db250cm9sXT1cIm11bHRpcGxlRGV2aWNlRkNcIj5cbiAgICAgICAgICAgIDxtYXQtb3B0aW9uIGRpc2FibGVkPlxuICAgICAgICAgICAgICAgIHt7IGNvbW1vbkNvbnN0YW50Lk5PX0RBVEFfRk9VTkQgfX1cbiAgICAgICAgICAgIDwvbWF0LW9wdGlvbj5cbiAgICAgICAgPC9tYXQtc2VsZWN0PlxuICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPG1hdC1lcnJvciAqbmdJZj1cIiFlbnRpdHlJbnBcIj5cbiAgICAgICAgUGxlYXNlIHNlbGVjdCBlbnRpdHkgZmlyc3RcbiAgICA8L21hdC1lcnJvcj5cbiAgICA8bWF0LWVycm9yICpuZ0lmPVwibXVsdGlwbGVEZXZpY2VGQy50b3VjaGVkICYmIG11bHRpcGxlRGV2aWNlRkMuaGFzRXJyb3IoJ3JlcXVpcmVkJykgJiYgZW50aXR5SW5wXCI+XG4gICAgICAgIFNlbGVjdCBkZXZpY2VcbiAgICA8L21hdC1lcnJvcj5cbjwvbWF0LWZvcm0tZmllbGQ+Il19