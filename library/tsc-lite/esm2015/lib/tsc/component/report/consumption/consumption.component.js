import { __awaiter } from "tslib";
import { Component, ViewChild } from '@angular/core';
import { Validators } from '@angular/forms';
import { ReportErrorEnum } from '../../../enum/error.enum';
import { Alert } from '../../../model/alert.model';
import { MeterData } from '../../../model/aggregate-data.model';
// tsc-library
import { ButtonLabelEnum, COMMON_CONSTANT, FileTypeEnum, FormErrorEnum, InvalidForm, MATERIAL_CONSTANT, MaterialFormFieldAppearance, MessageAlertIconEnum, MessageAlertTypeEnum, Static } from '@library/tsc-common';
import { DateFormatEnum, DateInputTypeEnum, DateTypeEnum } from '@library/date';
import { ToastrColor } from '@library/toastr-service';
import { ApplicationKeyID } from '@library/application-service';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
import * as i2 from "@angular/forms";
import * as i3 from "@library/storage-service";
import * as i4 from "@library/toastr-service";
import * as i5 from "../../../service/alert.service";
import * as i6 from "../../../service/source.service";
import * as i7 from "../../../service/parameter.service";
import * as i8 from "../../../service/aggregate-data.service";
import * as i9 from "../../../service/report.service";
import * as i10 from "@angular/material/slide-toggle";
import * as i11 from "@angular/material/button-toggle";
import * as i12 from "@library/date";
import * as i13 from "@angular/material/form-field";
import * as i14 from "@angular/material/select";
import * as i15 from "@angular/material/core";
import * as i16 from "../../_shared/download-report/download-report.component";
import * as i17 from "@library/tsc-common";
import * as i18 from "@angular/common";
// /tsc-library/
export class ConsumptionReportComponent {
    constructor(router, formBuilder, storageService, toastService, alertService, sourceService, parameterService, aggregateDataService, reportService) {
        this.router = router;
        this.formBuilder = formBuilder;
        this.storageService = storageService;
        this.toastService = toastService;
        this.alertService = alertService;
        this.sourceService = sourceService;
        this.parameterService = parameterService;
        this.aggregateDataService = aggregateDataService;
        this.reportService = reportService;
        this.MATERIAL_CONSTANT = MATERIAL_CONSTANT;
        this.COMMON_CONSTANT = COMMON_CONSTANT;
        this.MaterialFormFieldAppearance = MaterialFormFieldAppearance;
        this.ButtonLabelEnum = ButtonLabelEnum;
        this.DateFormatEnum = DateFormatEnum;
        this.DateInputTypeEnum = DateInputTypeEnum;
        this.DateTypeEnum = DateTypeEnum;
        this.FileTypeEnum = FileTypeEnum;
        this.FormErrorEnum = FormErrorEnum;
        this.reportData = [new MeterData()];
        this.showAlert = false;
        this.showLoader = false;
        this.sourceConsumerType = [new Static()];
        this.reportAlertObj = new Alert();
        this.errorHandling = (formGroup, controlPath, error) => {
            return formGroup.get(controlPath).hasError(error);
        };
    }
    ngOnInit() {
        this.orgID = this.storageService.getStorage('currentOrgID');
        this.timezone = this.storageService.getStorage('timezone');
        this.applicationKeyID = this.storageService.getStorage('applicationKeyID');
        if (this.applicationKeyID == ApplicationKeyID.ENERGY_KEY_ID) {
            this.pageTitle = "Energy Consumption Report";
        }
        else if (this.applicationKeyID == ApplicationKeyID.WATER_KEY_ID) {
            this.pageTitle = "Water Consumption Report";
        }
        this.reportFGInit();
        if (this.reportFG.get('sourceConsumer.type').value == 'SOURCE') {
            this.getSourceConsumerType('source');
        }
        else {
            this.getSourceConsumerType('load');
        }
        this.getConsumptionParameter();
    }
    reportFGInit() {
        this.reportFG = this.formBuilder.group({
            startDate: [, Validators.required],
            endDate: [, Validators.required],
            sourceConsumer: this.formBuilder.group({
                type: ['SOURCE', Validators.required],
                keyID: [, Validators.required]
            }),
            params: this.formBuilder.group({
                name: ['', Validators.required],
                dsAgg: ['sum', Validators.required],
                agg: ['sum', Validators.required]
            }),
            interval: [, Validators.required]
        });
        this.reportFG.get('sourceConsumer.type').valueChanges.subscribe((value) => __awaiter(this, void 0, void 0, function* () {
            if (value == 'SOURCE') {
                this.getSourceConsumerType('source');
            }
            else if (value == 'CONSUMER') {
                this.getSourceConsumerType('load');
            }
        }));
    }
    getSourceConsumerType(sourceConsumerType) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestData = {
                type: sourceConsumerType
            };
            this.sourceConsumerType = (yield this.sourceService.getSourceConsumerType(this.orgID, requestData));
        });
    }
    dateInpChange() {
        let startDate = this.monthDateInput.startDateFC.value;
        let endDate = this.monthDateInput.endDateFC.value;
        this.reportFG.get('startDate').patchValue(startDate);
        this.reportFG.get('endDate').patchValue(endDate);
    }
    getConsumptionParameter() {
        return __awaiter(this, void 0, void 0, function* () {
            const consumptionParamM = yield this.parameterService.getConsumptionParameter(this.orgID);
            this.consumptionParamM = consumptionParamM.consumptionParameter;
        });
    }
    reportSubmit() {
        const formValue = this.reportFG.value;
        const modifiedValue = Object.assign(Object.assign({}, formValue), { params: [formValue.params] });
        this.alertService.resetAlertProperties(this.reportAlertObj);
        if (this.reportFG.invalid) {
            console.log('Invalid form:', this.reportFG.value);
            this.toastService.openToast(InvalidForm.INVALID_FORM_TITLE, InvalidForm.INVALID_FORM_MESSAGE, ToastrColor.ERROR);
            return;
        }
        else {
            this.showLoader = true;
            this.alertService.resetAlertProperties(this.reportAlertObj);
            this.viewReport(modifiedValue);
        }
    }
    viewReport(modifiedValue) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const result = yield this.aggregateDataService.getMeterAggregateDataForReport(this.orgID, modifiedValue);
                if (result && result.length > 0 && result[0]['date']) {
                    this.reportData = result;
                }
                else {
                    this.alertService.setAlertProperties(this.reportAlertObj, ReportErrorEnum.DATA_NOT_FOUND_LABEL, ReportErrorEnum.DATA_NOT_FOUND_MESSAGE, MessageAlertTypeEnum.WARNING, MessageAlertIconEnum.WARNING_ICON);
                }
            }
            catch (error) {
                console.error("Error in viewReport()", error);
                this.alertService.setAlertProperties(this.reportAlertObj, ReportErrorEnum.INVALID_ERROR_LABEL, ReportErrorEnum.INVALID_ERROR_MESSAGE, MessageAlertTypeEnum.DANGER, MessageAlertIconEnum.DANGER_ICON);
            }
            finally {
                this.showLoader = false;
            }
        });
    }
    downloadReport(format) {
        return __awaiter(this, void 0, void 0, function* () {
            const formValue = this.reportFG.value;
            const modifiedValue = Object.assign(Object.assign({}, formValue), { params: [formValue.params] });
            this.alertService.resetAlertProperties(this.reportAlertObj);
            if (this.reportFG.invalid) {
                console.log('Invalid form:', this.reportFG.value);
                this.reportFG.markAllAsTouched();
                this.toastService.openToast(InvalidForm.INVALID_FORM_TITLE, InvalidForm.INVALID_FORM_MESSAGE, ToastrColor.ERROR);
                return;
            }
            this.showLoader = true;
            try {
                const requestData = {};
                requestData['request'] = modifiedValue;
                requestData['reportName'] = 'Consumption Report';
                requestData['reportFormat'] = format;
                yield this.reportService.downloadConsumptionReport(this.orgID, requestData);
            }
            catch (error) {
                console.error("Error in downloadConsumptionReport()", error);
            }
            finally {
                this.showLoader = false;
            }
        });
    }
    scheduleReport(value) {
        if (value) {
            const applicationName = this.applicationKeyID == ApplicationKeyID.WATER_KEY_ID ? 'water' : 'energy';
            this.router.navigate([`schedule-report/${applicationName}-consumption`]);
        }
    }
}
ConsumptionReportComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: ConsumptionReportComponent, deps: [{ token: i1.Router }, { token: i2.FormBuilder }, { token: i3.StorageService }, { token: i4.ToastrService }, { token: i5.AlertService }, { token: i6.SourceService }, { token: i7.ParameterService }, { token: i8.AggregateDataService }, { token: i9.ReportService }], target: i0.ɵɵFactoryTarget.Component });
ConsumptionReportComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: ConsumptionReportComponent, selector: "lib-consumption", viewQueries: [{ propertyName: "monthDateInput", first: true, predicate: ["monthDateInput"], descendants: true }], ngImport: i0, template: "<div class=\"card main-card cardOverwrite h100\">\n    <div class=\"headerContainer\">\n        <div class=\"headerLeftContainer\">\n            <div class=\"pageTitle\">{{ pageTitle }}</div>\n        </div>\n        <div class=\"headerRightContainer\">\n            <div class=\"headerRightContainerInner\">\n                <mat-slide-toggle (change)=\"scheduleReport($event.checked)\">Schedule report</mat-slide-toggle>\n            </div>\n        </div>\n    </div>\n\n    <div class=\"card-body\">\n        <form [formGroup]=\"reportFG\" (ngSubmit)=\"reportSubmit()\">\n            <div class=\"row\">\n                <div formGroupName=\"sourceConsumer\">\n                    <div class=\"col-sm-3\">\n                        <mat-button-toggle-group class=\"matBtnFilter\" formControlName=\"type\">\n                            <mat-button-toggle [value]=\"'SOURCE'\">Source</mat-button-toggle>\n                            <mat-button-toggle [value]=\"'CONSUMER'\">Consumer</mat-button-toggle>\n                        </mat-button-toggle-group>\n                        <mat-error class=\"textMatError ms-1\"\n                            *ngIf=\"errorHandling(reportFG, 'sourceConsumer.type', 'required')\">\n                            {{ FormErrorEnum.REQUIRED }}\n                        </mat-error>\n                    </div>\n                </div>\n            </div>\n\n            <div class=\"row mt-3\">\n                <div class=\"col-sm-3\">\n                    <lib-date-input #monthDateInput (emitFilter)=\"dateInpChange()\" [materialFieldWidthInp]=\"true\"\n                        [materialFormFieldAppearanceInp]=\"MaterialFormFieldAppearance.FORM_FIELD_APPEARANCE\"\n                        [isMandatoryFieldInp]=\"true\" [dateInputTypeInp]=\"DateInputTypeEnum.MONTH_INPUT\"\n                        [dateTypeInp]=\"DateTypeEnum.EXCLUSIVE\" [showDefaultDurationInp]=\"true\"\n                        [labelInp]=\"'Select date'\" [timezoneInp]=\"timezone\"></lib-date-input>\n                </div>\n\n                <div class=\"col-sm-3\">\n                    <mat-form-field class=\"matFieldWidth100\"\n                        [appearance]=\"MaterialFormFieldAppearance.FORM_FIELD_APPEARANCE\">\n                        <mat-label>Select aggregation</mat-label>\n                        <mat-select formControlName=\"interval\" required>\n                            <mat-option [value]=\"'DAILY'\">Daily</mat-option>\n                            <mat-option [value]=\"'MONTHLY'\">Monthly</mat-option>\n                        </mat-select>\n                        <mat-error *ngIf=\"errorHandling(reportFG, 'interval', 'required')\">\n                            {{ FormErrorEnum.REQUIRED }}\n                        </mat-error>\n                    </mat-form-field>\n                </div>\n\n\n                <div class=\"col-sm-3\">\n                    <div formGroupName=\"sourceConsumer\">\n                        <mat-form-field class=\"matFieldWidth100\"\n                            [appearance]=\"MaterialFormFieldAppearance.FORM_FIELD_APPEARANCE\">\n                            <mat-label> Select {{ reportFG.get('sourceConsumer.type').value == 'SOURCE' ? 'source' :\n                                'consumer' }} type</mat-label>\n\n                            <mat-select formControlName=\"keyID\" required>\n                                <ng-container\n                                    *ngIf=\"sourceConsumerType && sourceConsumerType.length > 0 && sourceConsumerType[0]['id']; else noSourceConsumerType\">\n                                    <mat-option *ngFor=\"let type of sourceConsumerType\" [value]=\"type.keyID\">\n                                        {{ type.name }}\n                                    </mat-option>\n                                </ng-container>\n\n                                <ng-template #noSourceConsumerType>\n                                    <mat-option disabled>\n                                        {{ COMMON_CONSTANT.NO_DATA_FOUND }}\n                                    </mat-option>\n                                </ng-template>\n                            </mat-select>\n\n                            <mat-error *ngIf=\"errorHandling(reportFG, 'sourceConsumer.keyID', 'required')\">\n                                {{ FormErrorEnum.REQUIRED }}\n                            </mat-error>\n                        </mat-form-field>\n                    </div>\n                </div>\n\n                <div class=\"col-sm-3\">\n                    <div formGroupName=\"params\">\n                        <mat-form-field class=\"matFieldWidth100\" [appearance]=\"MaterialFormFieldAppearance.FORM_FIELD_APPEARANCE\">\n                            <mat-label>Select consumption parameter</mat-label>\n\n                            <mat-select formControlName=\"name\" required>\n                                <ng-container\n                                    *ngIf=\"consumptionParamM && consumptionParamM.length > 0 && consumptionParamM[0]['id']; else noConsumptionParamM\">\n                                    <mat-option *ngFor=\"let param of consumptionParamM\" [value]=\"param.paramMetric\">\n                                        {{ param.label }}\n                                    </mat-option>\n                                </ng-container>\n\n                                <ng-template #noConsumptionParamM>\n                                    <mat-option disabled>\n                                        {{ COMMON_CONSTANT.NO_DATA_FOUND }}\n                                    </mat-option>\n                                </ng-template>\n                            </mat-select>\n\n                            <mat-error *ngIf=\"errorHandling(reportFG, 'params.name', 'required')\">\n                                {{ FormErrorEnum.REQUIRED }}\n                            </mat-error>\n                        </mat-form-field>\n                    </div>\n                </div>\n            </div>\n\n            <button class=\"d-none\" type=\"submit\" #formSubmitBtn></button>\n        </form>\n\n        <div class=\"row\">\n            <div class=\"col-sm-12\">\n                <div class=\"float-end\">\n                    <button class=\"btn btn-sm btn-primary\" (click)=\"formSubmitBtn.click()\" matRipple\n                        [matRippleCentered]=\"MATERIAL_CONSTANT.MAT_RIPPLE_CENTER\">\n                        {{ ButtonLabelEnum.READ_BTN_LABEL }}\n                    </button>\n                    <lib-download-report [excludeFileTypeInp]=\"FileTypeEnum.CSV\" (fileTypeEmitted)=\"downloadReport($event)\"></lib-download-report>\n                </div>\n            </div>\n        </div>\n\n        <div class=\"row mt-3\">\n            <div class=\"col-sm-12\">\n                <lib-message-alert *ngIf=\"reportAlertObj.showAlert\" [labelInp]=\"reportAlertObj.alertLabel\"\n                    [contentInp]=\"reportAlertObj.alertContent\" [messageAlertTypeInp]=\"reportAlertObj.messageAlertType\"\n                    [messageAlertIconInp]=\"reportAlertObj.messageAlertIcon\">\n                </lib-message-alert>\n            </div>\n        </div>\n\n        <div class=\"row mt-3\">\n            <div class=\"centerAlign\">\n                <lib-skeleton-loader *ngIf=\"showLoader\" [count]=\"3\" [appearance]=\"'circle'\"\n                    [theme]=\"{ height: '15px', width: '15px', 'background-color': '#e7ebf3' }\"></lib-skeleton-loader>\n            </div>\n        </div>\n\n        <div class=\"row mt-3\" *ngIf=\"reportData && reportData.length > 0 && reportData[0].date\">\n            <table class=\"table\">\n                <tbody>\n                    <tr class=\"tableHeader\">\n                        <td align=\"center\" class=\"fw-bold\"> Date </td>\n                        <td align=\"center\" class=\"fw-bold\"> Meter name </td>\n                        <td align=\"center\" class=\"fw-bold\"> Parameter name </td>\n                        <td align=\"center\" class=\"fw-bold\"> Meter start reading </td>\n                        <td align=\"center\" class=\"fw-bold\"> Meter end reading </td>\n                        <td align=\"center\" class=\"fw-bold\"> Consumption </td>\n                    </tr>\n                </tbody>\n                <tbody>\n                    <tr *ngFor=\"let data of reportData; let i = index\">\n                        <td align=\"center\" class=\"colWidthContainingDateTime\">{{ row?.date | date: 'dd-MMM-yyyy\n                            HH:mm:ss' }}</td>\n                        <td align=\"center\">{{ row?.meterName }}</td>\n                        <td align=\"center\">{{ row?.parameterName }}</td>\n                        <td align=\"center\">{{ row?.meterStartReading }}</td>\n                        <td align=\"center\">{{ row?.meterEndReading }}</td>\n                        <td align=\"center\">{{ row?.meterConsumption }}</td>\n                    </tr>\n                </tbody>\n            </table>\n        </div>\n    </div>\n</div>", components: [{ type: i10.MatSlideToggle, selector: "mat-slide-toggle", inputs: ["disabled", "disableRipple", "color", "tabIndex", "name", "id", "labelPosition", "aria-label", "aria-labelledby", "required", "checked", "aria-describedby"], outputs: ["change", "toggleChange"], exportAs: ["matSlideToggle"] }, { type: i11.MatButtonToggle, selector: "mat-button-toggle", inputs: ["disableRipple", "aria-labelledby", "tabIndex", "appearance", "checked", "disabled", "id", "name", "aria-label", "value"], outputs: ["change"], exportAs: ["matButtonToggle"] }, { type: i12.DateInputComponent, selector: "lib-date-input", inputs: ["materialFormFieldAppearanceInp", "materialFieldWidthInp", "frequencyInp", "dateInputTypeInp", "dateTypeInp", "timezoneInp", "labelInp", "rangeInp", "cdrFormatInp", "isMandatoryFieldInp", "showRangeInp", "showCdrRangeLabelInp", "showDefaultDurationInp", "showTimeInCDRInp"], outputs: ["emitFilter"] }, { type: i13.MatFormField, selector: "mat-form-field", inputs: ["color", "floatLabel", "appearance", "hideRequiredMarker", "hintLabel"], exportAs: ["matFormField"] }, { type: i14.MatSelect, selector: "mat-select", inputs: ["disabled", "disableRipple", "tabIndex"], exportAs: ["matSelect"] }, { type: i15.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { type: i16.DownloadReportComponent, selector: "lib-download-report", inputs: ["excludeFileTypeInp"], outputs: ["fileTypeEmitted"] }, { type: i17.MessageAlertComponent, selector: "lib-message-alert", inputs: ["messageAlertTypeInp", "messageAlertIconInp", "labelInp", "contentInp", "showCloseBtnInp"] }, { type: i17.SkeletonComponent, selector: "lib-skeleton-loader", inputs: ["count", "appearance", "theme"] }], directives: [{ type: i2.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i2.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i2.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i2.FormGroupName, selector: "[formGroupName]", inputs: ["formGroupName"] }, { type: i11.MatButtonToggleGroup, selector: "mat-button-toggle-group", inputs: ["appearance", "name", "vertical", "value", "multiple", "disabled"], outputs: ["valueChange", "change"], exportAs: ["matButtonToggleGroup"] }, { type: i2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2.FormControlName, selector: "[formControlName]", inputs: ["disabled", "formControlName", "ngModel"], outputs: ["ngModelChange"] }, { type: i18.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i13.MatError, selector: "mat-error", inputs: ["id"] }, { type: i13.MatLabel, selector: "mat-label" }, { type: i2.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i18.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i15.MatRipple, selector: "[mat-ripple], [matRipple]", inputs: ["matRippleRadius", "matRippleDisabled", "matRippleTrigger", "matRippleColor", "matRippleUnbounded", "matRippleCentered", "matRippleAnimation"], exportAs: ["matRipple"] }], pipes: { "date": i18.DatePipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: ConsumptionReportComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'lib-consumption',
                    templateUrl: './consumption.component.html',
                    styles: []
                }]
        }], ctorParameters: function () { return [{ type: i1.Router }, { type: i2.FormBuilder }, { type: i3.StorageService }, { type: i4.ToastrService }, { type: i5.AlertService }, { type: i6.SourceService }, { type: i7.ParameterService }, { type: i8.AggregateDataService }, { type: i9.ReportService }]; }, propDecorators: { monthDateInput: [{
                type: ViewChild,
                args: ['monthDateInput']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uc3VtcHRpb24uY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbGlicmFyeS90c2MtbGl0ZS9zcmMvbGliL3RzYy9jb21wb25lbnQvcmVwb3J0L2NvbnN1bXB0aW9uL2NvbnN1bXB0aW9uLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2xpYnJhcnkvdHNjLWxpdGUvc3JjL2xpYi90c2MvY29tcG9uZW50L3JlcG9ydC9jb25zdW1wdGlvbi9jb25zdW1wdGlvbi5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBVSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFN0QsT0FBTyxFQUEwQixVQUFVLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVwRSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFHM0QsT0FBTyxFQUFFLEtBQUssRUFBVSxNQUFNLDRCQUE0QixDQUFDO0FBQzNELE9BQU8sRUFBRSxTQUFTLEVBQWMsTUFBTSxxQ0FBcUMsQ0FBQztBQVE1RSxjQUFjO0FBQ2QsT0FBTyxFQUFFLGVBQWUsRUFBRSxlQUFlLEVBQUUsWUFBWSxFQUFFLGFBQWEsRUFBRSxXQUFXLEVBQUUsaUJBQWlCLEVBQUUsMkJBQTJCLEVBQUUsb0JBQW9CLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxFQUFXLE1BQU0scUJBQXFCLENBQUM7QUFDOU4sT0FBTyxFQUFFLGNBQWMsRUFBc0IsaUJBQWlCLEVBQUUsWUFBWSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRXBHLE9BQU8sRUFBRSxXQUFXLEVBQWlCLE1BQU0seUJBQXlCLENBQUM7QUFDckUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sOEJBQThCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ2hFLGdCQUFnQjtBQVFo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VSxHQUFHLEtBQUssQ0FBQzthQUMzQjtRQUNMLENBQUM7S0FBQTtJQU1ELGNBQWMsQ0FBQyxLQUFLO1FBQ2hCLElBQUksS0FBSyxFQUFFO1lBQ1AsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixJQUFJLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7WUFDcEcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxtQkFBbUIsZUFBZSxjQUFjLENBQUMsQ0FBQyxDQUFDO1NBQzVFO0lBQ0wsQ0FBQzs7d0hBak1RLDBCQUEwQjs0R0FBMUIsMEJBQTBCLHlLQzlCdkMsaTRSQXVLTTs0RkR6SU8sMEJBQTBCO2tCQU50QyxTQUFTO21CQUFDO29CQUNQLFFBQVEsRUFBRSxpQkFBaUI7b0JBQzNCLFdBQVcsRUFBRSw4QkFBOEI7b0JBQzNDLE1BQU0sRUFBRSxFQUNQO2lCQUNKO3FVQThCZ0MsY0FBYztzQkFBMUMsU0FBUzt1QkFBQyxnQkFBZ0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgRm9ybUJ1aWxkZXIsIEZvcm1Hcm91cCwgVmFsaWRhdG9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgUmVwb3J0RXJyb3JFbnVtIH0gZnJvbSAnLi4vLi4vLi4vZW51bS9lcnJvci5lbnVtJztcblxuaW1wb3J0IHsgQ29uc3VtcHRpb25QYXJhbWV0ZXJNIH0gZnJvbSAnLi4vLi4vLi4vbW9kZWwvcGFyYW1ldGVyLm1vZGVsJztcbmltcG9ydCB7IEFsZXJ0LCBBbGVydE0gfSBmcm9tICcuLi8uLi8uLi9tb2RlbC9hbGVydC5tb2RlbCc7XG5pbXBvcnQgeyBNZXRlckRhdGEsIE1ldGVyRGF0YUkgfSBmcm9tICcuLi8uLi8uLi9tb2RlbC9hZ2dyZWdhdGUtZGF0YS5tb2RlbCc7XG5cbmltcG9ydCB7IFNvdXJjZVNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9zZXJ2aWNlL3NvdXJjZS5zZXJ2aWNlJztcbmltcG9ydCB7IFBhcmFtZXRlclNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9zZXJ2aWNlL3BhcmFtZXRlci5zZXJ2aWNlJztcbmltcG9ydCB7IEFnZ3JlZ2F0ZURhdGFTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vc2VydmljZS9hZ2dyZWdhdGUtZGF0YS5zZXJ2aWNlJztcbmltcG9ydCB7IEFsZXJ0U2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3NlcnZpY2UvYWxlcnQuc2VydmljZSc7XG5pbXBvcnQgeyBSZXBvcnRTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vc2VydmljZS9yZXBvcnQuc2VydmljZSc7XG5cbi8vIHRzYy1saWJyYXJ5XG5pbXBvcnQgeyBCdXR0b25MYWJlbEVudW0sIENPTU1PTl9DT05TVEFOVCwgRmlsZVR5cGVFbnVtLCBGb3JtRXJyb3JFbnVtLCBJbnZhbGlkRm9ybSwgTUFURVJJQUxfQ09OU1RBTlQsIE1hdGVyaWFsRm9ybUZpZWxkQXBwZWFyYW5jZSwgTWVzc2FnZUFsZXJ0SWNvbkVudW0sIE1lc3NhZ2VBbGVydFR5cGVFbnVtLCBTdGF0aWMsIFN0YXRpY0kgfSBmcm9tICdAbGlicmFyeS90c2MtY29tbW9uJztcbmltcG9ydCB7IERhdGVGb3JtYXRFbnVtLCBEYXRlSW5wdXRDb21wb25lbnQsIERhdGVJbnB1dFR5cGVFbnVtLCBEYXRlVHlwZUVudW0gfSBmcm9tICdAbGlicmFyeS9kYXRlJztcbmltcG9ydCB7IFN0b3JhZ2VTZXJ2aWNlIH0gZnJvbSAnQGxpYnJhcnkvc3RvcmFnZS1zZXJ2aWNlJztcbmltcG9ydCB7IFRvYXN0ckNvbG9yLCBUb2FzdHJTZXJ2aWNlIH0gZnJvbSAnQGxpYnJhcnkvdG9hc3RyLXNlcnZpY2UnO1xuaW1wb3J0IHsgQXBwbGljYXRpb25LZXlJRCB9IGZyb20gJ0BsaWJyYXJ5L2FwcGxpY2F0aW9uLXNlcnZpY2UnO1xuLy8gL3RzYy1saWJyYXJ5L1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2xpYi1jb25zdW1wdGlvbicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2NvbnN1bXB0aW9uLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZXM6IFtcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIENvbnN1bXB0aW9uUmVwb3J0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICAgIE1BVEVSSUFMX0NPTlNUQU5UID0gTUFURVJJQUxfQ09OU1RBTlQ7XG4gICAgQ09NTU9OX0NPTlNUQU5UID0gQ09NTU9OX0NPTlNUQU5UO1xuXG4gICAgTWF0ZXJpYWxGb3JtRmllbGRBcHBlYXJhbmNlID0gTWF0ZXJpYWxGb3JtRmllbGRBcHBlYXJhbmNlO1xuICAgIEJ1dHRvbkxhYmVsRW51bSA9IEJ1dHRvbkxhYmVsRW51bTtcbiAgICBEYXRlRm9ybWF0RW51bSA9IERhdGVGb3JtYXRFbnVtO1xuICAgIERhdGVJbnB1dFR5cGVFbnVtID0gRGF0ZUlucHV0VHlwZUVudW07XG4gICAgRGF0ZVR5cGVFbnVtID0gRGF0ZVR5cGVFbnVtO1xuICAgIEZpbGVUeXBlRW51bSA9IEZpbGVUeXBlRW51bTtcbiAgICBGb3JtRXJyb3JFbnVtID0gRm9ybUVycm9yRW51bTtcblxuICAgIHBhZ2VUaXRsZTogc3RyaW5nO1xuXG4gICAgb3JnSUQ6IGFueTtcbiAgICB0aW1lem9uZTogc3RyaW5nO1xuICAgIGFwcGxpY2F0aW9uS2V5SUQ6IHN0cmluZztcblxuICAgIHJlcG9ydERhdGEgPSBbbmV3IE1ldGVyRGF0YSgpXTtcbiAgICBzaG93QWxlcnQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBzaG93TG9hZGVyOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBzb3VyY2VDb25zdW1lclR5cGUgPSBbbmV3IFN0YXRpYygpXTtcbiAgICBjb25zdW1wdGlvblBhcmFtTTogYW55O1xuICAgIHJlcG9ydEFsZXJ0T2JqOiBBbGVydE0gPSBuZXcgQWxlcnQoKTtcblxuICAgIHJlcG9ydEZHOiBGb3JtR3JvdXA7XG5cbiAgICBAVmlld0NoaWxkKCdtb250aERhdGVJbnB1dCcpIG1vbnRoRGF0ZUlucHV0OiBEYXRlSW5wdXRDb21wb25lbnQ7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByb3V0ZXI6IFJvdXRlcixcbiAgICAgICAgcHJpdmF0ZSBmb3JtQnVpbGRlcjogRm9ybUJ1aWxkZXIsXG4gICAgICAgIHByaXZhdGUgc3RvcmFnZVNlcnZpY2U6IFN0b3JhZ2VTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIHRvYXN0U2VydmljZTogVG9hc3RyU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBhbGVydFNlcnZpY2U6IEFsZXJ0U2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBzb3VyY2VTZXJ2aWNlOiBTb3VyY2VTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIHBhcmFtZXRlclNlcnZpY2U6IFBhcmFtZXRlclNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgYWdncmVnYXRlRGF0YVNlcnZpY2U6IEFnZ3JlZ2F0ZURhdGFTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIHJlcG9ydFNlcnZpY2U6IFJlcG9ydFNlcnZpY2VcbiAgICApIHsgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMub3JnSUQgPSB0aGlzLnN0b3JhZ2VTZXJ2aWNlLmdldFN0b3JhZ2UoJ2N1cnJlbnRPcmdJRCcpO1xuICAgICAgICB0aGlzLnRpbWV6b25lID0gdGhpcy5zdG9yYWdlU2VydmljZS5nZXRTdG9yYWdlKCd0aW1lem9uZScpO1xuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uS2V5SUQgPSB0aGlzLnN0b3JhZ2VTZXJ2aWNlLmdldFN0b3JhZ2UoJ2FwcGxpY2F0aW9uS2V5SUQnKTtcblxuICAgICAgICBpZiAodGhpcy5hcHBsaWNhdGlvbktleUlEID09IEFwcGxpY2F0aW9uS2V5SUQuRU5FUkdZX0tFWV9JRCkge1xuICAgICAgICAgICAgdGhpcy5wYWdlVGl0bGUgPSBcIkVuZXJneSBDb25zdW1wdGlvbiBSZXBvcnRcIjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFwcGxpY2F0aW9uS2V5SUQgPT0gQXBwbGljYXRpb25LZXlJRC5XQVRFUl9LRVlfSUQpIHtcbiAgICAgICAgICAgIHRoaXMucGFnZVRpdGxlID0gXCJXYXRlciBDb25zdW1wdGlvbiBSZXBvcnRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVwb3J0RkdJbml0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMucmVwb3J0RkcuZ2V0KCdzb3VyY2VDb25zdW1lci50eXBlJykudmFsdWUgPT0gJ1NPVVJDRScpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0U291cmNlQ29uc3VtZXJUeXBlKCdzb3VyY2UnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0U291cmNlQ29uc3VtZXJUeXBlKCdsb2FkJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdldENvbnN1bXB0aW9uUGFyYW1ldGVyKCk7XG4gICAgfVxuXG4gICAgcmVwb3J0RkdJbml0KCkge1xuICAgICAgICB0aGlzLnJlcG9ydEZHID0gdGhpcy5mb3JtQnVpbGRlci5ncm91cCh7XG4gICAgICAgICAgICBzdGFydERhdGU6IFssIFZhbGlkYXRvcnMucmVxdWlyZWRdLFxuICAgICAgICAgICAgZW5kRGF0ZTogWywgVmFsaWRhdG9ycy5yZXF1aXJlZF0sXG4gICAgICAgICAgICBzb3VyY2VDb25zdW1lcjogdGhpcy5mb3JtQnVpbGRlci5ncm91cCh7XG4gICAgICAgICAgICAgICAgdHlwZTogWydTT1VSQ0UnLCBWYWxpZGF0b3JzLnJlcXVpcmVkXSxcbiAgICAgICAgICAgICAgICBrZXlJRDogWywgVmFsaWRhdG9ycy5yZXF1aXJlZF1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLmZvcm1CdWlsZGVyLmdyb3VwKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBbJycsIFZhbGlkYXRvcnMucmVxdWlyZWRdLFxuICAgICAgICAgICAgICAgIGRzQWdnOiBbJ3N1bScsIFZhbGlkYXRvcnMucmVxdWlyZWRdLFxuICAgICAgICAgICAgICAgIGFnZzogWydzdW0nLCBWYWxpZGF0b3JzLnJlcXVpcmVkXVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpbnRlcnZhbDogWywgVmFsaWRhdG9ycy5yZXF1aXJlZF1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5yZXBvcnRGRy5nZXQoJ3NvdXJjZUNvbnN1bWVyLnR5cGUnKS52YWx1ZUNoYW5nZXMuc3Vic2NyaWJlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09ICdTT1VSQ0UnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRTb3VyY2VDb25zdW1lclR5cGUoJ3NvdXJjZScpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSAnQ09OU1VNRVInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRTb3VyY2VDb25zdW1lclR5cGUoJ2xvYWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0U291cmNlQ29uc3VtZXJUeXBlKHNvdXJjZUNvbnN1bWVyVHlwZSkge1xuICAgICAgICBjb25zdCByZXF1ZXN0RGF0YSA9IHtcbiAgICAgICAgICAgIHR5cGU6IHNvdXJjZUNvbnN1bWVyVHlwZVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc291cmNlQ29uc3VtZXJUeXBlID0gPFN0YXRpY0lbXT5hd2FpdCB0aGlzLnNvdXJjZVNlcnZpY2UuZ2V0U291cmNlQ29uc3VtZXJUeXBlKHRoaXMub3JnSUQsIHJlcXVlc3REYXRhKTtcbiAgICB9XG5cbiAgICBkYXRlSW5wQ2hhbmdlKCkge1xuICAgICAgICBsZXQgc3RhcnREYXRlID0gdGhpcy5tb250aERhdGVJbnB1dC5zdGFydERhdGVGQy52YWx1ZTtcbiAgICAgICAgbGV0IGVuZERhdGUgPSB0aGlzLm1vbnRoRGF0ZUlucHV0LmVuZERhdGVGQy52YWx1ZTtcblxuICAgICAgICB0aGlzLnJlcG9ydEZHLmdldCgnc3RhcnREYXRlJykucGF0Y2hWYWx1ZShzdGFydERhdGUpO1xuICAgICAgICB0aGlzLnJlcG9ydEZHLmdldCgnZW5kRGF0ZScpLnBhdGNoVmFsdWUoZW5kRGF0ZSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0Q29uc3VtcHRpb25QYXJhbWV0ZXIoKSB7XG4gICAgICAgIGNvbnN0IGNvbnN1bXB0aW9uUGFyYW1NID0gPENvbnN1bXB0aW9uUGFyYW1ldGVyTT5hd2FpdCB0aGlzLnBhcmFtZXRlclNlcnZpY2UuZ2V0Q29uc3VtcHRpb25QYXJhbWV0ZXIodGhpcy5vcmdJRCk7XG5cbiAgICAgICAgdGhpcy5jb25zdW1wdGlvblBhcmFtTSA9IGNvbnN1bXB0aW9uUGFyYW1NLmNvbnN1bXB0aW9uUGFyYW1ldGVyO1xuICAgIH1cblxuICAgIHJlcG9ydFN1Ym1pdCgpIHtcbiAgICAgICAgY29uc3QgZm9ybVZhbHVlID0gdGhpcy5yZXBvcnRGRy52YWx1ZTtcbiAgICAgICAgY29uc3QgbW9kaWZpZWRWYWx1ZSA9IHtcbiAgICAgICAgICAgIC4uLmZvcm1WYWx1ZSxcbiAgICAgICAgICAgIHBhcmFtczogW2Zvcm1WYWx1ZS5wYXJhbXNdXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5hbGVydFNlcnZpY2UucmVzZXRBbGVydFByb3BlcnRpZXModGhpcy5yZXBvcnRBbGVydE9iaik7XG5cbiAgICAgICAgaWYgKHRoaXMucmVwb3J0RkcuaW52YWxpZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgZm9ybTonLCB0aGlzLnJlcG9ydEZHLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMudG9hc3RTZXJ2aWNlLm9wZW5Ub2FzdChJbnZhbGlkRm9ybS5JTlZBTElEX0ZPUk1fVElUTEUsIEludmFsaWRGb3JtLklOVkFMSURfRk9STV9NRVNTQUdFLCBUb2FzdHJDb2xvci5FUlJPUik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3dMb2FkZXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5hbGVydFNlcnZpY2UucmVzZXRBbGVydFByb3BlcnRpZXModGhpcy5yZXBvcnRBbGVydE9iaik7XG4gICAgICAgICAgICB0aGlzLnZpZXdSZXBvcnQobW9kaWZpZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyB2aWV3UmVwb3J0KG1vZGlmaWVkVmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IDxNZXRlckRhdGFJW10+YXdhaXQgdGhpcy5hZ2dyZWdhdGVEYXRhU2VydmljZS5nZXRNZXRlckFnZ3JlZ2F0ZURhdGFGb3JSZXBvcnQodGhpcy5vcmdJRCwgbW9kaWZpZWRWYWx1ZSk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdWydkYXRlJ10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydERhdGEgPSByZXN1bHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxlcnRTZXJ2aWNlLnNldEFsZXJ0UHJvcGVydGllcyh0aGlzLnJlcG9ydEFsZXJ0T2JqLCBSZXBvcnRFcnJvckVudW0uREFUQV9OT1RfRk9VTkRfTEFCRUwsIFJlcG9ydEVycm9yRW51bS5EQVRBX05PVF9GT1VORF9NRVNTQUdFLCBNZXNzYWdlQWxlcnRUeXBlRW51bS5XQVJOSU5HLCBNZXNzYWdlQWxlcnRJY29uRW51bS5XQVJOSU5HX0lDT04pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gdmlld1JlcG9ydCgpXCIsIGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMuYWxlcnRTZXJ2aWNlLnNldEFsZXJ0UHJvcGVydGllcyh0aGlzLnJlcG9ydEFsZXJ0T2JqLCBSZXBvcnRFcnJvckVudW0uSU5WQUxJRF9FUlJPUl9MQUJFTCwgUmVwb3J0RXJyb3JFbnVtLklOVkFMSURfRVJST1JfTUVTU0FHRSwgTWVzc2FnZUFsZXJ0VHlwZUVudW0uREFOR0VSLCBNZXNzYWdlQWxlcnRJY29uRW51bS5EQU5HRVJfSUNPTik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnNob3dMb2FkZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGRvd25sb2FkUmVwb3J0KGZvcm1hdDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGZvcm1WYWx1ZSA9IHRoaXMucmVwb3J0RkcudmFsdWU7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkVmFsdWUgPSB7XG4gICAgICAgICAgICAuLi5mb3JtVmFsdWUsXG4gICAgICAgICAgICBwYXJhbXM6IFtmb3JtVmFsdWUucGFyYW1zXVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYWxlcnRTZXJ2aWNlLnJlc2V0QWxlcnRQcm9wZXJ0aWVzKHRoaXMucmVwb3J0QWxlcnRPYmopO1xuXG4gICAgICAgIGlmICh0aGlzLnJlcG9ydEZHLmludmFsaWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJbnZhbGlkIGZvcm06JywgdGhpcy5yZXBvcnRGRy52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEZHLm1hcmtBbGxBc1RvdWNoZWQoKTtcbiAgICAgICAgICAgIHRoaXMudG9hc3RTZXJ2aWNlLm9wZW5Ub2FzdChJbnZhbGlkRm9ybS5JTlZBTElEX0ZPUk1fVElUTEUsIEludmFsaWRGb3JtLklOVkFMSURfRk9STV9NRVNTQUdFLCBUb2FzdHJDb2xvci5FUlJPUik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNob3dMb2FkZXIgPSB0cnVlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0RGF0YSA9IHt9O1xuXG4gICAgICAgICAgICByZXF1ZXN0RGF0YVsncmVxdWVzdCddID0gbW9kaWZpZWRWYWx1ZTtcbiAgICAgICAgICAgIHJlcXVlc3REYXRhWydyZXBvcnROYW1lJ10gPSAnQ29uc3VtcHRpb24gUmVwb3J0JztcbiAgICAgICAgICAgIHJlcXVlc3REYXRhWydyZXBvcnRGb3JtYXQnXSA9IGZvcm1hdDtcblxuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZXBvcnRTZXJ2aWNlLmRvd25sb2FkQ29uc3VtcHRpb25SZXBvcnQodGhpcy5vcmdJRCwgcmVxdWVzdERhdGEpO1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gZG93bmxvYWRDb25zdW1wdGlvblJlcG9ydCgpXCIsIGVycm9yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuc2hvd0xvYWRlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXJyb3JIYW5kbGluZyA9IChmb3JtR3JvdXA6IEZvcm1Hcm91cCwgY29udHJvbFBhdGg6IHN0cmluZywgZXJyb3I6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgICAgICByZXR1cm4gZm9ybUdyb3VwLmdldChjb250cm9sUGF0aCkuaGFzRXJyb3IoZXJyb3IpO1xuICAgIH1cblxuICAgIHNjaGVkdWxlUmVwb3J0KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgYXBwbGljYXRpb25OYW1lID0gdGhpcy5hcHBsaWNhdGlvbktleUlEID09IEFwcGxpY2F0aW9uS2V5SUQuV0FURVJfS0VZX0lEID8gJ3dhdGVyJyA6ICdlbmVyZ3knO1xuICAgICAgICAgICAgdGhpcy5yb3V0ZXIubmF2aWdhdGUoW2BzY2hlZHVsZS1yZXBvcnQvJHthcHBsaWNhdGlvbk5hbWV9LWNvbnN1bXB0aW9uYF0pO1xuICAgICAgICB9XG4gICAgfVxuXG59IiwiPGRpdiBjbGFzcz1cImNhcmQgbWFpbi1jYXJkIGNhcmRPdmVyd3JpdGUgaDEwMFwiPlxuICAgIDxkaXYgY2xhc3M9XCJoZWFkZXJDb250YWluZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImhlYWRlckxlZnRDb250YWluZXJcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlVGl0bGVcIj57eyBwYWdlVGl0bGUgfX08L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJoZWFkZXJSaWdodENvbnRhaW5lclwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImhlYWRlclJpZ2h0Q29udGFpbmVySW5uZXJcIj5cbiAgICAgICAgICAgICAgICA8bWF0LXNsaWRlLXRvZ2dsZSAoY2hhbmdlKT1cInNjaGVkdWxlUmVwb3J0KCRldmVudC5jaGVja2VkKVwiPlNjaGVkdWxlIHJlcG9ydDwvbWF0LXNsaWRlLXRvZ2dsZT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJjYXJkLWJvZHlcIj5cbiAgICAgICAgPGZvcm0gW2Zvcm1Hcm91cF09XCJyZXBvcnRGR1wiIChuZ1N1Ym1pdCk9XCJyZXBvcnRTdWJtaXQoKVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAgICAgICAgIDxkaXYgZm9ybUdyb3VwTmFtZT1cInNvdXJjZUNvbnN1bWVyXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tM1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPG1hdC1idXR0b24tdG9nZ2xlLWdyb3VwIGNsYXNzPVwibWF0QnRuRmlsdGVyXCIgZm9ybUNvbnRyb2xOYW1lPVwidHlwZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxtYXQtYnV0dG9uLXRvZ2dsZSBbdmFsdWVdPVwiJ1NPVVJDRSdcIj5Tb3VyY2U8L21hdC1idXR0b24tdG9nZ2xlPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxtYXQtYnV0dG9uLXRvZ2dsZSBbdmFsdWVdPVwiJ0NPTlNVTUVSJ1wiPkNvbnN1bWVyPC9tYXQtYnV0dG9uLXRvZ2dsZT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbWF0LWJ1dHRvbi10b2dnbGUtZ3JvdXA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bWF0LWVycm9yIGNsYXNzPVwidGV4dE1hdEVycm9yIG1zLTFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiZXJyb3JIYW5kbGluZyhyZXBvcnRGRywgJ3NvdXJjZUNvbnN1bWVyLnR5cGUnLCAncmVxdWlyZWQnKVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IEZvcm1FcnJvckVudW0uUkVRVUlSRUQgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbWF0LWVycm9yPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93IG10LTNcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTNcIj5cbiAgICAgICAgICAgICAgICAgICAgPGxpYi1kYXRlLWlucHV0ICNtb250aERhdGVJbnB1dCAoZW1pdEZpbHRlcik9XCJkYXRlSW5wQ2hhbmdlKClcIiBbbWF0ZXJpYWxGaWVsZFdpZHRoSW5wXT1cInRydWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW21hdGVyaWFsRm9ybUZpZWxkQXBwZWFyYW5jZUlucF09XCJNYXRlcmlhbEZvcm1GaWVsZEFwcGVhcmFuY2UuRk9STV9GSUVMRF9BUFBFQVJBTkNFXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtpc01hbmRhdG9yeUZpZWxkSW5wXT1cInRydWVcIiBbZGF0ZUlucHV0VHlwZUlucF09XCJEYXRlSW5wdXRUeXBlRW51bS5NT05USF9JTlBVVFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbZGF0ZVR5cGVJbnBdPVwiRGF0ZVR5cGVFbnVtLkVYQ0xVU0lWRVwiIFtzaG93RGVmYXVsdER1cmF0aW9uSW5wXT1cInRydWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2xhYmVsSW5wXT1cIidTZWxlY3QgZGF0ZSdcIiBbdGltZXpvbmVJbnBdPVwidGltZXpvbmVcIj48L2xpYi1kYXRlLWlucHV0PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0zXCI+XG4gICAgICAgICAgICAgICAgICAgIDxtYXQtZm9ybS1maWVsZCBjbGFzcz1cIm1hdEZpZWxkV2lkdGgxMDBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2FwcGVhcmFuY2VdPVwiTWF0ZXJpYWxGb3JtRmllbGRBcHBlYXJhbmNlLkZPUk1fRklFTERfQVBQRUFSQU5DRVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPG1hdC1sYWJlbD5TZWxlY3QgYWdncmVnYXRpb248L21hdC1sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxtYXQtc2VsZWN0IGZvcm1Db250cm9sTmFtZT1cImludGVydmFsXCIgcmVxdWlyZWQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG1hdC1vcHRpb24gW3ZhbHVlXT1cIidEQUlMWSdcIj5EYWlseTwvbWF0LW9wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bWF0LW9wdGlvbiBbdmFsdWVdPVwiJ01PTlRITFknXCI+TW9udGhseTwvbWF0LW9wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbWF0LXNlbGVjdD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxtYXQtZXJyb3IgKm5nSWY9XCJlcnJvckhhbmRsaW5nKHJlcG9ydEZHLCAnaW50ZXJ2YWwnLCAncmVxdWlyZWQnKVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IEZvcm1FcnJvckVudW0uUkVRVUlSRUQgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbWF0LWVycm9yPlxuICAgICAgICAgICAgICAgICAgICA8L21hdC1mb3JtLWZpZWxkPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTNcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBmb3JtR3JvdXBOYW1lPVwic291cmNlQ29uc3VtZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxtYXQtZm9ybS1maWVsZCBjbGFzcz1cIm1hdEZpZWxkV2lkdGgxMDBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFthcHBlYXJhbmNlXT1cIk1hdGVyaWFsRm9ybUZpZWxkQXBwZWFyYW5jZS5GT1JNX0ZJRUxEX0FQUEVBUkFOQ0VcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bWF0LWxhYmVsPiBTZWxlY3Qge3sgcmVwb3J0RkcuZ2V0KCdzb3VyY2VDb25zdW1lci50eXBlJykudmFsdWUgPT0gJ1NPVVJDRScgPyAnc291cmNlJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb25zdW1lcicgfX0gdHlwZTwvbWF0LWxhYmVsPlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG1hdC1zZWxlY3QgZm9ybUNvbnRyb2xOYW1lPVwia2V5SURcIiByZXF1aXJlZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJzb3VyY2VDb25zdW1lclR5cGUgJiYgc291cmNlQ29uc3VtZXJUeXBlLmxlbmd0aCA+IDAgJiYgc291cmNlQ29uc3VtZXJUeXBlWzBdWydpZCddOyBlbHNlIG5vU291cmNlQ29uc3VtZXJUeXBlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bWF0LW9wdGlvbiAqbmdGb3I9XCJsZXQgdHlwZSBvZiBzb3VyY2VDb25zdW1lclR5cGVcIiBbdmFsdWVdPVwidHlwZS5rZXlJRFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IHR5cGUubmFtZSB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9tYXQtb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgI25vU291cmNlQ29uc3VtZXJUeXBlPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG1hdC1vcHRpb24gZGlzYWJsZWQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3sgQ09NTU9OX0NPTlNUQU5ULk5PX0RBVEFfRk9VTkQgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbWF0LW9wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L21hdC1zZWxlY3Q+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bWF0LWVycm9yICpuZ0lmPVwiZXJyb3JIYW5kbGluZyhyZXBvcnRGRywgJ3NvdXJjZUNvbnN1bWVyLmtleUlEJywgJ3JlcXVpcmVkJylcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3sgRm9ybUVycm9yRW51bS5SRVFVSVJFRCB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbWF0LWVycm9yPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9tYXQtZm9ybS1maWVsZD5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTNcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBmb3JtR3JvdXBOYW1lPVwicGFyYW1zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bWF0LWZvcm0tZmllbGQgY2xhc3M9XCJtYXRGaWVsZFdpZHRoMTAwXCIgW2FwcGVhcmFuY2VdPVwiTWF0ZXJpYWxGb3JtRmllbGRBcHBlYXJhbmNlLkZPUk1fRklFTERfQVBQRUFSQU5DRVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxtYXQtbGFiZWw+U2VsZWN0IGNvbnN1bXB0aW9uIHBhcmFtZXRlcjwvbWF0LWxhYmVsPlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG1hdC1zZWxlY3QgZm9ybUNvbnRyb2xOYW1lPVwibmFtZVwiIHJlcXVpcmVkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImNvbnN1bXB0aW9uUGFyYW1NICYmIGNvbnN1bXB0aW9uUGFyYW1NLmxlbmd0aCA+IDAgJiYgY29uc3VtcHRpb25QYXJhbU1bMF1bJ2lkJ107IGVsc2Ugbm9Db25zdW1wdGlvblBhcmFtTVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG1hdC1vcHRpb24gKm5nRm9yPVwibGV0IHBhcmFtIG9mIGNvbnN1bXB0aW9uUGFyYW1NXCIgW3ZhbHVlXT1cInBhcmFtLnBhcmFtTWV0cmljXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3sgcGFyYW0ubGFiZWwgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbWF0LW9wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNub0NvbnN1bXB0aW9uUGFyYW1NPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG1hdC1vcHRpb24gZGlzYWJsZWQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3sgQ09NTU9OX0NPTlNUQU5ULk5PX0RBVEFfRk9VTkQgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbWF0LW9wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L21hdC1zZWxlY3Q+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bWF0LWVycm9yICpuZ0lmPVwiZXJyb3JIYW5kbGluZyhyZXBvcnRGRywgJ3BhcmFtcy5uYW1lJywgJ3JlcXVpcmVkJylcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3sgRm9ybUVycm9yRW51bS5SRVFVSVJFRCB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbWF0LWVycm9yPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9tYXQtZm9ybS1maWVsZD5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImQtbm9uZVwiIHR5cGU9XCJzdWJtaXRcIiAjZm9ybVN1Ym1pdEJ0bj48L2J1dHRvbj5cbiAgICAgICAgPC9mb3JtPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTJcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmxvYXQtZW5kXCI+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1wcmltYXJ5XCIgKGNsaWNrKT1cImZvcm1TdWJtaXRCdG4uY2xpY2soKVwiIG1hdFJpcHBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgW21hdFJpcHBsZUNlbnRlcmVkXT1cIk1BVEVSSUFMX0NPTlNUQU5ULk1BVF9SSVBQTEVfQ0VOVEVSXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICB7eyBCdXR0b25MYWJlbEVudW0uUkVBRF9CVE5fTEFCRUwgfX1cbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDxsaWItZG93bmxvYWQtcmVwb3J0IFtleGNsdWRlRmlsZVR5cGVJbnBdPVwiRmlsZVR5cGVFbnVtLkNTVlwiIChmaWxlVHlwZUVtaXR0ZWQpPVwiZG93bmxvYWRSZXBvcnQoJGV2ZW50KVwiPjwvbGliLWRvd25sb2FkLXJlcG9ydD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93IG10LTNcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTJcIj5cbiAgICAgICAgICAgICAgICA8bGliLW1lc3NhZ2UtYWxlcnQgKm5nSWY9XCJyZXBvcnRBbGVydE9iai5zaG93QWxlcnRcIiBbbGFiZWxJbnBdPVwicmVwb3J0QWxlcnRPYmouYWxlcnRMYWJlbFwiXG4gICAgICAgICAgICAgICAgICAgIFtjb250ZW50SW5wXT1cInJlcG9ydEFsZXJ0T2JqLmFsZXJ0Q29udGVudFwiIFttZXNzYWdlQWxlcnRUeXBlSW5wXT1cInJlcG9ydEFsZXJ0T2JqLm1lc3NhZ2VBbGVydFR5cGVcIlxuICAgICAgICAgICAgICAgICAgICBbbWVzc2FnZUFsZXJ0SWNvbklucF09XCJyZXBvcnRBbGVydE9iai5tZXNzYWdlQWxlcnRJY29uXCI+XG4gICAgICAgICAgICAgICAgPC9saWItbWVzc2FnZS1hbGVydD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93IG10LTNcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJBbGlnblwiPlxuICAgICAgICAgICAgICAgIDxsaWItc2tlbGV0b24tbG9hZGVyICpuZ0lmPVwic2hvd0xvYWRlclwiIFtjb3VudF09XCIzXCIgW2FwcGVhcmFuY2VdPVwiJ2NpcmNsZSdcIlxuICAgICAgICAgICAgICAgICAgICBbdGhlbWVdPVwieyBoZWlnaHQ6ICcxNXB4Jywgd2lkdGg6ICcxNXB4JywgJ2JhY2tncm91bmQtY29sb3InOiAnI2U3ZWJmMycgfVwiPjwvbGliLXNrZWxldG9uLWxvYWRlcj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93IG10LTNcIiAqbmdJZj1cInJlcG9ydERhdGEgJiYgcmVwb3J0RGF0YS5sZW5ndGggPiAwICYmIHJlcG9ydERhdGFbMF0uZGF0ZVwiPlxuICAgICAgICAgICAgPHRhYmxlIGNsYXNzPVwidGFibGVcIj5cbiAgICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAgICAgIDx0ciBjbGFzcz1cInRhYmxlSGVhZGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQgYWxpZ249XCJjZW50ZXJcIiBjbGFzcz1cImZ3LWJvbGRcIj4gRGF0ZSA8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGFsaWduPVwiY2VudGVyXCIgY2xhc3M9XCJmdy1ib2xkXCI+IE1ldGVyIG5hbWUgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBhbGlnbj1cImNlbnRlclwiIGNsYXNzPVwiZnctYm9sZFwiPiBQYXJhbWV0ZXIgbmFtZSA8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGFsaWduPVwiY2VudGVyXCIgY2xhc3M9XCJmdy1ib2xkXCI+IE1ldGVyIHN0YXJ0IHJlYWRpbmcgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBhbGlnbj1cImNlbnRlclwiIGNsYXNzPVwiZnctYm9sZFwiPiBNZXRlciBlbmQgcmVhZGluZyA8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGFsaWduPVwiY2VudGVyXCIgY2xhc3M9XCJmdy1ib2xkXCI+IENvbnN1bXB0aW9uIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgPC90Ym9keT5cbiAgICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAgICAgIDx0ciAqbmdGb3I9XCJsZXQgZGF0YSBvZiByZXBvcnREYXRhOyBsZXQgaSA9IGluZGV4XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQgYWxpZ249XCJjZW50ZXJcIiBjbGFzcz1cImNvbFdpZHRoQ29udGFpbmluZ0RhdGVUaW1lXCI+e3sgcm93Py5kYXRlIHwgZGF0ZTogJ2RkLU1NTS15eXl5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSEg6bW06c3MnIH19PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBhbGlnbj1cImNlbnRlclwiPnt7IHJvdz8ubWV0ZXJOYW1lIH19PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBhbGlnbj1cImNlbnRlclwiPnt7IHJvdz8ucGFyYW1ldGVyTmFtZSB9fTwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQgYWxpZ249XCJjZW50ZXJcIj57eyByb3c/Lm1ldGVyU3RhcnRSZWFkaW5nIH19PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBhbGlnbj1cImNlbnRlclwiPnt7IHJvdz8ubWV0ZXJFbmRSZWFkaW5nIH19PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBhbGlnbj1cImNlbnRlclwiPnt7IHJvdz8ubWV0ZXJDb25zdW1wdGlvbiB9fTwvdGQ+XG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgPC90Ym9keT5cbiAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+Il19